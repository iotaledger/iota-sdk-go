
package iota_sdk

// #include <iota_sdk.h>
import "C"

import (
	"bytes"
	"fmt"
	"io"
	"unsafe"
	"encoding/binary"
	"runtime/cgo"
	"math"
	"runtime"
	"sync/atomic"
	"time"
)



// This is needed, because as of go 1.24
// type RustBuffer C.RustBuffer cannot have methods,
// RustBuffer is treated as non-local type
type GoRustBuffer struct {
	inner C.RustBuffer
}

type RustBufferI interface {
	AsReader() *bytes.Reader
	Free()
	ToGoBytes() []byte
	Data() unsafe.Pointer
	Len() uint64
	Capacity() uint64
}

func RustBufferFromExternal(b RustBufferI) GoRustBuffer {
	return GoRustBuffer {
		inner: C.RustBuffer {
			capacity: C.uint64_t(b.Capacity()),
			len: C.uint64_t(b.Len()),
			data: (*C.uchar)(b.Data()),
		},
	}
}

func (cb GoRustBuffer) Capacity() uint64 {
	return uint64(cb.inner.capacity)
}

func (cb GoRustBuffer) Len() uint64 {
	return uint64(cb.inner.len)
}

func (cb GoRustBuffer) Data() unsafe.Pointer {
	return unsafe.Pointer(cb.inner.data)
}

func (cb GoRustBuffer) AsReader() *bytes.Reader {
	b := unsafe.Slice((*byte)(cb.inner.data), C.uint64_t(cb.inner.len))
	return bytes.NewReader(b)
}

func (cb GoRustBuffer) Free() {
	rustCall(func( status *C.RustCallStatus) bool {
		C.ffi_iota_sdk_ffi_rustbuffer_free(cb.inner, status)
		return false
	})
}

func (cb GoRustBuffer) ToGoBytes() []byte {
	return C.GoBytes(unsafe.Pointer(cb.inner.data), C.int(cb.inner.len))
}


func stringToRustBuffer(str string) C.RustBuffer {
	return bytesToRustBuffer([]byte(str))
}

func bytesToRustBuffer(b []byte) C.RustBuffer {
	if len(b) == 0 {
		return C.RustBuffer{}
	}
	// We can pass the pointer along here, as it is pinned
	// for the duration of this call
	foreign := C.ForeignBytes {
		len: C.int(len(b)),
		data: (*C.uchar)(unsafe.Pointer(&b[0])),
	}

	return rustCall(func( status *C.RustCallStatus) C.RustBuffer {
		return C.ffi_iota_sdk_ffi_rustbuffer_from_bytes(foreign, status)
	})
}


type BufLifter[GoType any] interface {
	Lift(value RustBufferI) GoType
}

type BufLowerer[GoType any] interface {
	Lower(value GoType) C.RustBuffer
}

type BufReader[GoType any] interface {
	Read(reader io.Reader) GoType
}

type BufWriter[GoType any] interface {
	Write(writer io.Writer, value GoType)
}

func LowerIntoRustBuffer[GoType any](bufWriter BufWriter[GoType], value GoType) C.RustBuffer {
	// This might be not the most efficient way but it does not require knowing allocation size
	// beforehand
	var buffer bytes.Buffer
	bufWriter.Write(&buffer, value)

	bytes, err := io.ReadAll(&buffer)
	if err != nil {
		panic(fmt.Errorf("reading written data: %w", err))
	}
	return bytesToRustBuffer(bytes)
}

func LiftFromRustBuffer[GoType any](bufReader BufReader[GoType], rbuf RustBufferI) GoType {
	defer rbuf.Free()
	reader := rbuf.AsReader()
	item := bufReader.Read(reader)
	if reader.Len() > 0 {
		// TODO: Remove this
		leftover, _ := io.ReadAll(reader)
		panic(fmt.Errorf("Junk remaining in buffer after lifting: %s", string(leftover)))
	}
	return item
}



func rustCallWithError[E any, U any](converter BufReader[*E], callback func(*C.RustCallStatus) U) (U, *E) {
	var status C.RustCallStatus
	returnValue := callback(&status)
	err := checkCallStatus(converter, status)
	return returnValue, err
}

func checkCallStatus[E any](converter BufReader[*E], status C.RustCallStatus) *E {
	switch status.code {
	case 0:
		return nil
	case 1:
		return LiftFromRustBuffer(converter, GoRustBuffer { inner: status.errorBuf })
	case 2:
		// when the rust code sees a panic, it tries to construct a rustBuffer
		// with the message.  but if that code panics, then it just sends back
		// an empty buffer.
		if status.errorBuf.len > 0 {
			panic(fmt.Errorf("%s", FfiConverterStringINSTANCE.Lift(GoRustBuffer { inner: status.errorBuf })))
		} else {
			panic(fmt.Errorf("Rust panicked while handling Rust panic"))
		}
	default:
		panic(fmt.Errorf("unknown status code: %d", status.code))
	}
}

func checkCallStatusUnknown(status C.RustCallStatus) error {
	switch status.code {
	case 0:
		return nil
	case 1:
		panic(fmt.Errorf("function not returning an error returned an error"))
	case 2:
		// when the rust code sees a panic, it tries to construct a C.RustBuffer
		// with the message.  but if that code panics, then it just sends back
		// an empty buffer.
		if status.errorBuf.len > 0 {
			panic(fmt.Errorf("%s", FfiConverterStringINSTANCE.Lift(GoRustBuffer {
				inner: status.errorBuf,
			})))
		} else {
			panic(fmt.Errorf("Rust panicked while handling Rust panic"))
		}
	default:
		return fmt.Errorf("unknown status code: %d", status.code)
	}
}

func rustCall[U any](callback func(*C.RustCallStatus) U) U {
	returnValue, err := rustCallWithError[error](nil, callback)
	if err != nil {
		panic(err)
	}
	return returnValue
}

type NativeError interface {
	AsError() error
}


func writeInt8(writer io.Writer, value int8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint8(writer io.Writer, value uint8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt16(writer io.Writer, value int16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint16(writer io.Writer, value uint16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt32(writer io.Writer, value int32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint32(writer io.Writer, value uint32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt64(writer io.Writer, value int64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint64(writer io.Writer, value uint64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat32(writer io.Writer, value float32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat64(writer io.Writer, value float64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}


func readInt8(reader io.Reader) int8 {
	var result int8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint8(reader io.Reader) uint8 {
	var result uint8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt16(reader io.Reader) int16 {
	var result int16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint16(reader io.Reader) uint16 {
	var result uint16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt32(reader io.Reader) int32 {
	var result int32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint32(reader io.Reader) uint32 {
	var result uint32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt64(reader io.Reader) int64 {
	var result int64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint64(reader io.Reader) uint64 {
	var result uint64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat32(reader io.Reader) float32 {
	var result float32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat64(reader io.Reader) float64 {
	var result float64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func init() {
        
        uniffiCheckChecksums()
}


func uniffiCheckChecksums() {
	// Get the bindings contract version from our ComponentInterface
	bindingsContractVersion := 29
	// Get the scaffolding contract version by calling the into the dylib
	scaffoldingContractVersion := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint32_t {
		return C.ffi_iota_sdk_ffi_uniffi_contract_version()
	})
	if bindingsContractVersion != int(scaffoldingContractVersion) {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: UniFFI contract version mismatch")
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_active_jwk_from_bcs()
	})
	if checksum != 65415 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_active_jwk_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_active_jwk_to_bcs()
	})
	if checksum != 37978 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_active_jwk_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_address_from_bcs()
	})
	if checksum != 8229 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_address_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_address_to_bcs()
	})
	if checksum != 61852 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_address_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_argument_from_bcs()
	})
	if checksum != 3719 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_argument_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_argument_to_bcs()
	})
	if checksum != 11813 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_argument_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_from_bcs()
	})
	if checksum != 23378 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_to_bcs()
	})
	if checksum != 26245 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_from_bcs()
	})
	if checksum != 39650 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_to_bcs()
	})
	if checksum != 31251 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_base64_decode()
	})
	if checksum != 57367 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_base64_decode: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_base64_encode()
	})
	if checksum != 54791 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_base64_encode: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_from_bcs()
	})
	if checksum != 27639 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_to_bcs()
	})
	if checksum != 45714 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_from_bcs()
	})
	if checksum != 28208 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_to_bcs()
	})
	if checksum != 29002 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_from_bcs()
	})
	if checksum != 13721 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_to_bcs()
	})
	if checksum != 3863 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_bool_from_bcs()
	})
	if checksum != 591 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_bool_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_bool_to_bcs()
	})
	if checksum != 11338 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_bool_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_from_bcs()
	})
	if checksum != 3386 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_to_bcs()
	})
	if checksum != 32242 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_change_epoch_from_bcs()
	})
	if checksum != 49588 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_change_epoch_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_change_epoch_to_bcs()
	})
	if checksum != 4565 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_change_epoch_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_from_bcs()
	})
	if checksum != 16404 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_to_bcs()
	})
	if checksum != 12967 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_changed_object_from_bcs()
	})
	if checksum != 41461 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_changed_object_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_changed_object_to_bcs()
	})
	if checksum != 58498 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_changed_object_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_from_bcs()
	})
	if checksum != 62657 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_to_bcs()
	})
	if checksum != 35587 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_from_bcs()
	})
	if checksum != 1002 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_to_bcs()
	})
	if checksum != 52481 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_from_bcs()
	})
	if checksum != 23217 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_to_bcs()
	})
	if checksum != 48157 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_from_bcs()
	})
	if checksum != 40094 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_to_bcs()
	})
	if checksum != 62034 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_circom_g1_from_bcs()
	})
	if checksum != 60233 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_circom_g1_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_circom_g1_to_bcs()
	})
	if checksum != 19531 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_circom_g1_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_circom_g2_from_bcs()
	})
	if checksum != 1042 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_circom_g2_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_circom_g2_to_bcs()
	})
	if checksum != 8225 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_circom_g2_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_command_argument_error_from_bcs()
	})
	if checksum != 5998 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_command_argument_error_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_command_argument_error_to_bcs()
	})
	if checksum != 30279 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_command_argument_error_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_command_from_bcs()
	})
	if checksum != 25814 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_command_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_command_to_bcs()
	})
	if checksum != 38816 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_command_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_from_bcs()
	})
	if checksum != 22391 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_to_bcs()
	})
	if checksum != 13457 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_from_bcs()
	})
	if checksum != 30528 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_to_bcs()
	})
	if checksum != 35973 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_digest_from_bcs()
	})
	if checksum != 56231 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_digest_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_digest_to_bcs()
	})
	if checksum != 10551 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_digest_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_from_bcs()
	})
	if checksum != 6221 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_to_bcs()
	})
	if checksum != 30464 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_from_bcs()
	})
	if checksum != 39614 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_to_bcs()
	})
	if checksum != 17200 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_from_bcs()
	})
	if checksum != 36284 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_to_bcs()
	})
	if checksum != 6697 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_event_from_bcs()
	})
	if checksum != 11285 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_event_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_event_to_bcs()
	})
	if checksum != 35514 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_event_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_error_from_bcs()
	})
	if checksum != 54349 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_error_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_error_to_bcs()
	})
	if checksum != 1185 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_error_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_status_from_bcs()
	})
	if checksum != 65175 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_status_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_status_to_bcs()
	})
	if checksum != 42821 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_status_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_from_bcs()
	})
	if checksum != 19124 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_from_bcs()
	})
	if checksum != 3465 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_to_bcs()
	})
	if checksum != 166 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_to_bcs()
	})
	if checksum != 35779 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_from_bcs()
	})
	if checksum != 954 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_to_bcs()
	})
	if checksum != 38212 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_from_bcs()
	})
	if checksum != 305 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_to_bcs()
	})
	if checksum != 39838 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_gas_payment_from_bcs()
	})
	if checksum != 20862 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_gas_payment_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_gas_payment_to_bcs()
	})
	if checksum != 2681 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_gas_payment_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_generate_mnemonic()
	})
	if checksum != 15726 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_generate_mnemonic: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_genesis_object_from_bcs()
	})
	if checksum != 15482 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_genesis_object_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_genesis_object_to_bcs()
	})
	if checksum != 63349 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_genesis_object_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_from_bcs()
	})
	if checksum != 21010 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_to_bcs()
	})
	if checksum != 17884 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_hex_decode()
	})
	if checksum != 35424 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_hex_decode: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_hex_encode()
	})
	if checksum != 34343 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_hex_encode: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_i16_from_bcs()
	})
	if checksum != 10273 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_i16_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_i16_to_bcs()
	})
	if checksum != 28969 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_i16_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_i32_from_bcs()
	})
	if checksum != 7849 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_i32_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_i32_to_bcs()
	})
	if checksum != 52773 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_i32_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_i64_from_bcs()
	})
	if checksum != 17714 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_i64_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_i64_to_bcs()
	})
	if checksum != 38028 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_i64_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_i8_from_bcs()
	})
	if checksum != 21810 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_i8_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_i8_to_bcs()
	})
	if checksum != 57592 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_i8_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_id_operation_from_bcs()
	})
	if checksum != 10384 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_id_operation_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_id_operation_to_bcs()
	})
	if checksum != 62670 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_id_operation_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_identifier_from_bcs()
	})
	if checksum != 3668 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_identifier_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_identifier_to_bcs()
	})
	if checksum != 46605 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_identifier_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_input_from_bcs()
	})
	if checksum != 13339 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_input_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_input_to_bcs()
	})
	if checksum != 51152 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_input_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_jwk_from_bcs()
	})
	if checksum != 14752 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_jwk_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_jwk_id_from_bcs()
	})
	if checksum != 22836 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_jwk_id_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_jwk_id_to_bcs()
	})
	if checksum != 2155 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_jwk_id_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_jwk_to_bcs()
	})
	if checksum != 29567 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_jwk_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_make_move_vector_from_bcs()
	})
	if checksum != 17479 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_make_move_vector_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_make_move_vector_to_bcs()
	})
	if checksum != 17288 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_make_move_vector_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_merge_coins_from_bcs()
	})
	if checksum != 33652 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_merge_coins_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_merge_coins_to_bcs()
	})
	if checksum != 40802 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_merge_coins_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_move_call_from_bcs()
	})
	if checksum != 3402 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_move_call_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_move_call_to_bcs()
	})
	if checksum != 40106 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_move_call_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_move_location_from_bcs()
	})
	if checksum != 62161 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_move_location_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_move_location_to_bcs()
	})
	if checksum != 25104 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_move_location_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_move_package_from_bcs()
	})
	if checksum != 922 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_move_package_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_move_package_to_bcs()
	})
	if checksum != 53617 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_move_package_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_move_struct_from_bcs()
	})
	if checksum != 25715 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_move_struct_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_move_struct_to_bcs()
	})
	if checksum != 9518 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_move_struct_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_from_bcs()
	})
	if checksum != 56951 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_to_bcs()
	})
	if checksum != 57074 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_committee_from_bcs()
	})
	if checksum != 49092 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_committee_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_committee_to_bcs()
	})
	if checksum != 11846 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_committee_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_member_from_bcs()
	})
	if checksum != 4473 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_member_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_from_bcs()
	})
	if checksum != 55389 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_to_bcs()
	})
	if checksum != 8657 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_from_bcs()
	})
	if checksum != 26016 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_to_bcs()
	})
	if checksum != 49432 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_multisig_member_to_bcs()
	})
	if checksum != 50267 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_multisig_member_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_data_from_bcs()
	})
	if checksum != 29702 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_data_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_data_to_bcs()
	})
	if checksum != 13288 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_data_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_from_bcs()
	})
	if checksum != 58875 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_id_from_bcs()
	})
	if checksum != 39824 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_id_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_id_to_bcs()
	})
	if checksum != 48535 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_id_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_in_from_bcs()
	})
	if checksum != 36098 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_in_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_in_to_bcs()
	})
	if checksum != 37270 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_in_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_out_from_bcs()
	})
	if checksum != 55820 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_out_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_out_to_bcs()
	})
	if checksum != 57777 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_out_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_reference_from_bcs()
	})
	if checksum != 2613 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_reference_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_reference_to_bcs()
	})
	if checksum != 50964 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_reference_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_object_to_bcs()
	})
	if checksum != 59689 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_object_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_owner_from_bcs()
	})
	if checksum != 60479 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_owner_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_owner_to_bcs()
	})
	if checksum != 40596 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_owner_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_from_bcs()
	})
	if checksum != 19771 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_to_bcs()
	})
	if checksum != 36019 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_from_bcs()
	})
	if checksum != 5683 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_to_bcs()
	})
	if checksum != 26250 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_from_bcs()
	})
	if checksum != 28762 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_to_bcs()
	})
	if checksum != 49182 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_publish_from_bcs()
	})
	if checksum != 59778 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_publish_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_publish_to_bcs()
	})
	if checksum != 44879 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_publish_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_from_bcs()
	})
	if checksum != 17429 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_to_bcs()
	})
	if checksum != 53446 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_from_bcs()
	})
	if checksum != 26826 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_to_bcs()
	})
	if checksum != 20301 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_from_bcs()
	})
	if checksum != 19555 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_to_bcs()
	})
	if checksum != 65529 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_from_bcs()
	})
	if checksum != 44046 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_to_bcs()
	})
	if checksum != 12590 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_from_bcs()
	})
	if checksum != 17047 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_to_bcs()
	})
	if checksum != 2418 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_signed_transaction_from_bcs()
	})
	if checksum != 42264 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_signed_transaction_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_signed_transaction_to_bcs()
	})
	if checksum != 44178 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_signed_transaction_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_simple_signature_from_bcs()
	})
	if checksum != 19746 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_simple_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_simple_signature_to_bcs()
	})
	if checksum != 36033 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_simple_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_split_coins_from_bcs()
	})
	if checksum != 55454 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_split_coins_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_split_coins_to_bcs()
	})
	if checksum != 30667 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_split_coins_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_string_from_bcs()
	})
	if checksum != 53853 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_string_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_string_to_bcs()
	})
	if checksum != 54804 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_string_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_struct_tag_from_bcs()
	})
	if checksum != 24910 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_struct_tag_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_struct_tag_to_bcs()
	})
	if checksum != 23529 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_struct_tag_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_system_package_from_bcs()
	})
	if checksum != 60428 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_system_package_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_system_package_to_bcs()
	})
	if checksum != 40961 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_system_package_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_from_bcs()
	})
	if checksum != 36911 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_effects_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_to_bcs()
	})
	if checksum != 43876 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_effects_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_from_bcs()
	})
	if checksum != 64140 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_to_bcs()
	})
	if checksum != 12420 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_events_from_bcs()
	})
	if checksum != 50477 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_events_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_events_to_bcs()
	})
	if checksum != 49708 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_events_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_from_bcs()
	})
	if checksum != 12318 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_to_bcs()
	})
	if checksum != 34807 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_from_bcs()
	})
	if checksum != 52964 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_kind_from_bcs()
	})
	if checksum != 19749 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_kind_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_kind_to_bcs()
	})
	if checksum != 38945 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_kind_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_to_bcs()
	})
	if checksum != 38438 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_v1_from_bcs()
	})
	if checksum != 56096 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_v1_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transaction_v1_to_bcs()
	})
	if checksum != 62454 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transaction_v1_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transfer_objects_from_bcs()
	})
	if checksum != 34010 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transfer_objects_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_transfer_objects_to_bcs()
	})
	if checksum != 59364 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_transfer_objects_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_type_argument_error_from_bcs()
	})
	if checksum != 30578 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_type_argument_error_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_type_argument_error_to_bcs()
	})
	if checksum != 22531 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_type_argument_error_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_type_origin_from_bcs()
	})
	if checksum != 63210 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_type_origin_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_type_origin_to_bcs()
	})
	if checksum != 62869 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_type_origin_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_type_tag_from_bcs()
	})
	if checksum != 31167 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_type_tag_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_type_tag_to_bcs()
	})
	if checksum != 57365 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_type_tag_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_u16_from_bcs()
	})
	if checksum != 3653 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_u16_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_u16_to_bcs()
	})
	if checksum != 13254 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_u16_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_u32_from_bcs()
	})
	if checksum != 335 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_u32_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_u32_to_bcs()
	})
	if checksum != 36384 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_u32_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_u64_from_bcs()
	})
	if checksum != 63829 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_u64_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_u64_to_bcs()
	})
	if checksum != 2947 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_u64_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_u8_from_bcs()
	})
	if checksum != 34764 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_u8_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_u8_to_bcs()
	})
	if checksum != 59020 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_u8_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_from_bcs()
	})
	if checksum != 6308 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_to_bcs()
	})
	if checksum != 46464 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_from_bcs()
	})
	if checksum != 28910 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_to_bcs()
	})
	if checksum != 38998 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_upgrade_from_bcs()
	})
	if checksum != 19484 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_upgrade_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_upgrade_info_from_bcs()
	})
	if checksum != 58871 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_upgrade_info_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_upgrade_info_to_bcs()
	})
	if checksum != 8867 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_upgrade_info_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_upgrade_to_bcs()
	})
	if checksum != 32303 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_upgrade_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_user_signature_from_bcs()
	})
	if checksum != 8567 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_user_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_user_signature_to_bcs()
	})
	if checksum != 47630 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_user_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_from_bcs()
	})
	if checksum != 21169 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_to_bcs()
	})
	if checksum != 44404 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_committee_from_bcs()
	})
	if checksum != 30352 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_committee_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_from_bcs()
	})
	if checksum != 27463 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_to_bcs()
	})
	if checksum != 54694 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_committee_to_bcs()
	})
	if checksum != 31448 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_committee_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_from_bcs()
	})
	if checksum != 28604 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_to_bcs()
	})
	if checksum != 35325 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_signature_from_bcs()
	})
	if checksum != 57394 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_signature_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_validator_signature_to_bcs()
	})
	if checksum != 19559 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_validator_signature_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_version_assignment_from_bcs()
	})
	if checksum != 23398 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_version_assignment_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_version_assignment_to_bcs()
	})
	if checksum != 44956 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_version_assignment_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_from_bcs()
	})
	if checksum != 48317 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_to_bcs()
	})
	if checksum != 50917 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_from_bcs()
	})
	if checksum != 47140 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_to_bcs()
	})
	if checksum != 58412 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_from_bcs()
	})
	if checksum != 13910 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_to_bcs()
	})
	if checksum != 22664 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_from_bcs()
	})
	if checksum != 35391 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_from_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_to_bcs()
	})
	if checksum != 39685 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_to_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_address_to_bytes()
	})
	if checksum != 57710 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_address_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_address_to_hex()
	})
	if checksum != 22032 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_address_to_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_argument_get_nested_result()
	})
	if checksum != 53358 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_argument_get_nested_result: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_public_key()
	})
	if checksum != 53765 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_scheme()
	})
	if checksum != 8293 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_sign_checkpoint_summary()
	})
	if checksum != 1487 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_sign_checkpoint_summary: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_try_sign()
	})
	if checksum != 59341 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_try_sign: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_verifying_key()
	})
	if checksum != 36438 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_verifying_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bls12381publickey_to_bytes()
	})
	if checksum != 9890 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bls12381publickey_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bls12381signature_to_bytes()
	})
	if checksum != 56969 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bls12381signature_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_public_key()
	})
	if checksum != 59353 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_verify()
	})
	if checksum != 54718 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_padded()
	})
	if checksum != 44301 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_padded: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_unpadded()
	})
	if checksum != 33350 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_unpadded: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_digest()
	})
	if checksum != 52811 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_version_assignments()
	})
	if checksum != 52539 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_version_assignments: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepoch_computation_charge()
	})
	if checksum != 25355 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepoch_computation_charge: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch()
	})
	if checksum != 49990 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch_start_timestamp_ms()
	})
	if checksum != 57669 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch_start_timestamp_ms: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepoch_non_refundable_storage_fee()
	})
	if checksum != 28070 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepoch_non_refundable_storage_fee: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepoch_protocol_version()
	})
	if checksum != 40406 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepoch_protocol_version: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_charge()
	})
	if checksum != 35870 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_charge: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_rebate()
	})
	if checksum != 21786 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_rebate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepoch_system_packages()
	})
	if checksum != 55002 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepoch_system_packages: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge()
	})
	if checksum != 4379 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge_burned()
	})
	if checksum != 17712 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge_burned: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch()
	})
	if checksum != 52992 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch_start_timestamp_ms()
	})
	if checksum != 35398 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch_start_timestamp_ms: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_non_refundable_storage_fee()
	})
	if checksum != 38234 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv2_non_refundable_storage_fee: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_protocol_version()
	})
	if checksum != 16414 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv2_protocol_version: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_charge()
	})
	if checksum != 4751 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_charge: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_rebate()
	})
	if checksum != 52102 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_rebate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_system_packages()
	})
	if checksum != 48705 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv2_system_packages: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge()
	})
	if checksum != 29832 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge_burned()
	})
	if checksum != 40461 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge_burned: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_eligible_active_validators()
	})
	if checksum != 6336 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_eligible_active_validators: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch()
	})
	if checksum != 4081 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch_start_timestamp_ms()
	})
	if checksum != 22703 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch_start_timestamp_ms: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_non_refundable_storage_fee()
	})
	if checksum != 5224 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_non_refundable_storage_fee: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_protocol_version()
	})
	if checksum != 48266 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_protocol_version: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_charge()
	})
	if checksum != 7690 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_charge: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_rebate()
	})
	if checksum != 54084 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_rebate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_system_packages()
	})
	if checksum != 38309 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_changeepochv3_system_packages: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_as_ecmh_live_object_set_digest()
	})
	if checksum != 41616 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_as_ecmh_live_object_set_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_is_ecmh_live_object_set()
	})
	if checksum != 22589 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_is_ecmh_live_object_set: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_digest()
	})
	if checksum != 22345 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_transaction_info()
	})
	if checksum != 56465 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_transaction_info: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_checkpoint_commitments()
	})
	if checksum != 61600 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_checkpoint_commitments: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_content_digest()
	})
	if checksum != 31627 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_content_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_digest()
	})
	if checksum != 14291 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_end_of_epoch_data()
	})
	if checksum != 49930 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_end_of_epoch_data: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch()
	})
	if checksum != 35840 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch_rolling_gas_cost_summary()
	})
	if checksum != 10205 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch_rolling_gas_cost_summary: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_network_total_transactions()
	})
	if checksum != 50558 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_network_total_transactions: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_previous_digest()
	})
	if checksum != 933 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_previous_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_sequence_number()
	})
	if checksum != 33896 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_sequence_number: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message()
	})
	if checksum != 59962 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message_hex()
	})
	if checksum != 52548 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_timestamp_ms()
	})
	if checksum != 62474 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_timestamp_ms: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_version_specific_data()
	})
	if checksum != 43828 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_version_specific_data: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_effects()
	})
	if checksum != 54822 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_effects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_signatures()
	})
	if checksum != 36925 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_signatures: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_transaction()
	})
	if checksum != 58570 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_transaction: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_dry_run()
	})
	if checksum != 10983 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_dry_run: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute()
	})
	if checksum != 45165 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute_with_sponsor()
	})
	if checksum != 64410 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute_with_sponsor: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_expiration()
	})
	if checksum != 32958 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_expiration: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_finish()
	})
	if checksum != 56677 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_finish: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas()
	})
	if checksum != 522 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_budget()
	})
	if checksum != 27427 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_budget: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_price()
	})
	if checksum != 56003 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_price: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_station_sponsor()
	})
	if checksum != 25572 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_station_sponsor: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_make_move_vec()
	})
	if checksum != 4858 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_make_move_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_merge_coins()
	})
	if checksum != 43478 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_merge_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_move_call()
	})
	if checksum != 13617 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_move_call: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_publish()
	})
	if checksum != 25909 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_publish: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_coins()
	})
	if checksum != 65187 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_iota()
	})
	if checksum != 65011 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_iota: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_split_coins()
	})
	if checksum != 2932 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_split_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_sponsor()
	})
	if checksum != 44990 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_sponsor: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_stake()
	})
	if checksum != 9961 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_stake: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_transfer_objects()
	})
	if checksum != 23790 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_transfer_objects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_unstake()
	})
	if checksum != 40181 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_unstake: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_upgrade()
	})
	if checksum != 59977 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_upgrade: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_coin_balance()
	})
	if checksum != 29928 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_coin_balance: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_coin_coin_type()
	})
	if checksum != 18211 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_coin_coin_type: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_coin_id()
	})
	if checksum != 40013 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_coin_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_commit_timestamp_ms()
	})
	if checksum != 14198 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_commit_timestamp_ms: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_commit_digest()
	})
	if checksum != 34585 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_commit_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_determined_version_assignments()
	})
	if checksum != 32713 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_determined_version_assignments: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_epoch()
	})
	if checksum != 1832 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_round()
	})
	if checksum != 6355 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_round: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_sub_dag_index()
	})
	if checksum != 56426 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_sub_dag_index: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_as_cancelled_transactions()
	})
	if checksum != 59888 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_as_cancelled_transactions: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_is_cancelled_transactions()
	})
	if checksum != 10241 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_is_cancelled_transactions: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_digest_to_base58()
	})
	if checksum != 54638 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_digest_to_base58: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_digest_to_bytes()
	})
	if checksum != 14244 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_digest_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_public_key()
	})
	if checksum != 55389 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_scheme()
	})
	if checksum != 8128 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_personal_message()
	})
	if checksum != 59851 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_personal_message: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_transaction()
	})
	if checksum != 4951 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_transaction: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bech32()
	})
	if checksum != 64514 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bech32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bytes()
	})
	if checksum != 26261 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_der()
	})
	if checksum != 61433 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_pem()
	})
	if checksum != 34166 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign()
	})
	if checksum != 39795 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_simple()
	})
	if checksum != 56024 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_user()
	})
	if checksum != 42020 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_user: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_verifying_key()
	})
	if checksum != 59162 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_verifying_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_derive_address()
	})
	if checksum != 37757 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_derive_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_scheme()
	})
	if checksum != 3041 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_bytes()
	})
	if checksum != 16656 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_flagged_bytes()
	})
	if checksum != 62359 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_flagged_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519signature_to_bytes()
	})
	if checksum != 31911 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519signature_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_public_key()
	})
	if checksum != 55026 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_der()
	})
	if checksum != 56779 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_pem()
	})
	if checksum != 56327 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify()
	})
	if checksum != 24673 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_simple()
	})
	if checksum != 29563 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_user()
	})
	if checksum != 43622 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_user: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_key()
	})
	if checksum != 10295 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_observations()
	})
	if checksum != 58594 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_observations: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request()
	})
	if checksum != 13326 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_faucetclient_request: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_and_wait()
	})
	if checksum != 22484 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_and_wait: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_status()
	})
	if checksum != 48258 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_status: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_genesisobject_data()
	})
	if checksum != 26598 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_genesisobject_data: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_id()
	})
	if checksum != 9601 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_type()
	})
	if checksum != 32731 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_type: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_genesisobject_owner()
	})
	if checksum != 50201 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_genesisobject_owner: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_genesisobject_version()
	})
	if checksum != 36305 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_genesisobject_version: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_genesistransaction_events()
	})
	if checksum != 64664 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_genesistransaction_events: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_genesistransaction_objects()
	})
	if checksum != 14715 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_genesistransaction_objects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_active_validators()
	})
	if checksum != 29559 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_active_validators: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_balance()
	})
	if checksum != 9953 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_balance: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_chain_id()
	})
	if checksum != 45619 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_chain_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoint()
	})
	if checksum != 9094 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoint: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoints()
	})
	if checksum != 36867 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoints: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coin_metadata()
	})
	if checksum != 10872 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coin_metadata: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coins()
	})
	if checksum != 47450 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx()
	})
	if checksum != 7552 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx_kind()
	})
	if checksum != 37663 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx_kind: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_field()
	})
	if checksum != 12346 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_field: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_fields()
	})
	if checksum != 14745 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_fields: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_object_field()
	})
	if checksum != 28336 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_object_field: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch()
	})
	if checksum != 62805 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_checkpoints()
	})
	if checksum != 29086 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_checkpoints: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_transaction_blocks()
	})
	if checksum != 61978 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_transaction_blocks: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_events()
	})
	if checksum != 20245 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_events: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_execute_tx()
	})
	if checksum != 65277 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_execute_tx: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_gas_coins()
	})
	if checksum != 24826 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_gas_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_default_name()
	})
	if checksum != 53764 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_default_name: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_lookup()
	})
	if checksum != 20908 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_lookup: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_registrations()
	})
	if checksum != 44467 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_registrations: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_finalized()
	})
	if checksum != 8647 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_finalized: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_indexed_on_node()
	})
	if checksum != 20156 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_indexed_on_node: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_latest_checkpoint_sequence_number()
	})
	if checksum != 40336 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_latest_checkpoint_sequence_number: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_max_page_size()
	})
	if checksum != 44733 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_max_page_size: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents()
	})
	if checksum != 40412 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents_bcs()
	})
	if checksum != 49694 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_function()
	})
	if checksum != 16965 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_function: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_module()
	})
	if checksum != 51355 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_module: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object()
	})
	if checksum != 27424 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object_bcs()
	})
	if checksum != 29653 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object_bcs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_objects()
	})
	if checksum != 14040 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_objects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package()
	})
	if checksum != 7913 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_latest()
	})
	if checksum != 55024 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_latest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_versions()
	})
	if checksum != 34213 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_versions: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_packages()
	})
	if checksum != 45891 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_packages: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_protocol_config()
	})
	if checksum != 58559 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_protocol_config: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_reference_gas_price()
	})
	if checksum != 39065 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_reference_gas_price: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_run_query()
	})
	if checksum != 54586 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_run_query: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_service_config()
	})
	if checksum != 11931 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_service_config: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_set_rpc_server()
	})
	if checksum != 31958 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_set_rpc_server: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_supply()
	})
	if checksum != 21504 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_supply: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks()
	})
	if checksum != 9583 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_digest()
	})
	if checksum != 24739 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_seq_num()
	})
	if checksum != 18624 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_seq_num: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction()
	})
	if checksum != 58857 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_data_effects()
	})
	if checksum != 53397 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_data_effects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_effects()
	})
	if checksum != 27010 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_effects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions()
	})
	if checksum != 20537 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_data_effects()
	})
	if checksum != 46218 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_data_effects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_effects()
	})
	if checksum != 25858 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_effects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_wait_for_tx()
	})
	if checksum != 25664 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_graphqlclient_wait_for_tx: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_identifier_as_str()
	})
	if checksum != 63815 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_identifier_as_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_makemovevector_elements()
	})
	if checksum != 20773 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_makemovevector_elements: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_makemovevector_type_tag()
	})
	if checksum != 31154 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_makemovevector_type_tag: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_mergecoins_coin()
	})
	if checksum != 38884 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_mergecoins_coin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_mergecoins_coins_to_merge()
	})
	if checksum != 44350 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_mergecoins_coins_to_merge: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movecall_arguments()
	})
	if checksum != 17202 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movecall_arguments: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movecall_function()
	})
	if checksum != 2751 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movecall_function: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movecall_module()
	})
	if checksum != 35106 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movecall_module: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movecall_package()
	})
	if checksum != 24481 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movecall_package: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movecall_type_arguments()
	})
	if checksum != 46468 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movecall_type_arguments: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movefunction_is_entry()
	})
	if checksum != 5688 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movefunction_is_entry: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movefunction_name()
	})
	if checksum != 15389 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movefunction_name: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movefunction_parameters()
	})
	if checksum != 34373 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movefunction_parameters: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movefunction_return_type()
	})
	if checksum != 2574 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movefunction_return_type: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movefunction_type_parameters()
	})
	if checksum != 3798 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movefunction_type_parameters: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movefunction_visibility()
	})
	if checksum != 3892 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movefunction_visibility: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackage_id()
	})
	if checksum != 28435 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackage_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackage_linkage_table()
	})
	if checksum != 40601 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackage_linkage_table: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackage_modules()
	})
	if checksum != 49866 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackage_modules: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackage_type_origin_table()
	})
	if checksum != 7308 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackage_type_origin_table: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackage_version()
	})
	if checksum != 22970 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackage_version: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_dependencies()
	})
	if checksum != 61113 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackagedata_dependencies: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_digest()
	})
	if checksum != 31652 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackagedata_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_modules()
	})
	if checksum != 63377 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackagedata_modules: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_base64()
	})
	if checksum != 1835 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_base64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_json()
	})
	if checksum != 3153 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_json: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_bitmap()
	})
	if checksum != 41489 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_bitmap: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_committee()
	})
	if checksum != 17432 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_committee: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_signatures()
	})
	if checksum != 5488 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_signatures: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_finish()
	})
	if checksum != 31014 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_finish: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_verifier()
	})
	if checksum != 36902 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_verifier: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_signature()
	})
	if checksum != 48209 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_signature: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_verifier()
	})
	if checksum != 10820 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_verifier: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_derive_address()
	})
	if checksum != 26282 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_derive_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_is_valid()
	})
	if checksum != 45468 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_is_valid: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_members()
	})
	if checksum != 62870 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_members: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_scheme()
	})
	if checksum != 15458 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_threshold()
	})
	if checksum != 21653 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_threshold: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmember_public_key()
	})
	if checksum != 7804 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmember_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmember_weight()
	})
	if checksum != 57194 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmember_weight: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519()
	})
	if checksum != 8241 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519_opt()
	})
	if checksum != 28021 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1()
	})
	if checksum != 52073 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1_opt()
	})
	if checksum != 40194 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1()
	})
	if checksum != 38170 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1_opt()
	})
	if checksum != 28963 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin()
	})
	if checksum != 17714 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin_opt()
	})
	if checksum != 23106 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_ed25519()
	})
	if checksum != 1939 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_ed25519: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256k1()
	})
	if checksum != 49521 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256k1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256r1()
	})
	if checksum != 16265 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256r1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_zklogin()
	})
	if checksum != 37193 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_zklogin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519()
	})
	if checksum != 22855 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519_opt()
	})
	if checksum != 56690 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1()
	})
	if checksum != 49085 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1_opt()
	})
	if checksum != 26984 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1()
	})
	if checksum != 57510 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1_opt()
	})
	if checksum != 12419 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin()
	})
	if checksum != 39624 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin_opt()
	})
	if checksum != 34526 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_ed25519()
	})
	if checksum != 18913 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_ed25519: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256k1()
	})
	if checksum != 16841 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256k1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256r1()
	})
	if checksum != 51171 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256r1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_zklogin()
	})
	if checksum != 65193 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_zklogin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_verify()
	})
	if checksum != 49901 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigverifier_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_with_zklogin_verifier()
	})
	if checksum != 20062 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigverifier_with_zklogin_verifier: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_zklogin_verifier()
	})
	if checksum != 5971 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_multisigverifier_zklogin_verifier: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_name_format()
	})
	if checksum != 66 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_name_format: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_name_is_sln()
	})
	if checksum != 9860 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_name_is_sln: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_name_is_subname()
	})
	if checksum != 22382 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_name_is_subname: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_name_label()
	})
	if checksum != 9695 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_name_label: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_name_labels()
	})
	if checksum != 44675 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_name_labels: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_name_num_labels()
	})
	if checksum != 62037 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_name_num_labels: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_name_parent()
	})
	if checksum != 40819 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_name_parent: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_nameregistration_expiration_timestamp_ms()
	})
	if checksum != 13855 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_nameregistration_expiration_timestamp_ms: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_nameregistration_id()
	})
	if checksum != 17049 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_nameregistration_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_nameregistration_name()
	})
	if checksum != 16565 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_nameregistration_name: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_nameregistration_name_str()
	})
	if checksum != 19903 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_nameregistration_name_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_as_package()
	})
	if checksum != 21763 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_as_package: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_as_package_opt()
	})
	if checksum != 61571 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_as_package_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_as_struct()
	})
	if checksum != 5928 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_as_struct: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_as_struct_opt()
	})
	if checksum != 49657 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_as_struct_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_data()
	})
	if checksum != 4330 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_data: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_digest()
	})
	if checksum != 48655 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_object_id()
	})
	if checksum != 6575 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_object_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_object_ref()
	})
	if checksum != 13587 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_object_ref: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_object_type()
	})
	if checksum != 1843 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_object_type: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_owner()
	})
	if checksum != 3724 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_owner: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_previous_transaction()
	})
	if checksum != 4427 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_previous_transaction: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_storage_rebate()
	})
	if checksum != 24969 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_storage_rebate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_object_version()
	})
	if checksum != 18433 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_object_version: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objectdata_as_package_opt()
	})
	if checksum != 50334 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objectdata_as_package_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objectdata_as_struct_opt()
	})
	if checksum != 8956 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objectdata_as_struct_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objectdata_is_package()
	})
	if checksum != 11147 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objectdata_is_package: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objectdata_is_struct()
	})
	if checksum != 58579 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objectdata_is_struct: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objectid_derive_dynamic_child_id()
	})
	if checksum != 47819 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objectid_derive_dynamic_child_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objectid_to_address()
	})
	if checksum != 21880 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objectid_to_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objectid_to_bytes()
	})
	if checksum != 38367 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objectid_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objectid_to_hex()
	})
	if checksum != 4418 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objectid_to_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct()
	})
	if checksum != 15094 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct_opt()
	})
	if checksum != 14701 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objecttype_is_package()
	})
	if checksum != 40585 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objecttype_is_package: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_objecttype_is_struct()
	})
	if checksum != 33698 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_objecttype_is_struct: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_as_address()
	})
	if checksum != 19200 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_as_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_as_address_opt()
	})
	if checksum != 36265 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_as_address_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_as_object()
	})
	if checksum != 42917 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_as_object: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_as_object_opt()
	})
	if checksum != 17159 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_as_object_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_as_shared()
	})
	if checksum != 56096 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_as_shared: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_as_shared_opt()
	})
	if checksum != 4209 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_as_shared_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_is_address()
	})
	if checksum != 26982 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_is_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_is_immutable()
	})
	if checksum != 23542 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_is_immutable: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_is_object()
	})
	if checksum != 29892 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_is_object: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_owner_is_shared()
	})
	if checksum != 6506 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_owner_is_shared: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_authenticator_data()
	})
	if checksum != 36642 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_authenticator_data: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_challenge()
	})
	if checksum != 28147 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_challenge: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_client_data_json()
	})
	if checksum != 26196 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_client_data_json: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_public_key()
	})
	if checksum != 18555 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_signature()
	})
	if checksum != 5489 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_signature: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_derive_address()
	})
	if checksum != 61803 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_derive_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_inner()
	})
	if checksum != 65008 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_inner: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_passkeyverifier_verify()
	})
	if checksum != 19101 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_passkeyverifier_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_personalmessage_message_bytes()
	})
	if checksum != 347 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_personalmessage_message_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest()
	})
	if checksum != 39344 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest_hex()
	})
	if checksum != 63754 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_commands()
	})
	if checksum != 49868 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_commands: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_inputs()
	})
	if checksum != 25458 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_inputs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_publish_dependencies()
	})
	if checksum != 57311 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_publish_dependencies: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_publish_modules()
	})
	if checksum != 26011 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_publish_modules: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_public_key()
	})
	if checksum != 27155 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_scheme()
	})
	if checksum != 60810 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_personal_message()
	})
	if checksum != 53577 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_personal_message: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_transaction()
	})
	if checksum != 34208 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_transaction: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bech32()
	})
	if checksum != 60488 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bech32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bytes()
	})
	if checksum != 18583 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_der()
	})
	if checksum != 65507 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_pem()
	})
	if checksum != 12369 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign()
	})
	if checksum != 5798 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_simple()
	})
	if checksum != 11597 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_user()
	})
	if checksum != 20597 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_user: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_verifying_key()
	})
	if checksum != 51137 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_verifying_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_derive_address()
	})
	if checksum != 48490 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_derive_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_scheme()
	})
	if checksum != 60874 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_bytes()
	})
	if checksum != 49170 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_flagged_bytes()
	})
	if checksum != 46673 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_flagged_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1signature_to_bytes()
	})
	if checksum != 49705 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1signature_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_simple()
	})
	if checksum != 36777 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_user()
	})
	if checksum != 26362 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_user: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_public_key()
	})
	if checksum != 56083 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_der()
	})
	if checksum != 21325 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_pem()
	})
	if checksum != 29137 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify()
	})
	if checksum != 27904 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_simple()
	})
	if checksum != 35045 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_user()
	})
	if checksum != 41639 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_user: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_public_key()
	})
	if checksum != 58075 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_scheme()
	})
	if checksum != 20973 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_personal_message()
	})
	if checksum != 113 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_personal_message: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_transaction()
	})
	if checksum != 1687 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_transaction: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bech32()
	})
	if checksum != 4230 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bech32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bytes()
	})
	if checksum != 8648 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_der()
	})
	if checksum != 48507 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_pem()
	})
	if checksum != 34634 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign()
	})
	if checksum != 39126 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_simple()
	})
	if checksum != 57038 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_user()
	})
	if checksum != 36924 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_user: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_verifying_key()
	})
	if checksum != 55895 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_verifying_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_derive_address()
	})
	if checksum != 27344 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_derive_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_scheme()
	})
	if checksum != 48083 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_bytes()
	})
	if checksum != 21066 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_flagged_bytes()
	})
	if checksum != 14205 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_flagged_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1signature_to_bytes()
	})
	if checksum != 64948 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1signature_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_simple()
	})
	if checksum != 18491 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_user()
	})
	if checksum != 19940 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_user: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_public_key()
	})
	if checksum != 35474 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_der()
	})
	if checksum != 49763 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_pem()
	})
	if checksum != 51401 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify()
	})
	if checksum != 32594 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_simple()
	})
	if checksum != 35191 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_user()
	})
	if checksum != 46052 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_user: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_public_key()
	})
	if checksum != 11009 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_scheme()
	})
	if checksum != 19826 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_personal_message()
	})
	if checksum != 2940 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_personal_message: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_transaction()
	})
	if checksum != 35221 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_transaction: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bech32()
	})
	if checksum != 4776 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bech32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bytes()
	})
	if checksum != 1555 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_der()
	})
	if checksum != 22161 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_pem()
	})
	if checksum != 18854 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign()
	})
	if checksum != 52266 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign_user()
	})
	if checksum != 17485 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign_user: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_verifying_key()
	})
	if checksum != 20797 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplekeypair_verifying_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key()
	})
	if checksum != 36693 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key_opt()
	})
	if checksum != 11858 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig()
	})
	if checksum != 56126 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig_opt()
	})
	if checksum != 33862 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_ed25519()
	})
	if checksum != 64494 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_ed25519: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256k1()
	})
	if checksum != 39262 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256k1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256r1()
	})
	if checksum != 49536 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256r1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_scheme()
	})
	if checksum != 30423 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key()
	})
	if checksum != 51778 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key_opt()
	})
	if checksum != 20475 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig()
	})
	if checksum != 36141 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig_opt()
	})
	if checksum != 16111 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key()
	})
	if checksum != 25197 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key_opt()
	})
	if checksum != 22487 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig()
	})
	if checksum != 30390 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig_opt()
	})
	if checksum != 51961 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simplesignature_to_bytes()
	})
	if checksum != 28081 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simplesignature_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simpleverifier_verify()
	})
	if checksum != 8441 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simpleverifier_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_public_key()
	})
	if checksum != 58667 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_scheme()
	})
	if checksum != 7296 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_der()
	})
	if checksum != 3936 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_pem()
	})
	if checksum != 55066 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_verify()
	})
	if checksum != 22348 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_splitcoins_amounts()
	})
	if checksum != 10377 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_splitcoins_amounts: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_splitcoins_coin()
	})
	if checksum != 17278 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_splitcoins_coin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_structtag_address()
	})
	if checksum != 20393 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_structtag_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type()
	})
	if checksum != 37745 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type_opt()
	})
	if checksum != 65306 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_structtag_module()
	})
	if checksum != 28022 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_structtag_module: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_structtag_name()
	})
	if checksum != 62865 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_structtag_name: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_structtag_type_args()
	})
	if checksum != 48594 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_structtag_type_args: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_systempackage_dependencies()
	})
	if checksum != 25411 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_systempackage_dependencies: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_systempackage_modules()
	})
	if checksum != 23597 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_systempackage_modules: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_systempackage_version()
	})
	if checksum != 39738 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_systempackage_version: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transaction_as_v1()
	})
	if checksum != 53004 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transaction_as_v1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transaction_digest()
	})
	if checksum != 52429 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transaction_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transaction_expiration()
	})
	if checksum != 47752 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transaction_expiration: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transaction_gas_payment()
	})
	if checksum != 5316 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transaction_gas_payment: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transaction_kind()
	})
	if checksum != 49492 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transaction_kind: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transaction_sender()
	})
	if checksum != 38190 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transaction_sender: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest()
	})
	if checksum != 21125 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest_hex()
	})
	if checksum != 44484 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transaction_to_base64()
	})
	if checksum != 51030 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transaction_to_base64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_execute_with_gas_station()
	})
	if checksum != 6268 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_execute_with_gas_station: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_expiration()
	})
	if checksum != 5328 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_expiration: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_finish()
	})
	if checksum != 39582 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_finish: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas()
	})
	if checksum != 23371 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_budget()
	})
	if checksum != 48686 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_budget: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_price()
	})
	if checksum != 7437 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_price: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_station_sponsor()
	})
	if checksum != 41106 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_station_sponsor: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_make_move_vec()
	})
	if checksum != 64922 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_make_move_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_merge_coins()
	})
	if checksum != 136 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_merge_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_move_call()
	})
	if checksum != 22281 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_move_call: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_publish()
	})
	if checksum != 22805 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_publish: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_coins()
	})
	if checksum != 6220 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_iota()
	})
	if checksum != 2185 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_iota: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_split_coins()
	})
	if checksum != 17747 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_split_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_sponsor()
	})
	if checksum != 25655 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_sponsor: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_stake()
	})
	if checksum != 41361 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_stake: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_transfer_objects()
	})
	if checksum != 16313 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_transfer_objects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_unstake()
	})
	if checksum != 30530 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_unstake: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_upgrade()
	})
	if checksum != 14493 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_upgrade: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_with_client()
	})
	if checksum != 26579 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_with_client: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_as_v1()
	})
	if checksum != 48710 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactioneffects_as_v1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_digest()
	})
	if checksum != 46963 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactioneffects_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_is_v1()
	})
	if checksum != 39808 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactioneffects_is_v1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionevents_digest()
	})
	if checksum != 55750 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionevents_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionevents_events()
	})
	if checksum != 36651 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionevents_events: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionv1_digest()
	})
	if checksum != 52708 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionv1_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionv1_expiration()
	})
	if checksum != 9317 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionv1_expiration: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionv1_gas_payment()
	})
	if checksum != 61676 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionv1_gas_payment: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionv1_kind()
	})
	if checksum != 56302 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionv1_kind: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionv1_sender()
	})
	if checksum != 8513 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionv1_sender: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest()
	})
	if checksum != 51695 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest_hex()
	})
	if checksum != 21009 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transactionv1_to_base64()
	})
	if checksum != 54846 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transactionv1_to_base64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transferobjects_address()
	})
	if checksum != 37833 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transferobjects_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_transferobjects_objects()
	})
	if checksum != 24154 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_transferobjects_objects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag()
	})
	if checksum != 1715 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag_opt()
	})
	if checksum != 15734 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag()
	})
	if checksum != 20180 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag_opt()
	})
	if checksum != 55130 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_address()
	})
	if checksum != 38219 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_bool()
	})
	if checksum != 30264 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_bool: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_signer()
	})
	if checksum != 57678 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_signer: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_struct()
	})
	if checksum != 39029 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_struct: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u128()
	})
	if checksum != 65460 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_u128: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u16()
	})
	if checksum != 34540 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_u16: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u256()
	})
	if checksum != 65130 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_u256: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u32()
	})
	if checksum != 40795 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_u32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u64()
	})
	if checksum != 28705 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_u64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u8()
	})
	if checksum != 18761 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_u8: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_typetag_is_vector()
	})
	if checksum != 49992 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_typetag_is_vector: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_upgrade_dependencies()
	})
	if checksum != 7113 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_upgrade_dependencies: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_upgrade_modules()
	})
	if checksum != 62138 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_upgrade_modules: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_upgrade_package()
	})
	if checksum != 35757 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_upgrade_package: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_upgrade_ticket()
	})
	if checksum != 11416 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_upgrade_ticket: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_upgradepolicy_as_u8()
	})
	if checksum != 10203 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_upgradepolicy_as_u8: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig()
	})
	if checksum != 36332 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig_opt()
	})
	if checksum != 21895 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey()
	})
	if checksum != 17710 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey_opt()
	})
	if checksum != 53755 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple()
	})
	if checksum != 57455 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple_opt()
	})
	if checksum != 47248 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin()
	})
	if checksum != 53484 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin_opt()
	})
	if checksum != 43934 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin_opt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_multisig()
	})
	if checksum != 61839 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_is_multisig: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_passkey()
	})
	if checksum != 35671 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_is_passkey: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_simple()
	})
	if checksum != 58211 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_is_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_zklogin()
	})
	if checksum != 38693 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_is_zklogin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_scheme()
	})
	if checksum != 25381 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_scheme: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_to_base64()
	})
	if checksum != 33757 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_to_base64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignature_to_bytes()
	})
	if checksum != 58893 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignature_to_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_verify()
	})
	if checksum != 47797 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_with_zklogin_verifier()
	})
	if checksum != 44658 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_with_zklogin_verifier: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_zklogin_verifier()
	})
	if checksum != 9821 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_zklogin_verifier: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_bitmap_bytes()
	})
	if checksum != 59039 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_bitmap_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_epoch()
	})
	if checksum != 54283 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_signature()
	})
	if checksum != 39125 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_signature: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_add_signature()
	})
	if checksum != 13923 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_add_signature: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_committee()
	})
	if checksum != 36159 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_committee: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_finish()
	})
	if checksum != 7324 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_finish: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_committee()
	})
	if checksum != 5093 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_committee: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify()
	})
	if checksum != 29238 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_aggregated()
	})
	if checksum != 46271 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_aggregated: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_checkpoint_summary()
	})
	if checksum != 36331 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_checkpoint_summary: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_duration()
	})
	if checksum != 59803 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_duration: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_validator()
	})
	if checksum != 10003 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_validator: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_epoch()
	})
	if checksum != 15301 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorsignature_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_public_key()
	})
	if checksum != 16384 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorsignature_public_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_signature()
	})
	if checksum != 58273 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_validatorsignature_signature: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_versionassignment_object_id()
	})
	if checksum != 50440 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_versionassignment_object_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_versionassignment_version()
	})
	if checksum != 51219 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_versionassignment_version: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_inputs()
	})
	if checksum != 1512 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_inputs: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_max_epoch()
	})
	if checksum != 9769 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_max_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_signature()
	})
	if checksum != 18838 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_signature: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_address_seed()
	})
	if checksum != 4892 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zklogininputs_address_seed: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_header_base64()
	})
	if checksum != 32056 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zklogininputs_header_base64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss()
	})
	if checksum != 1099 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss_base64_details()
	})
	if checksum != 20914 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss_base64_details: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_jwk_id()
	})
	if checksum != 37580 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zklogininputs_jwk_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_proof_points()
	})
	if checksum != 28172 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zklogininputs_proof_points: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_public_identifier()
	})
	if checksum != 48158 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zklogininputs_public_identifier: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_a()
	})
	if checksum != 6891 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginproof_a: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_b()
	})
	if checksum != 36477 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginproof_b: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_c()
	})
	if checksum != 10897 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginproof_c: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_address_seed()
	})
	if checksum != 3936 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_address_seed: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address()
	})
	if checksum != 14353 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_padded()
	})
	if checksum != 45141 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_padded: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_unpadded()
	})
	if checksum != 51424 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_unpadded: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_iss()
	})
	if checksum != 58864 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_iss: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_jwks()
	})
	if checksum != 62366 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_jwks: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_verify()
	})
	if checksum != 29967 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_verify: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_with_jwks()
	})
	if checksum != 49665 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_with_jwks: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_address_framework()
	})
	if checksum != 52951 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_address_framework: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_address_from_bytes()
	})
	if checksum != 58901 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_address_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_address_from_hex()
	})
	if checksum != 63442 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_address_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_address_generate()
	})
	if checksum != 48865 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_address_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_address_std_lib()
	})
	if checksum != 35825 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_address_std_lib: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_address_system()
	})
	if checksum != 4297 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_address_system: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_address_zero()
	})
	if checksum != 46553 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_address_zero: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_gas()
	})
	if checksum != 14489 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_argument_new_gas: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_input()
	})
	if checksum != 33966 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_argument_new_input: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_nested_result()
	})
	if checksum != 57666 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_argument_new_nested_result: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_result()
	})
	if checksum != 44025 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_argument_new_result: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_generate()
	})
	if checksum != 14780 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_new()
	})
	if checksum != 52467 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_bytes()
	})
	if checksum != 6069 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_str()
	})
	if checksum != 26128 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_generate()
	})
	if checksum != 30791 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_bytes()
	})
	if checksum != 42745 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_str()
	})
	if checksum != 5412 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_generate()
	})
	if checksum != 58435 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bls12381verifyingkey_new()
	})
	if checksum != 22402 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bls12381verifyingkey_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_bytes()
	})
	if checksum != 3672 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str()
	})
	if checksum != 21214 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str_radix_10()
	})
	if checksum != 17556 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str_radix_10: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_cancelledtransaction_new()
	})
	if checksum != 59199 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_cancelledtransaction_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_changeepoch_new()
	})
	if checksum != 48694 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_changeepoch_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_changeepochv2_new()
	})
	if checksum != 52433 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_changeepochv2_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_changeepochv3_new()
	})
	if checksum != 2388 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_changeepochv3_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_checkpointcontents_new()
	})
	if checksum != 27130 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_checkpointcontents_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_checkpointsummary_new()
	})
	if checksum != 16062 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_checkpointsummary_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_checkpointtransactioninfo_new()
	})
	if checksum != 65327 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_checkpointtransactioninfo_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_circomg1_new()
	})
	if checksum != 39786 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_circomg1_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_circomg2_new()
	})
	if checksum != 50489 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_circomg2_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_coin_try_from_object()
	})
	if checksum != 35349 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_coin_try_from_object: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_command_new_make_move_vector()
	})
	if checksum != 54610 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_command_new_make_move_vector: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_command_new_merge_coins()
	})
	if checksum != 1888 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_command_new_merge_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_command_new_move_call()
	})
	if checksum != 23161 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_command_new_move_call: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_command_new_publish()
	})
	if checksum != 7239 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_command_new_publish: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_command_new_split_coins()
	})
	if checksum != 59484 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_command_new_split_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_command_new_transfer_objects()
	})
	if checksum != 54265 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_command_new_transfer_objects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_command_new_upgrade()
	})
	if checksum != 48835 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_command_new_upgrade: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_consensuscommitprologuev1_new()
	})
	if checksum != 50376 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_consensuscommitprologuev1_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_consensusdeterminedversionassignments_new_cancelled_transactions()
	})
	if checksum != 929 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_consensusdeterminedversionassignments_new_cancelled_transactions: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_digest_from_base58()
	})
	if checksum != 41234 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_digest_from_base58: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_digest_from_bytes()
	})
	if checksum != 65530 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_digest_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_digest_generate()
	})
	if checksum != 8094 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_digest_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_bech32()
	})
	if checksum != 16842 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_bech32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_der()
	})
	if checksum != 42838 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic()
	})
	if checksum != 55789 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic_with_path()
	})
	if checksum != 15255 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic_with_path: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_pem()
	})
	if checksum != 53776 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_generate()
	})
	if checksum != 53932 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_new()
	})
	if checksum != 12862 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_bytes()
	})
	if checksum != 60403 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_str()
	})
	if checksum != 38751 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_generate()
	})
	if checksum != 46412 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_bytes()
	})
	if checksum != 61841 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_str()
	})
	if checksum != 39607 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_generate()
	})
	if checksum != 41607 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_der()
	})
	if checksum != 1677 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_pem()
	})
	if checksum != 37214 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_new()
	})
	if checksum != 23280 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_create()
	})
	if checksum != 42248 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_create: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_expire()
	})
	if checksum != 58811 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_expire: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch()
	})
	if checksum != 56235 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v2()
	})
	if checksum != 13653 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v2: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v3()
	})
	if checksum != 21107 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v3: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservation_new()
	})
	if checksum != 22119 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservation_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_make_move_vec()
	})
	if checksum != 1498 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_make_move_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_merge_coins()
	})
	if checksum != 40848 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_merge_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_move_entry_point()
	})
	if checksum != 6711 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_move_entry_point: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_publish()
	})
	if checksum != 6398 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_publish: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_split_coins()
	})
	if checksum != 28564 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_split_coins: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_transfer_objects()
	})
	if checksum != 29560 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_transfer_objects: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_upgrade()
	})
	if checksum != 26115 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_upgrade: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservations_new_v1()
	})
	if checksum != 19098 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservations_new_v1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new()
	})
	if checksum != 4619 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_devnet()
	})
	if checksum != 41429 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_devnet: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_localnet()
	})
	if checksum != 53173 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_localnet: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_testnet()
	})
	if checksum != 11124 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_testnet: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_genesisobject_new()
	})
	if checksum != 35390 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_genesisobject_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_genesistransaction_new()
	})
	if checksum != 47990 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_genesistransaction_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new()
	})
	if checksum != 32097 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_devnet()
	})
	if checksum != 6494 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_devnet: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_localnet()
	})
	if checksum != 2330 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_localnet: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_mainnet()
	})
	if checksum != 3613 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_mainnet: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_testnet()
	})
	if checksum != 48529 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_testnet: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_identifier_new()
	})
	if checksum != 9398 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_identifier_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_input_new_immutable_or_owned()
	})
	if checksum != 33908 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_input_new_immutable_or_owned: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_input_new_pure()
	})
	if checksum != 53404 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_input_new_pure: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_input_new_receiving()
	})
	if checksum != 28060 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_input_new_receiving: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_input_new_shared()
	})
	if checksum != 61970 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_input_new_shared: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_makemovevector_new()
	})
	if checksum != 20934 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_makemovevector_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_mergecoins_new()
	})
	if checksum != 1506 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_mergecoins_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address()
	})
	if checksum != 46522 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_from_hex()
	})
	if checksum != 44452 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec()
	})
	if checksum != 6097 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec_from_hex()
	})
	if checksum != 4963 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool()
	})
	if checksum != 52909 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool_vec()
	})
	if checksum != 25067 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest()
	})
	if checksum != 60114 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_from_base58()
	})
	if checksum != 42108 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_from_base58: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec()
	})
	if checksum != 42012 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec_from_base58()
	})
	if checksum != 36057 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec_from_base58: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_option()
	})
	if checksum != 48206 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_option: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_string()
	})
	if checksum != 18343 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_string: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_string_vec()
	})
	if checksum != 22295 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_string_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128()
	})
	if checksum != 8902 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128_vec()
	})
	if checksum != 64018 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16()
	})
	if checksum != 62318 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16_vec()
	})
	if checksum != 29254 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256()
	})
	if checksum != 32008 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256_vec()
	})
	if checksum != 50179 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32()
	})
	if checksum != 16255 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32_vec()
	})
	if checksum != 41122 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64()
	})
	if checksum != 7097 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64_vec()
	})
	if checksum != 17684 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8()
	})
	if checksum != 10135 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8_vec()
	})
	if checksum != 4587 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movecall_new()
	})
	if checksum != 30411 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movecall_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movepackage_new()
	})
	if checksum != 17506 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movepackage_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_base64()
	})
	if checksum != 61420 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_base64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_json()
	})
	if checksum != 13174 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_json: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_new()
	})
	if checksum != 65225 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregatedsignature_new()
	})
	if checksum != 3396 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregatedsignature_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_message()
	})
	if checksum != 41388 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_message: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_transaction()
	})
	if checksum != 27644 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_transaction: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_multisigcommittee_new()
	})
	if checksum != 40069 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_multisigcommittee_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_multisigmember_new()
	})
	if checksum != 63622 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_multisigmember_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_multisigverifier_new()
	})
	if checksum != 53197 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_multisigverifier_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_name_from_str()
	})
	if checksum != 30248 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_name_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_nameregistration_new()
	})
	if checksum != 19327 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_nameregistration_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_object_new()
	})
	if checksum != 41346 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_object_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_package()
	})
	if checksum != 5274 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_package: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_struct()
	})
	if checksum != 1861 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_struct: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objectid_clock()
	})
	if checksum != 14732 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objectid_clock: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objectid_derive_id()
	})
	if checksum != 16970 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objectid_derive_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_bytes()
	})
	if checksum != 41789 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_hex()
	})
	if checksum != 30954 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objectid_system()
	})
	if checksum != 9600 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objectid_system: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objectid_zero()
	})
	if checksum != 40526 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objectid_zero: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_package()
	})
	if checksum != 63533 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_package: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_struct()
	})
	if checksum != 65488 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_struct: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_address()
	})
	if checksum != 6008 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_owner_new_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_immutable()
	})
	if checksum != 51786 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_owner_new_immutable: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_object()
	})
	if checksum != 381 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_owner_new_object: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_shared()
	})
	if checksum != 36753 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_owner_new_shared: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address()
	})
	if checksum != 14619 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_from_hex()
	})
	if checksum != 40759 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec()
	})
	if checksum != 326 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec_from_hex()
	})
	if checksum != 60030 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool()
	})
	if checksum != 51030 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool_vec()
	})
	if checksum != 65126 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest()
	})
	if checksum != 54344 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_from_base58()
	})
	if checksum != 5017 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_from_base58: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec()
	})
	if checksum != 19113 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec_from_base58()
	})
	if checksum != 59134 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec_from_base58: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_gas()
	})
	if checksum != 10767 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_gas: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_move_arg()
	})
	if checksum != 26972 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_move_arg: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id()
	})
	if checksum != 41681 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id_from_hex()
	})
	if checksum != 47640 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_ref()
	})
	if checksum != 24215 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_ref: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_option()
	})
	if checksum != 37559 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_option: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving()
	})
	if checksum != 50553 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving_from_hex()
	})
	if checksum != 48453 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_res()
	})
	if checksum != 47661 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_res: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared()
	})
	if checksum != 59619 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_from_hex()
	})
	if checksum != 60985 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut()
	})
	if checksum != 43242 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut_from_hex()
	})
	if checksum != 52415 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut_from_hex: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_string()
	})
	if checksum != 60971 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_string: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128()
	})
	if checksum != 47870 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128_vec()
	})
	if checksum != 37355 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16()
	})
	if checksum != 58656 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16_vec()
	})
	if checksum != 10787 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256()
	})
	if checksum != 19985 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256_vec()
	})
	if checksum != 57693 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32()
	})
	if checksum != 13754 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32_vec()
	})
	if checksum != 50917 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64()
	})
	if checksum != 6870 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64_vec()
	})
	if checksum != 27400 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8()
	})
	if checksum != 22414 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8_vec()
	})
	if checksum != 51245 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8_vec: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_passkeypublickey_new()
	})
	if checksum != 30856 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_passkeypublickey_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_passkeyverifier_new()
	})
	if checksum != 23457 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_passkeyverifier_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_personalmessage_new()
	})
	if checksum != 3617 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_personalmessage_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_programmabletransaction_new()
	})
	if checksum != 38638 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_programmabletransaction_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_publish_new()
	})
	if checksum != 4785 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_publish_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_bech32()
	})
	if checksum != 34529 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_bech32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_der()
	})
	if checksum != 45448 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic()
	})
	if checksum != 33082 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic_with_path()
	})
	if checksum != 7431 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic_with_path: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_pem()
	})
	if checksum != 20937 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_generate()
	})
	if checksum != 49496 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_new()
	})
	if checksum != 35513 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_bytes()
	})
	if checksum != 20339 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_str()
	})
	if checksum != 24158 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_generate()
	})
	if checksum != 36411 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_bytes()
	})
	if checksum != 36237 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_str()
	})
	if checksum != 16397 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_generate()
	})
	if checksum != 63087 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifier_new()
	})
	if checksum != 59813 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifier_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_der()
	})
	if checksum != 40127 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_pem()
	})
	if checksum != 40573 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_new()
	})
	if checksum != 16080 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_bech32()
	})
	if checksum != 7016 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_bech32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_der()
	})
	if checksum != 63595 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic()
	})
	if checksum != 57849 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic_with_path()
	})
	if checksum != 7709 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic_with_path: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_pem()
	})
	if checksum != 28166 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_generate()
	})
	if checksum != 47736 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_new()
	})
	if checksum != 32825 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_bytes()
	})
	if checksum != 60002 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_str()
	})
	if checksum != 27991 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_generate()
	})
	if checksum != 49992 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_bytes()
	})
	if checksum != 8469 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_str()
	})
	if checksum != 15312 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_str: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_generate()
	})
	if checksum != 40260 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_generate: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifier_new()
	})
	if checksum != 59881 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifier_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_der()
	})
	if checksum != 6292 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_pem()
	})
	if checksum != 20421 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_new()
	})
	if checksum != 57317 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bech32()
	})
	if checksum != 51811 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bech32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bytes()
	})
	if checksum != 9299 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_der()
	})
	if checksum != 24923 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_ed25519()
	})
	if checksum != 22142 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_ed25519: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_pem()
	})
	if checksum != 2041 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256k1()
	})
	if checksum != 46546 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256k1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256r1()
	})
	if checksum != 13117 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256r1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_ed25519()
	})
	if checksum != 65185 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_ed25519: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256k1()
	})
	if checksum != 56524 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256k1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256r1()
	})
	if checksum != 19953 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256r1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifier_new()
	})
	if checksum != 34783 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simpleverifier_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_der()
	})
	if checksum != 21482 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_der: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_pem()
	})
	if checksum != 11192 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_pem: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_splitcoins_new()
	})
	if checksum != 50321 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_splitcoins_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new()
	})
	if checksum != 61625 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_ascii_string()
	})
	if checksum != 60972 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_ascii_string: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_balance()
	})
	if checksum != 10874 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_balance: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_clock()
	})
	if checksum != 18419 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_clock: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin()
	})
	if checksum != 38232 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_manager()
	})
	if checksum != 16973 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_manager: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_metadata()
	})
	if checksum != 56669 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_metadata: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config()
	})
	if checksum != 33902 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config_setting()
	})
	if checksum != 18224 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config_setting: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_address_key()
	})
	if checksum != 6409 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_address_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_config_key()
	})
	if checksum != 3059 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_config_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_global_pause_key()
	})
	if checksum != 36813 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_global_pause_key: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_display_created()
	})
	if checksum != 24465 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_display_created: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_dynamic_object_field_wrapper()
	})
	if checksum != 48905 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_dynamic_object_field_wrapper: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_field()
	})
	if checksum != 4196 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_field: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_gas_coin()
	})
	if checksum != 5754 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_gas_coin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_id()
	})
	if checksum != 62017 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_id: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_coin_type()
	})
	if checksum != 44499 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_coin_type: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_admin_cap()
	})
	if checksum != 5595 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_admin_cap: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_state()
	})
	if checksum != 29781 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_state: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_treasury_cap()
	})
	if checksum != 59282 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_treasury_cap: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_name()
	})
	if checksum != 26361 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_name: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_staked_iota()
	})
	if checksum != 60970 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_staked_iota: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_string()
	})
	if checksum != 47333 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_string: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_system_epoch_info_event()
	})
	if checksum != 36154 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_system_epoch_info_event: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_time_lock()
	})
	if checksum != 38402 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_time_lock: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_timelocked_staked_iota()
	})
	if checksum != 46742 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_timelocked_staked_iota: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_transfer_receiving()
	})
	if checksum != 40850 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_transfer_receiving: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_treasury_cap()
	})
	if checksum != 2523 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_treasury_cap: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_uid()
	})
	if checksum != 54533 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_uid: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_cap()
	})
	if checksum != 6365 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_cap: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_receipt()
	})
	if checksum != 44298 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_receipt: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_ticket()
	})
	if checksum != 43936 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_ticket: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_version_updated()
	})
	if checksum != 40840 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_version_updated: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_systempackage_new()
	})
	if checksum != 25070 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_systempackage_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transaction_from_base64()
	})
	if checksum != 30255 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transaction_from_base64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transaction_new_v1()
	})
	if checksum != 58632 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transaction_new_v1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionbuilder_new()
	})
	if checksum != 35216 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionbuilder_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactioneffects_new_v1()
	})
	if checksum != 63561 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactioneffects_new_v1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionevents_new()
	})
	if checksum != 1310 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionevents_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_authenticator_state_update_v1()
	})
	if checksum != 29264 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_authenticator_state_update_v1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_consensus_commit_prologue_v1()
	})
	if checksum != 27756 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_consensus_commit_prologue_v1: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_end_of_epoch()
	})
	if checksum != 44556 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_end_of_epoch: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_genesis()
	})
	if checksum != 45541 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_genesis: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_programmable_transaction()
	})
	if checksum != 9153 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_programmable_transaction: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_randomness_state_update()
	})
	if checksum != 37051 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_randomness_state_update: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_from_base64()
	})
	if checksum != 19681 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_from_base64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_new()
	})
	if checksum != 17484 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_transferobjects_new()
	})
	if checksum != 22470 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_transferobjects_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_address()
	})
	if checksum != 65087 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_address: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_bool()
	})
	if checksum != 404 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_bool: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_signer()
	})
	if checksum != 49791 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_signer: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_struct()
	})
	if checksum != 40686 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_struct: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u128()
	})
	if checksum != 24239 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u128: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u16()
	})
	if checksum != 14922 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u16: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u256()
	})
	if checksum != 41658 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u256: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u32()
	})
	if checksum != 59185 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u32: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u64()
	})
	if checksum != 29045 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u8()
	})
	if checksum != 55184 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u8: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_vector()
	})
	if checksum != 2453 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_vector: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_upgrade_new()
	})
	if checksum != 61663 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_upgrade_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_additive()
	})
	if checksum != 63459 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_additive: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_compatible()
	})
	if checksum != 63292 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_compatible: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_dep_only()
	})
	if checksum != 44371 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_dep_only: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_base64()
	})
	if checksum != 8029 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_base64: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_bytes()
	})
	if checksum != 37499 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_bytes: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_multisig()
	})
	if checksum != 39922 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_multisig: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_passkey()
	})
	if checksum != 25378 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_passkey: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_simple()
	})
	if checksum != 31310 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_simple: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_zklogin()
	})
	if checksum != 43856 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_zklogin: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_usersignatureverifier_new()
	})
	if checksum != 32322 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_usersignatureverifier_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_validatoraggregatedsignature_new()
	})
	if checksum != 15846 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_validatoraggregatedsignature_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureaggregator_new_checkpoint_summary()
	})
	if checksum != 25823 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureaggregator_new_checkpoint_summary: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureverifier_new()
	})
	if checksum != 17424 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureverifier_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_validatorexecutiontimeobservation_new()
	})
	if checksum != 47546 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_validatorexecutiontimeobservation_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_validatorsignature_new()
	})
	if checksum != 2599 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_validatorsignature_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_versionassignment_new()
	})
	if checksum != 14186 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_versionassignment_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_zkloginauthenticator_new()
	})
	if checksum != 32812 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_zkloginauthenticator_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_zklogininputs_new()
	})
	if checksum != 48962 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_zklogininputs_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_zkloginproof_new()
	})
	if checksum != 19950 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_zkloginproof_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_zkloginpublicidentifier_new()
	})
	if checksum != 53294 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_zkloginpublicidentifier_new: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_dev()
	})
	if checksum != 44446 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_dev: UniFFI API checksum mismatch")
	}
	}
	{
	checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_mainnet()
	})
	if checksum != 12123 {
		// If this happens try cleaning and rebuilding your project
		panic("iota_sdk_ffi: uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_mainnet: UniFFI API checksum mismatch")
	}
	}
}



type FfiConverterUint8 struct{}

var FfiConverterUint8INSTANCE = FfiConverterUint8{}

func (FfiConverterUint8) Lower(value uint8) C.uint8_t {
	return C.uint8_t(value)
}

func (FfiConverterUint8) Write(writer io.Writer, value uint8) {
	writeUint8(writer, value)
}

func (FfiConverterUint8) Lift(value C.uint8_t) uint8 {
	return uint8(value)
}

func (FfiConverterUint8) Read(reader io.Reader) uint8 {
	return readUint8(reader)
}

type FfiDestroyerUint8 struct {}

func (FfiDestroyerUint8) Destroy(_ uint8) {}

type FfiConverterInt8 struct{}

var FfiConverterInt8INSTANCE = FfiConverterInt8{}

func (FfiConverterInt8) Lower(value int8) C.int8_t {
	return C.int8_t(value)
}

func (FfiConverterInt8) Write(writer io.Writer, value int8) {
	writeInt8(writer, value)
}

func (FfiConverterInt8) Lift(value C.int8_t) int8 {
	return int8(value)
}

func (FfiConverterInt8) Read(reader io.Reader) int8 {
	return readInt8(reader)
}

type FfiDestroyerInt8 struct {}

func (FfiDestroyerInt8) Destroy(_ int8) {}

type FfiConverterUint16 struct{}

var FfiConverterUint16INSTANCE = FfiConverterUint16{}

func (FfiConverterUint16) Lower(value uint16) C.uint16_t {
	return C.uint16_t(value)
}

func (FfiConverterUint16) Write(writer io.Writer, value uint16) {
	writeUint16(writer, value)
}

func (FfiConverterUint16) Lift(value C.uint16_t) uint16 {
	return uint16(value)
}

func (FfiConverterUint16) Read(reader io.Reader) uint16 {
	return readUint16(reader)
}

type FfiDestroyerUint16 struct {}

func (FfiDestroyerUint16) Destroy(_ uint16) {}

type FfiConverterInt16 struct{}

var FfiConverterInt16INSTANCE = FfiConverterInt16{}

func (FfiConverterInt16) Lower(value int16) C.int16_t {
	return C.int16_t(value)
}

func (FfiConverterInt16) Write(writer io.Writer, value int16) {
	writeInt16(writer, value)
}

func (FfiConverterInt16) Lift(value C.int16_t) int16 {
	return int16(value)
}

func (FfiConverterInt16) Read(reader io.Reader) int16 {
	return readInt16(reader)
}

type FfiDestroyerInt16 struct {}

func (FfiDestroyerInt16) Destroy(_ int16) {}

type FfiConverterUint32 struct{}

var FfiConverterUint32INSTANCE = FfiConverterUint32{}

func (FfiConverterUint32) Lower(value uint32) C.uint32_t {
	return C.uint32_t(value)
}

func (FfiConverterUint32) Write(writer io.Writer, value uint32) {
	writeUint32(writer, value)
}

func (FfiConverterUint32) Lift(value C.uint32_t) uint32 {
	return uint32(value)
}

func (FfiConverterUint32) Read(reader io.Reader) uint32 {
	return readUint32(reader)
}

type FfiDestroyerUint32 struct {}

func (FfiDestroyerUint32) Destroy(_ uint32) {}

type FfiConverterInt32 struct{}

var FfiConverterInt32INSTANCE = FfiConverterInt32{}

func (FfiConverterInt32) Lower(value int32) C.int32_t {
	return C.int32_t(value)
}

func (FfiConverterInt32) Write(writer io.Writer, value int32) {
	writeInt32(writer, value)
}

func (FfiConverterInt32) Lift(value C.int32_t) int32 {
	return int32(value)
}

func (FfiConverterInt32) Read(reader io.Reader) int32 {
	return readInt32(reader)
}

type FfiDestroyerInt32 struct {}

func (FfiDestroyerInt32) Destroy(_ int32) {}

type FfiConverterUint64 struct{}

var FfiConverterUint64INSTANCE = FfiConverterUint64{}

func (FfiConverterUint64) Lower(value uint64) C.uint64_t {
	return C.uint64_t(value)
}

func (FfiConverterUint64) Write(writer io.Writer, value uint64) {
	writeUint64(writer, value)
}

func (FfiConverterUint64) Lift(value C.uint64_t) uint64 {
	return uint64(value)
}

func (FfiConverterUint64) Read(reader io.Reader) uint64 {
	return readUint64(reader)
}

type FfiDestroyerUint64 struct {}

func (FfiDestroyerUint64) Destroy(_ uint64) {}

type FfiConverterInt64 struct{}

var FfiConverterInt64INSTANCE = FfiConverterInt64{}

func (FfiConverterInt64) Lower(value int64) C.int64_t {
	return C.int64_t(value)
}

func (FfiConverterInt64) Write(writer io.Writer, value int64) {
	writeInt64(writer, value)
}

func (FfiConverterInt64) Lift(value C.int64_t) int64 {
	return int64(value)
}

func (FfiConverterInt64) Read(reader io.Reader) int64 {
	return readInt64(reader)
}

type FfiDestroyerInt64 struct {}

func (FfiDestroyerInt64) Destroy(_ int64) {}

type FfiConverterBool struct{}

var FfiConverterBoolINSTANCE = FfiConverterBool{}

func (FfiConverterBool) Lower(value bool) C.int8_t {
	if value {
		return C.int8_t(1)
	}
	return C.int8_t(0)
}

func (FfiConverterBool) Write(writer io.Writer, value bool) {
	if value {
		writeInt8(writer, 1)
	} else {
		writeInt8(writer, 0)
	}
}

func (FfiConverterBool) Lift(value C.int8_t) bool {
	return value != 0
}

func (FfiConverterBool) Read(reader io.Reader) bool {
	return readInt8(reader) != 0
}

type FfiDestroyerBool struct {}

func (FfiDestroyerBool) Destroy(_ bool) {}

type FfiConverterString struct{}

var FfiConverterStringINSTANCE = FfiConverterString{}

func (FfiConverterString) Lift(rb RustBufferI) string {
	defer rb.Free()
	reader := rb.AsReader()
	b, err := io.ReadAll(reader)
	if err != nil {
		panic(fmt.Errorf("reading reader: %w", err))
	}
	return string(b)
}

func (FfiConverterString) Read(reader io.Reader) string {
	length := readInt32(reader)
	buffer := make([]byte, length)
	read_length, err := reader.Read(buffer)
	if err != nil && err != io.EOF {
		panic(err)
	}
	if read_length != int(length) {
		panic(fmt.Errorf("bad read length when reading string, expected %d, read %d", length, read_length))
	}
	return string(buffer)
}

func (FfiConverterString) Lower(value string) C.RustBuffer {
	return stringToRustBuffer(value)
}

func (FfiConverterString) Write(writer io.Writer, value string) {
	if len(value) > math.MaxInt32 {
		panic("String is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	write_length, err := io.WriteString(writer, value)
	if err != nil {
		panic(err)
	}
	if write_length != len(value) {
		panic(fmt.Errorf("bad write length when writing string, expected %d, written %d", len(value), write_length))
	}
}

type FfiDestroyerString struct {}

func (FfiDestroyerString) Destroy(_ string) {}

type FfiConverterBytes struct{}

var FfiConverterBytesINSTANCE = FfiConverterBytes{}

func (c FfiConverterBytes) Lower(value []byte) C.RustBuffer {
	return LowerIntoRustBuffer[[]byte](c, value)
}

func (c FfiConverterBytes) Write(writer io.Writer, value []byte) {
	if len(value) > math.MaxInt32 {
		panic("[]byte is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	write_length, err := writer.Write(value)
	if err != nil {
		panic(err)
	}
	if write_length != len(value) {
		panic(fmt.Errorf("bad write length when writing []byte, expected %d, written %d", len(value), write_length))
	}
}

func (c FfiConverterBytes) Lift(rb RustBufferI) []byte {
	return LiftFromRustBuffer[[]byte](c, rb)
}

func (c FfiConverterBytes) Read(reader io.Reader) []byte {
	length := readInt32(reader)
	buffer := make([]byte, length)
	read_length, err := reader.Read(buffer)
	if err != nil && err != io.EOF {
		panic(err)
	}
	if read_length != int(length) {
		panic(fmt.Errorf("bad read length when reading []byte, expected %d, read %d", length, read_length))
	}
	return buffer
}

type FfiDestroyerBytes struct {}

func (FfiDestroyerBytes) Destroy(_ []byte) {}


// FfiConverterDuration converts between uniffi duration and Go duration.
type FfiConverterDuration struct{}

var FfiConverterDurationINSTANCE = FfiConverterDuration{}

func (c FfiConverterDuration) Lift(rb RustBufferI) time.Duration {
	return LiftFromRustBuffer[time.Duration](c, rb)
}

func (c FfiConverterDuration) Read(reader io.Reader) time.Duration {
	sec := readUint64(reader)
	nsec := readUint32(reader)
	return time.Duration(sec*1_000_000_000 + uint64(nsec))
}

func (c FfiConverterDuration) Lower(value time.Duration) C.RustBuffer {
	return LowerIntoRustBuffer[time.Duration](c, value)
}

func (c FfiConverterDuration) Write(writer io.Writer, value time.Duration) {
	if value.Nanoseconds() < 0 {
		// Rust does not support negative durations:
		// https://www.reddit.com/r/rust/comments/ljl55u/why_rusts_duration_not_supporting_negative_values/
		// This panic is very bad, because it depends on user input, and in Go user input related
		// error are supposed to be returned as errors, and not cause panics. However, with the
		// current architecture, its not possible to return an error from here, so panic is used as
		// the only other option to signal an error.
		panic("negative duration is not allowed")
	}

	writeUint64(writer, uint64(value) / 1_000_000_000)
	writeUint32(writer, uint32(uint64(value) % 1_000_000_000))
}

type FfiDestroyerDuration struct {}

func (FfiDestroyerDuration) Destroy(_ time.Duration) {}

// Below is an implementation of synchronization requirements outlined in the link.
// https://github.com/mozilla/uniffi-rs/blob/0dc031132d9493ca812c3af6e7dd60ad2ea95bf0/uniffi_bindgen/src/bindings/kotlin/templates/ObjectRuntime.kt#L31

type FfiObject struct {
	pointer unsafe.Pointer
	callCounter atomic.Int64
	cloneFunction func(unsafe.Pointer, *C.RustCallStatus) unsafe.Pointer
	freeFunction func(unsafe.Pointer, *C.RustCallStatus)
	destroyed atomic.Bool
}

func newFfiObject(
	pointer unsafe.Pointer,
	cloneFunction func(unsafe.Pointer, *C.RustCallStatus) unsafe.Pointer,
	freeFunction func(unsafe.Pointer, *C.RustCallStatus),
) FfiObject {
	return FfiObject {
		pointer: pointer,
		cloneFunction: cloneFunction,
		freeFunction: freeFunction,
	}
}

func (ffiObject *FfiObject)incrementPointer(debugName string) unsafe.Pointer {
	for {
		counter := ffiObject.callCounter.Load()
		if counter <= -1 {
			panic(fmt.Errorf("%v object has already been destroyed", debugName))
		}
		if counter == math.MaxInt64 {
			panic(fmt.Errorf("%v object call counter would overflow", debugName))
		}
		if ffiObject.callCounter.CompareAndSwap(counter, counter + 1) {
			break
		}
	}

	return rustCall(func(status *C.RustCallStatus) unsafe.Pointer {
		return ffiObject.cloneFunction(ffiObject.pointer, status)
	})
}

func (ffiObject *FfiObject)decrementPointer() {
	if ffiObject.callCounter.Add(-1) == -1 {
		ffiObject.freeRustArcPtr()
	}
}

func (ffiObject *FfiObject)destroy() {
	if ffiObject.destroyed.CompareAndSwap(false, true) {
		if ffiObject.callCounter.Add(-1) == -1 {
			ffiObject.freeRustArcPtr()
		}
	}
}

func (ffiObject *FfiObject)freeRustArcPtr() {
	rustCall(func(status *C.RustCallStatus) int32 {
		ffiObject.freeFunction(ffiObject.pointer, status)
		return 0
	})
}
// Unique identifier for an Account on the IOTA blockchain.
//
// An `Address` is a 32-byte pseudonymous identifier used to uniquely identify
// an account and asset-ownership on the IOTA blockchain. Often, human-readable
// addresses are encoded in hexadecimal with a `0x` prefix. For example, this
// is a valid IOTA address:
// `0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331`.
//
// # Deriving an Address
//
// Addresses are cryptographically derived from a number of user account
// authenticators, the simplest of which is an
// `Ed25519PublicKey`.
//
// Deriving an address consists of the Blake2b256 hash of the sequence of bytes
// of its corresponding authenticator, prefixed with a domain-separator (except
// ed25519, for compatibility reasons). For each other authenticator, this
// domain-separator is the single byte-value of its
// `SignatureScheme` flag. E.g. `hash(signature schema flag || authenticator
// bytes)`.
//
// Each authenticator has a method for deriving its `Address` as well as
// documentation for the specifics of how the derivation is done. See
// `Ed25519PublicKey::derive_address` for an example.
//
// ## Relationship to ObjectIds
//
// `ObjectId`s and `Address`es share the same 32-byte addressable space but
// are derived leveraging different domain-separator values to ensure that,
// cryptographically, there won't be any overlap, e.g. there can't be a
// valid `Object` who's `ObjectId` is equal to that of the `Address` of a user
// account.
//
// # BCS
//
// An `Address`'s BCS serialized form is defined by the following:
//
// ```text
// address = 32OCTET
// ```
type AddressInterface interface {
	ToBytes() []byte
	ToHex() string
}
// Unique identifier for an Account on the IOTA blockchain.
//
// An `Address` is a 32-byte pseudonymous identifier used to uniquely identify
// an account and asset-ownership on the IOTA blockchain. Often, human-readable
// addresses are encoded in hexadecimal with a `0x` prefix. For example, this
// is a valid IOTA address:
// `0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331`.
//
// # Deriving an Address
//
// Addresses are cryptographically derived from a number of user account
// authenticators, the simplest of which is an
// `Ed25519PublicKey`.
//
// Deriving an address consists of the Blake2b256 hash of the sequence of bytes
// of its corresponding authenticator, prefixed with a domain-separator (except
// ed25519, for compatibility reasons). For each other authenticator, this
// domain-separator is the single byte-value of its
// `SignatureScheme` flag. E.g. `hash(signature schema flag || authenticator
// bytes)`.
//
// Each authenticator has a method for deriving its `Address` as well as
// documentation for the specifics of how the derivation is done. See
// `Ed25519PublicKey::derive_address` for an example.
//
// ## Relationship to ObjectIds
//
// `ObjectId`s and `Address`es share the same 32-byte addressable space but
// are derived leveraging different domain-separator values to ensure that,
// cryptographically, there won't be any overlap, e.g. there can't be a
// valid `Object` who's `ObjectId` is equal to that of the `Address` of a user
// account.
//
// # BCS
//
// An `Address`'s BCS serialized form is defined by the following:
//
// ```text
// address = 32OCTET
// ```
type Address struct {
	ffiObject FfiObject
}


func AddressFramework() *Address {
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_address_framework(_uniffiStatus)
	}))
}

func AddressFromBytes(bytes []byte) (*Address, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_address_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Address
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterAddressINSTANCE.Lift(_uniffiRV), nil
		}
}

func AddressFromHex(hex string) (*Address, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_address_from_hex(FfiConverterStringINSTANCE.Lower(hex),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Address
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterAddressINSTANCE.Lift(_uniffiRV), nil
		}
}

func AddressGenerate() *Address {
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_address_generate(_uniffiStatus)
	}))
}

func AddressStdLib() *Address {
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_address_std_lib(_uniffiStatus)
	}))
}

func AddressSystem() *Address {
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_address_system(_uniffiStatus)
	}))
}

func AddressZero() *Address {
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_address_zero(_uniffiStatus)
	}))
}



func (_self *Address) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Address")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_address_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Address) ToHex() string {
	_pointer := _self.ffiObject.incrementPointer("*Address")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_address_to_hex(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Address) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterAddress struct {}

var FfiConverterAddressINSTANCE = FfiConverterAddress{}


func (c FfiConverterAddress) Lift(pointer unsafe.Pointer) *Address {
	result := &Address {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_address(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_address(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Address).Destroy)
	return result
}

func (c FfiConverterAddress) Read(reader io.Reader) *Address {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterAddress) Lower(value *Address) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Address")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterAddress) Write(writer io.Writer, value *Address) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerAddress struct {}

func (_ FfiDestroyerAddress) Destroy(value *Address) {
		value.Destroy()
}



// An argument to a programmable transaction command
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// argument    =  argument-gas
// =/ argument-input
// =/ argument-result
// =/ argument-nested-result
//
// argument-gas            = %x00
// argument-input          = %x01 u16
// argument-result         = %x02 u16
// argument-nested-result  = %x03 u16 u16
// ```
type ArgumentInterface interface {
	// Get the nested result for this result at the given index. Returns None
	// if this is not a Result.
	GetNestedResult(ix uint16) **Argument
}
// An argument to a programmable transaction command
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// argument    =  argument-gas
// =/ argument-input
// =/ argument-result
// =/ argument-nested-result
//
// argument-gas            = %x00
// argument-input          = %x01 u16
// argument-result         = %x02 u16
// argument-nested-result  = %x03 u16 u16
// ```
type Argument struct {
	ffiObject FfiObject
}


// The gas coin. The gas coin can only be used by-ref, except for with
// `TransferObjects`, which can use it by-value.
func ArgumentNewGas() *Argument {
	return FfiConverterArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_argument_new_gas(_uniffiStatus)
	}))
}

// One of the input objects or primitive values (from
// `ProgrammableTransaction` inputs)
func ArgumentNewInput(input uint16) *Argument {
	return FfiConverterArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_argument_new_input(FfiConverterUint16INSTANCE.Lower(input),_uniffiStatus)
	}))
}

// Like a `Result` but it accesses a nested result. Currently, the only
// usage of this is to access a value from a Move call with multiple
// return values.
func ArgumentNewNestedResult(commandIndex uint16, subresultIndex uint16) *Argument {
	return FfiConverterArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_argument_new_nested_result(FfiConverterUint16INSTANCE.Lower(commandIndex), FfiConverterUint16INSTANCE.Lower(subresultIndex),_uniffiStatus)
	}))
}

// The result of another command (from `ProgrammableTransaction` commands)
func ArgumentNewResult(result uint16) *Argument {
	return FfiConverterArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_argument_new_result(FfiConverterUint16INSTANCE.Lower(result),_uniffiStatus)
	}))
}



// Get the nested result for this result at the given index. Returns None
// if this is not a Result.
func (_self *Argument) GetNestedResult(ix uint16) **Argument {
	_pointer := _self.ffiObject.incrementPointer("*Argument")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_argument_get_nested_result(
		_pointer,FfiConverterUint16INSTANCE.Lower(ix),_uniffiStatus),
	}
	}))
}
func (object *Argument) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterArgument struct {}

var FfiConverterArgumentINSTANCE = FfiConverterArgument{}


func (c FfiConverterArgument) Lift(pointer unsafe.Pointer) *Argument {
	result := &Argument {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_argument(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_argument(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Argument).Destroy)
	return result
}

func (c FfiConverterArgument) Read(reader io.Reader) *Argument {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterArgument) Lower(value *Argument) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Argument")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterArgument) Write(writer io.Writer, value *Argument) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerArgument struct {}

func (_ FfiDestroyerArgument) Destroy(value *Argument) {
		value.Destroy()
}



type Bls12381PrivateKeyInterface interface {
	PublicKey() *Bls12381PublicKey
	Scheme() SignatureScheme
	SignCheckpointSummary(summary *CheckpointSummary) *ValidatorSignature
	TrySign(message []byte) (*Bls12381Signature, error)
	VerifyingKey() *Bls12381VerifyingKey
}
type Bls12381PrivateKey struct {
	ffiObject FfiObject
}
func NewBls12381PrivateKey(bytes []byte) (*Bls12381PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bls12381privatekey_new(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bls12381PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBls12381PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}


func Bls12381PrivateKeyGenerate() *Bls12381PrivateKey {
	return FfiConverterBls12381PrivateKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bls12381privatekey_generate(_uniffiStatus)
	}))
}



func (_self *Bls12381PrivateKey) PublicKey() *Bls12381PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*Bls12381PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBls12381PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_public_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Bls12381PrivateKey) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*Bls12381PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Bls12381PrivateKey) SignCheckpointSummary(summary *CheckpointSummary) *ValidatorSignature {
	_pointer := _self.ffiObject.incrementPointer("*Bls12381PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterValidatorSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_sign_checkpoint_summary(
		_pointer,FfiConverterCheckpointSummaryINSTANCE.Lower(summary),_uniffiStatus)
	}))
}

func (_self *Bls12381PrivateKey) TrySign(message []byte) (*Bls12381Signature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Bls12381PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_try_sign(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bls12381Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBls12381SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Bls12381PrivateKey) VerifyingKey() *Bls12381VerifyingKey {
	_pointer := _self.ffiObject.incrementPointer("*Bls12381PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBls12381VerifyingKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_verifying_key(
		_pointer,_uniffiStatus)
	}))
}
func (object *Bls12381PrivateKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterBls12381PrivateKey struct {}

var FfiConverterBls12381PrivateKeyINSTANCE = FfiConverterBls12381PrivateKey{}


func (c FfiConverterBls12381PrivateKey) Lift(pointer unsafe.Pointer) *Bls12381PrivateKey {
	result := &Bls12381PrivateKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_bls12381privatekey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_bls12381privatekey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Bls12381PrivateKey).Destroy)
	return result
}

func (c FfiConverterBls12381PrivateKey) Read(reader io.Reader) *Bls12381PrivateKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterBls12381PrivateKey) Lower(value *Bls12381PrivateKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Bls12381PrivateKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterBls12381PrivateKey) Write(writer io.Writer, value *Bls12381PrivateKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerBls12381PrivateKey struct {}

func (_ FfiDestroyerBls12381PrivateKey) Destroy(value *Bls12381PrivateKey) {
		value.Destroy()
}



// A bls12381 min-sig public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// bls-public-key = %x60 96OCTECT
// ```
//
// Due to historical reasons, even though a min-sig `Bls12381PublicKey` has a
// fixed-length of 96, IOTA's binary representation of a min-sig
// `Bls12381PublicKey` is prefixed with its length meaning its serialized
// binary form (in bcs) is 97 bytes long vs a more compact 96 bytes.
type Bls12381PublicKeyInterface interface {
	ToBytes() []byte
}
// A bls12381 min-sig public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// bls-public-key = %x60 96OCTECT
// ```
//
// Due to historical reasons, even though a min-sig `Bls12381PublicKey` has a
// fixed-length of 96, IOTA's binary representation of a min-sig
// `Bls12381PublicKey` is prefixed with its length meaning its serialized
// binary form (in bcs) is 97 bytes long vs a more compact 96 bytes.
type Bls12381PublicKey struct {
	ffiObject FfiObject
}


func Bls12381PublicKeyFromBytes(bytes []byte) (*Bls12381PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bls12381PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBls12381PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Bls12381PublicKeyFromStr(s string) (*Bls12381PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bls12381PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBls12381PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Bls12381PublicKeyGenerate() *Bls12381PublicKey {
	return FfiConverterBls12381PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_generate(_uniffiStatus)
	}))
}



func (_self *Bls12381PublicKey) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Bls12381PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_bls12381publickey_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Bls12381PublicKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterBls12381PublicKey struct {}

var FfiConverterBls12381PublicKeyINSTANCE = FfiConverterBls12381PublicKey{}


func (c FfiConverterBls12381PublicKey) Lift(pointer unsafe.Pointer) *Bls12381PublicKey {
	result := &Bls12381PublicKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_bls12381publickey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_bls12381publickey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Bls12381PublicKey).Destroy)
	return result
}

func (c FfiConverterBls12381PublicKey) Read(reader io.Reader) *Bls12381PublicKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterBls12381PublicKey) Lower(value *Bls12381PublicKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Bls12381PublicKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterBls12381PublicKey) Write(writer io.Writer, value *Bls12381PublicKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerBls12381PublicKey struct {}

func (_ FfiDestroyerBls12381PublicKey) Destroy(value *Bls12381PublicKey) {
		value.Destroy()
}



// A bls12381 min-sig public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// bls-public-key = %x60 96OCTECT
// ```
//
// Due to historical reasons, even though a min-sig `Bls12381PublicKey` has a
// fixed-length of 96, IOTA's binary representation of a min-sig
// `Bls12381PublicKey` is prefixed with its length meaning its serialized
// binary form (in bcs) is 97 bytes long vs a more compact 96 bytes.
type Bls12381SignatureInterface interface {
	ToBytes() []byte
}
// A bls12381 min-sig public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// bls-public-key = %x60 96OCTECT
// ```
//
// Due to historical reasons, even though a min-sig `Bls12381PublicKey` has a
// fixed-length of 96, IOTA's binary representation of a min-sig
// `Bls12381PublicKey` is prefixed with its length meaning its serialized
// binary form (in bcs) is 97 bytes long vs a more compact 96 bytes.
type Bls12381Signature struct {
	ffiObject FfiObject
}


func Bls12381SignatureFromBytes(bytes []byte) (*Bls12381Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bls12381Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBls12381SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func Bls12381SignatureFromStr(s string) (*Bls12381Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bls12381Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBls12381SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func Bls12381SignatureGenerate() *Bls12381Signature {
	return FfiConverterBls12381SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_generate(_uniffiStatus)
	}))
}



func (_self *Bls12381Signature) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Bls12381Signature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_bls12381signature_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Bls12381Signature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterBls12381Signature struct {}

var FfiConverterBls12381SignatureINSTANCE = FfiConverterBls12381Signature{}


func (c FfiConverterBls12381Signature) Lift(pointer unsafe.Pointer) *Bls12381Signature {
	result := &Bls12381Signature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_bls12381signature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_bls12381signature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Bls12381Signature).Destroy)
	return result
}

func (c FfiConverterBls12381Signature) Read(reader io.Reader) *Bls12381Signature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterBls12381Signature) Lower(value *Bls12381Signature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Bls12381Signature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterBls12381Signature) Write(writer io.Writer, value *Bls12381Signature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerBls12381Signature struct {}

func (_ FfiDestroyerBls12381Signature) Destroy(value *Bls12381Signature) {
		value.Destroy()
}



type Bls12381VerifyingKeyInterface interface {
	PublicKey() *Bls12381PublicKey
	Verify(message []byte, signature *Bls12381Signature) error
}
type Bls12381VerifyingKey struct {
	ffiObject FfiObject
}
func NewBls12381VerifyingKey(publicKey *Bls12381PublicKey) (*Bls12381VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bls12381verifyingkey_new(FfiConverterBls12381PublicKeyINSTANCE.Lower(publicKey),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bls12381VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBls12381VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}




func (_self *Bls12381VerifyingKey) PublicKey() *Bls12381PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*Bls12381VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBls12381PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_bls12381verifyingkey_public_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Bls12381VerifyingKey) Verify(message []byte, signature *Bls12381Signature) error {
	_pointer := _self.ffiObject.incrementPointer("*Bls12381VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_bls12381verifyingkey_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterBls12381SignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *Bls12381VerifyingKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterBls12381VerifyingKey struct {}

var FfiConverterBls12381VerifyingKeyINSTANCE = FfiConverterBls12381VerifyingKey{}


func (c FfiConverterBls12381VerifyingKey) Lift(pointer unsafe.Pointer) *Bls12381VerifyingKey {
	result := &Bls12381VerifyingKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_bls12381verifyingkey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_bls12381verifyingkey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Bls12381VerifyingKey).Destroy)
	return result
}

func (c FfiConverterBls12381VerifyingKey) Read(reader io.Reader) *Bls12381VerifyingKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterBls12381VerifyingKey) Lower(value *Bls12381VerifyingKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Bls12381VerifyingKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterBls12381VerifyingKey) Write(writer io.Writer, value *Bls12381VerifyingKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerBls12381VerifyingKey struct {}

func (_ FfiDestroyerBls12381VerifyingKey) Destroy(value *Bls12381VerifyingKey) {
		value.Destroy()
}



// A point on the BN254 elliptic curve.
//
// This is a 32-byte, or 256-bit, value that is generally represented as
// radix10 when a human-readable display format is needed, and is represented
// as a 32-byte big-endian value while in memory.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// bn254-field-element = *DIGIT ; which is then interpreted as a radix10 encoded 32-byte value
// ```
type Bn254FieldElementInterface interface {
	Padded() []byte
	Unpadded() []byte
}
// A point on the BN254 elliptic curve.
//
// This is a 32-byte, or 256-bit, value that is generally represented as
// radix10 when a human-readable display format is needed, and is represented
// as a 32-byte big-endian value while in memory.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// bn254-field-element = *DIGIT ; which is then interpreted as a radix10 encoded 32-byte value
// ```
type Bn254FieldElement struct {
	ffiObject FfiObject
}


func Bn254FieldElementFromBytes(bytes []byte) (*Bn254FieldElement, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bn254FieldElement
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBn254FieldElementINSTANCE.Lift(_uniffiRV), nil
		}
}

func Bn254FieldElementFromStr(s string) (*Bn254FieldElement, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bn254FieldElement
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBn254FieldElementINSTANCE.Lift(_uniffiRV), nil
		}
}

func Bn254FieldElementFromStrRadix10(s string) (*Bn254FieldElement, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_str_radix_10(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bn254FieldElement
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBn254FieldElementINSTANCE.Lift(_uniffiRV), nil
		}
}



func (_self *Bn254FieldElement) Padded() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Bn254FieldElement")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_bn254fieldelement_padded(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Bn254FieldElement) Unpadded() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Bn254FieldElement")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_bn254fieldelement_unpadded(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Bn254FieldElement) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterBn254FieldElement struct {}

var FfiConverterBn254FieldElementINSTANCE = FfiConverterBn254FieldElement{}


func (c FfiConverterBn254FieldElement) Lift(pointer unsafe.Pointer) *Bn254FieldElement {
	result := &Bn254FieldElement {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_bn254fieldelement(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_bn254fieldelement(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Bn254FieldElement).Destroy)
	return result
}

func (c FfiConverterBn254FieldElement) Read(reader io.Reader) *Bn254FieldElement {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterBn254FieldElement) Lower(value *Bn254FieldElement) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Bn254FieldElement")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterBn254FieldElement) Write(writer io.Writer, value *Bn254FieldElement) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerBn254FieldElement struct {}

func (_ FfiDestroyerBn254FieldElement) Destroy(value *Bn254FieldElement) {
		value.Destroy()
}



// A transaction that was cancelled
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// cancelled-transaction = digest (vector version-assignment)
// ```
type CancelledTransactionInterface interface {
	Digest() *Digest
	VersionAssignments() []*VersionAssignment
}
// A transaction that was cancelled
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// cancelled-transaction = digest (vector version-assignment)
// ```
type CancelledTransaction struct {
	ffiObject FfiObject
}
func NewCancelledTransaction(digest *Digest, versionAssignments []*VersionAssignment) *CancelledTransaction {
	return FfiConverterCancelledTransactionINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_cancelledtransaction_new(FfiConverterDigestINSTANCE.Lower(digest), FfiConverterSequenceVersionAssignmentINSTANCE.Lower(versionAssignments),_uniffiStatus)
	}))
}




func (_self *CancelledTransaction) Digest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*CancelledTransaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_cancelledtransaction_digest(
		_pointer,_uniffiStatus)
	}))
}

func (_self *CancelledTransaction) VersionAssignments() []*VersionAssignment {
	_pointer := _self.ffiObject.incrementPointer("*CancelledTransaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceVersionAssignmentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_cancelledtransaction_version_assignments(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *CancelledTransaction) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterCancelledTransaction struct {}

var FfiConverterCancelledTransactionINSTANCE = FfiConverterCancelledTransaction{}


func (c FfiConverterCancelledTransaction) Lift(pointer unsafe.Pointer) *CancelledTransaction {
	result := &CancelledTransaction {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_cancelledtransaction(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_cancelledtransaction(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*CancelledTransaction).Destroy)
	return result
}

func (c FfiConverterCancelledTransaction) Read(reader io.Reader) *CancelledTransaction {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterCancelledTransaction) Lower(value *CancelledTransaction) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*CancelledTransaction")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterCancelledTransaction) Write(writer io.Writer, value *CancelledTransaction) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerCancelledTransaction struct {}

func (_ FfiDestroyerCancelledTransaction) Destroy(value *CancelledTransaction) {
		value.Destroy()
}



// System transaction used to change the epoch
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// change-epoch = u64  ; next epoch
// u64  ; protocol version
// u64  ; storage charge
// u64  ; computation charge
// u64  ; storage rebate
// u64  ; non-refundable storage fee
// u64  ; epoch start timestamp
// (vector system-package)
// ```
type ChangeEpochInterface interface {
	// The total amount of gas charged for computation during the epoch.
	ComputationCharge() uint64
	// The next (to become) epoch ID.
	Epoch() uint64
	// Unix timestamp when epoch started
	EpochStartTimestampMs() uint64
	// The non-refundable storage fee.
	NonRefundableStorageFee() uint64
	// The protocol version in effect in the new epoch.
	ProtocolVersion() uint64
	// The total amount of gas charged for storage during the epoch.
	StorageCharge() uint64
	// The amount of storage rebate refunded to the txn senders.
	StorageRebate() uint64
	// System packages (specifically framework and move stdlib) that are
	// written before the new epoch starts.
	SystemPackages() []*SystemPackage
}
// System transaction used to change the epoch
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// change-epoch = u64  ; next epoch
// u64  ; protocol version
// u64  ; storage charge
// u64  ; computation charge
// u64  ; storage rebate
// u64  ; non-refundable storage fee
// u64  ; epoch start timestamp
// (vector system-package)
// ```
type ChangeEpoch struct {
	ffiObject FfiObject
}
func NewChangeEpoch(epoch uint64, protocolVersion uint64, storageCharge uint64, computationCharge uint64, storageRebate uint64, nonRefundableStorageFee uint64, epochStartTimestampMs uint64, systemPackages []*SystemPackage) *ChangeEpoch {
	return FfiConverterChangeEpochINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_changeepoch_new(FfiConverterUint64INSTANCE.Lower(epoch), FfiConverterUint64INSTANCE.Lower(protocolVersion), FfiConverterUint64INSTANCE.Lower(storageCharge), FfiConverterUint64INSTANCE.Lower(computationCharge), FfiConverterUint64INSTANCE.Lower(storageRebate), FfiConverterUint64INSTANCE.Lower(nonRefundableStorageFee), FfiConverterUint64INSTANCE.Lower(epochStartTimestampMs), FfiConverterSequenceSystemPackageINSTANCE.Lower(systemPackages),_uniffiStatus)
	}))
}




// The total amount of gas charged for computation during the epoch.
func (_self *ChangeEpoch) ComputationCharge() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpoch")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepoch_computation_charge(
		_pointer,_uniffiStatus)
	}))
}

// The next (to become) epoch ID.
func (_self *ChangeEpoch) Epoch() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpoch")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepoch_epoch(
		_pointer,_uniffiStatus)
	}))
}

// Unix timestamp when epoch started
func (_self *ChangeEpoch) EpochStartTimestampMs() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpoch")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepoch_epoch_start_timestamp_ms(
		_pointer,_uniffiStatus)
	}))
}

// The non-refundable storage fee.
func (_self *ChangeEpoch) NonRefundableStorageFee() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpoch")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepoch_non_refundable_storage_fee(
		_pointer,_uniffiStatus)
	}))
}

// The protocol version in effect in the new epoch.
func (_self *ChangeEpoch) ProtocolVersion() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpoch")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepoch_protocol_version(
		_pointer,_uniffiStatus)
	}))
}

// The total amount of gas charged for storage during the epoch.
func (_self *ChangeEpoch) StorageCharge() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpoch")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepoch_storage_charge(
		_pointer,_uniffiStatus)
	}))
}

// The amount of storage rebate refunded to the txn senders.
func (_self *ChangeEpoch) StorageRebate() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpoch")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepoch_storage_rebate(
		_pointer,_uniffiStatus)
	}))
}

// System packages (specifically framework and move stdlib) that are
// written before the new epoch starts.
func (_self *ChangeEpoch) SystemPackages() []*SystemPackage {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpoch")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceSystemPackageINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_changeepoch_system_packages(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *ChangeEpoch) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterChangeEpoch struct {}

var FfiConverterChangeEpochINSTANCE = FfiConverterChangeEpoch{}


func (c FfiConverterChangeEpoch) Lift(pointer unsafe.Pointer) *ChangeEpoch {
	result := &ChangeEpoch {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_changeepoch(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_changeepoch(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ChangeEpoch).Destroy)
	return result
}

func (c FfiConverterChangeEpoch) Read(reader io.Reader) *ChangeEpoch {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterChangeEpoch) Lower(value *ChangeEpoch) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ChangeEpoch")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterChangeEpoch) Write(writer io.Writer, value *ChangeEpoch) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerChangeEpoch struct {}

func (_ FfiDestroyerChangeEpoch) Destroy(value *ChangeEpoch) {
		value.Destroy()
}



// System transaction used to change the epoch
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// change-epoch = u64  ; next epoch
// u64  ; protocol version
// u64  ; storage charge
// u64  ; computation charge
// u64  ; computation charge burned
// u64  ; storage rebate
// u64  ; non-refundable storage fee
// u64  ; epoch start timestamp
// (vector system-package)
// ```
type ChangeEpochV2Interface interface {
	// The total amount of gas charged for computation during the epoch.
	ComputationCharge() uint64
	// The total amount of gas burned for computation during the epoch.
	ComputationChargeBurned() uint64
	// The next (to become) epoch ID.
	Epoch() uint64
	// Unix timestamp when epoch started
	EpochStartTimestampMs() uint64
	// The non-refundable storage fee.
	NonRefundableStorageFee() uint64
	// The protocol version in effect in the new epoch.
	ProtocolVersion() uint64
	// The total amount of gas charged for storage during the epoch.
	StorageCharge() uint64
	// The amount of storage rebate refunded to the txn senders.
	StorageRebate() uint64
	// System packages (specifically framework and move stdlib) that are
	// written before the new epoch starts.
	SystemPackages() []*SystemPackage
}
// System transaction used to change the epoch
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// change-epoch = u64  ; next epoch
// u64  ; protocol version
// u64  ; storage charge
// u64  ; computation charge
// u64  ; computation charge burned
// u64  ; storage rebate
// u64  ; non-refundable storage fee
// u64  ; epoch start timestamp
// (vector system-package)
// ```
type ChangeEpochV2 struct {
	ffiObject FfiObject
}
func NewChangeEpochV2(epoch uint64, protocolVersion uint64, storageCharge uint64, computationCharge uint64, computationChargeBurned uint64, storageRebate uint64, nonRefundableStorageFee uint64, epochStartTimestampMs uint64, systemPackages []*SystemPackage) *ChangeEpochV2 {
	return FfiConverterChangeEpochV2INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_changeepochv2_new(FfiConverterUint64INSTANCE.Lower(epoch), FfiConverterUint64INSTANCE.Lower(protocolVersion), FfiConverterUint64INSTANCE.Lower(storageCharge), FfiConverterUint64INSTANCE.Lower(computationCharge), FfiConverterUint64INSTANCE.Lower(computationChargeBurned), FfiConverterUint64INSTANCE.Lower(storageRebate), FfiConverterUint64INSTANCE.Lower(nonRefundableStorageFee), FfiConverterUint64INSTANCE.Lower(epochStartTimestampMs), FfiConverterSequenceSystemPackageINSTANCE.Lower(systemPackages),_uniffiStatus)
	}))
}




// The total amount of gas charged for computation during the epoch.
func (_self *ChangeEpochV2) ComputationCharge() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV2")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv2_computation_charge(
		_pointer,_uniffiStatus)
	}))
}

// The total amount of gas burned for computation during the epoch.
func (_self *ChangeEpochV2) ComputationChargeBurned() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV2")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv2_computation_charge_burned(
		_pointer,_uniffiStatus)
	}))
}

// The next (to become) epoch ID.
func (_self *ChangeEpochV2) Epoch() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV2")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv2_epoch(
		_pointer,_uniffiStatus)
	}))
}

// Unix timestamp when epoch started
func (_self *ChangeEpochV2) EpochStartTimestampMs() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV2")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv2_epoch_start_timestamp_ms(
		_pointer,_uniffiStatus)
	}))
}

// The non-refundable storage fee.
func (_self *ChangeEpochV2) NonRefundableStorageFee() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV2")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv2_non_refundable_storage_fee(
		_pointer,_uniffiStatus)
	}))
}

// The protocol version in effect in the new epoch.
func (_self *ChangeEpochV2) ProtocolVersion() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV2")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv2_protocol_version(
		_pointer,_uniffiStatus)
	}))
}

// The total amount of gas charged for storage during the epoch.
func (_self *ChangeEpochV2) StorageCharge() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV2")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv2_storage_charge(
		_pointer,_uniffiStatus)
	}))
}

// The amount of storage rebate refunded to the txn senders.
func (_self *ChangeEpochV2) StorageRebate() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV2")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv2_storage_rebate(
		_pointer,_uniffiStatus)
	}))
}

// System packages (specifically framework and move stdlib) that are
// written before the new epoch starts.
func (_self *ChangeEpochV2) SystemPackages() []*SystemPackage {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV2")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceSystemPackageINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_changeepochv2_system_packages(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *ChangeEpochV2) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterChangeEpochV2 struct {}

var FfiConverterChangeEpochV2INSTANCE = FfiConverterChangeEpochV2{}


func (c FfiConverterChangeEpochV2) Lift(pointer unsafe.Pointer) *ChangeEpochV2 {
	result := &ChangeEpochV2 {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_changeepochv2(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_changeepochv2(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ChangeEpochV2).Destroy)
	return result
}

func (c FfiConverterChangeEpochV2) Read(reader io.Reader) *ChangeEpochV2 {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterChangeEpochV2) Lower(value *ChangeEpochV2) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ChangeEpochV2")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterChangeEpochV2) Write(writer io.Writer, value *ChangeEpochV2) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerChangeEpochV2 struct {}

func (_ FfiDestroyerChangeEpochV2) Destroy(value *ChangeEpochV2) {
		value.Destroy()
}



type ChangeEpochV3Interface interface {
	// The total amount of gas charged for computation during the epoch.
	ComputationCharge() uint64
	// The total amount of gas burned for computation during the epoch.
	ComputationChargeBurned() uint64
	// Vector of active validator indices eligible to take part in committee
	// selection because they support the new, target protocol version.
	EligibleActiveValidators() []uint64
	// The next (to become) epoch ID.
	Epoch() uint64
	// Unix timestamp when epoch started
	EpochStartTimestampMs() uint64
	// The non-refundable storage fee.
	NonRefundableStorageFee() uint64
	// The protocol version in effect in the new epoch.
	ProtocolVersion() uint64
	// The total amount of gas charged for storage during the epoch.
	StorageCharge() uint64
	// The amount of storage rebate refunded to the txn senders.
	StorageRebate() uint64
	// System packages (specifically framework and move stdlib) that are
	// written before the new epoch starts.
	SystemPackages() []*SystemPackage
}
type ChangeEpochV3 struct {
	ffiObject FfiObject
}
func NewChangeEpochV3(epoch uint64, protocolVersion uint64, storageCharge uint64, computationCharge uint64, computationChargeBurned uint64, storageRebate uint64, nonRefundableStorageFee uint64, epochStartTimestampMs uint64, systemPackages []*SystemPackage, eligibleActiveValidators []uint64) *ChangeEpochV3 {
	return FfiConverterChangeEpochV3INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_changeepochv3_new(FfiConverterUint64INSTANCE.Lower(epoch), FfiConverterUint64INSTANCE.Lower(protocolVersion), FfiConverterUint64INSTANCE.Lower(storageCharge), FfiConverterUint64INSTANCE.Lower(computationCharge), FfiConverterUint64INSTANCE.Lower(computationChargeBurned), FfiConverterUint64INSTANCE.Lower(storageRebate), FfiConverterUint64INSTANCE.Lower(nonRefundableStorageFee), FfiConverterUint64INSTANCE.Lower(epochStartTimestampMs), FfiConverterSequenceSystemPackageINSTANCE.Lower(systemPackages), FfiConverterSequenceUint64INSTANCE.Lower(eligibleActiveValidators),_uniffiStatus)
	}))
}




// The total amount of gas charged for computation during the epoch.
func (_self *ChangeEpochV3) ComputationCharge() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_computation_charge(
		_pointer,_uniffiStatus)
	}))
}

// The total amount of gas burned for computation during the epoch.
func (_self *ChangeEpochV3) ComputationChargeBurned() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_computation_charge_burned(
		_pointer,_uniffiStatus)
	}))
}

// Vector of active validator indices eligible to take part in committee
// selection because they support the new, target protocol version.
func (_self *ChangeEpochV3) EligibleActiveValidators() []uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_eligible_active_validators(
		_pointer,_uniffiStatus),
	}
	}))
}

// The next (to become) epoch ID.
func (_self *ChangeEpochV3) Epoch() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_epoch(
		_pointer,_uniffiStatus)
	}))
}

// Unix timestamp when epoch started
func (_self *ChangeEpochV3) EpochStartTimestampMs() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_epoch_start_timestamp_ms(
		_pointer,_uniffiStatus)
	}))
}

// The non-refundable storage fee.
func (_self *ChangeEpochV3) NonRefundableStorageFee() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_non_refundable_storage_fee(
		_pointer,_uniffiStatus)
	}))
}

// The protocol version in effect in the new epoch.
func (_self *ChangeEpochV3) ProtocolVersion() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_protocol_version(
		_pointer,_uniffiStatus)
	}))
}

// The total amount of gas charged for storage during the epoch.
func (_self *ChangeEpochV3) StorageCharge() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_storage_charge(
		_pointer,_uniffiStatus)
	}))
}

// The amount of storage rebate refunded to the txn senders.
func (_self *ChangeEpochV3) StorageRebate() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_storage_rebate(
		_pointer,_uniffiStatus)
	}))
}

// System packages (specifically framework and move stdlib) that are
// written before the new epoch starts.
func (_self *ChangeEpochV3) SystemPackages() []*SystemPackage {
	_pointer := _self.ffiObject.incrementPointer("*ChangeEpochV3")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceSystemPackageINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_changeepochv3_system_packages(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *ChangeEpochV3) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterChangeEpochV3 struct {}

var FfiConverterChangeEpochV3INSTANCE = FfiConverterChangeEpochV3{}


func (c FfiConverterChangeEpochV3) Lift(pointer unsafe.Pointer) *ChangeEpochV3 {
	result := &ChangeEpochV3 {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_changeepochv3(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_changeepochv3(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ChangeEpochV3).Destroy)
	return result
}

func (c FfiConverterChangeEpochV3) Read(reader io.Reader) *ChangeEpochV3 {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterChangeEpochV3) Lower(value *ChangeEpochV3) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ChangeEpochV3")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterChangeEpochV3) Write(writer io.Writer, value *ChangeEpochV3) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerChangeEpochV3 struct {}

func (_ FfiDestroyerChangeEpochV3) Destroy(value *ChangeEpochV3) {
		value.Destroy()
}



// A commitment made by a checkpoint.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// ; CheckpointCommitment is an enum and each variant is prefixed with its index
// checkpoint-commitment = ecmh-live-object-set
// ecmh-live-object-set = %x00 digest
// ```
type CheckpointCommitmentInterface interface {
	AsEcmhLiveObjectSetDigest() *Digest
	IsEcmhLiveObjectSet() bool
}
// A commitment made by a checkpoint.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// ; CheckpointCommitment is an enum and each variant is prefixed with its index
// checkpoint-commitment = ecmh-live-object-set
// ecmh-live-object-set = %x00 digest
// ```
type CheckpointCommitment struct {
	ffiObject FfiObject
}




func (_self *CheckpointCommitment) AsEcmhLiveObjectSetDigest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointCommitment")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointcommitment_as_ecmh_live_object_set_digest(
		_pointer,_uniffiStatus)
	}))
}

func (_self *CheckpointCommitment) IsEcmhLiveObjectSet() bool {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointCommitment")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointcommitment_is_ecmh_live_object_set(
		_pointer,_uniffiStatus)
	}))
}
func (object *CheckpointCommitment) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterCheckpointCommitment struct {}

var FfiConverterCheckpointCommitmentINSTANCE = FfiConverterCheckpointCommitment{}


func (c FfiConverterCheckpointCommitment) Lift(pointer unsafe.Pointer) *CheckpointCommitment {
	result := &CheckpointCommitment {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_checkpointcommitment(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_checkpointcommitment(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*CheckpointCommitment).Destroy)
	return result
}

func (c FfiConverterCheckpointCommitment) Read(reader io.Reader) *CheckpointCommitment {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterCheckpointCommitment) Lower(value *CheckpointCommitment) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*CheckpointCommitment")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterCheckpointCommitment) Write(writer io.Writer, value *CheckpointCommitment) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerCheckpointCommitment struct {}

func (_ FfiDestroyerCheckpointCommitment) Destroy(value *CheckpointCommitment) {
		value.Destroy()
}



// The committed to contents of a checkpoint.
//
// `CheckpointContents` contains a list of digests of Transactions, their
// effects, and the user signatures that authorized their execution included in
// a checkpoint.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// checkpoint-contents = %x00 checkpoint-contents-v1 ; variant 0
//
// checkpoint-contents-v1 = (vector (digest digest)) ; vector of transaction and effect digests
// (vector (vector bcs-user-signature)) ; set of user signatures for each
// ; transaction. MUST be the same
// ; length as the vector of digests
// ```
type CheckpointContentsInterface interface {
	Digest() *Digest
	TransactionInfo() []*CheckpointTransactionInfo
}
// The committed to contents of a checkpoint.
//
// `CheckpointContents` contains a list of digests of Transactions, their
// effects, and the user signatures that authorized their execution included in
// a checkpoint.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// checkpoint-contents = %x00 checkpoint-contents-v1 ; variant 0
//
// checkpoint-contents-v1 = (vector (digest digest)) ; vector of transaction and effect digests
// (vector (vector bcs-user-signature)) ; set of user signatures for each
// ; transaction. MUST be the same
// ; length as the vector of digests
// ```
type CheckpointContents struct {
	ffiObject FfiObject
}
func NewCheckpointContents(transactionInfo []*CheckpointTransactionInfo) *CheckpointContents {
	return FfiConverterCheckpointContentsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_checkpointcontents_new(FfiConverterSequenceCheckpointTransactionInfoINSTANCE.Lower(transactionInfo),_uniffiStatus)
	}))
}




func (_self *CheckpointContents) Digest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointContents")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointcontents_digest(
		_pointer,_uniffiStatus)
	}))
}

func (_self *CheckpointContents) TransactionInfo() []*CheckpointTransactionInfo {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointContents")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceCheckpointTransactionInfoINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_checkpointcontents_transaction_info(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *CheckpointContents) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterCheckpointContents struct {}

var FfiConverterCheckpointContentsINSTANCE = FfiConverterCheckpointContents{}


func (c FfiConverterCheckpointContents) Lift(pointer unsafe.Pointer) *CheckpointContents {
	result := &CheckpointContents {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_checkpointcontents(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_checkpointcontents(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*CheckpointContents).Destroy)
	return result
}

func (c FfiConverterCheckpointContents) Read(reader io.Reader) *CheckpointContents {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterCheckpointContents) Lower(value *CheckpointContents) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*CheckpointContents")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterCheckpointContents) Write(writer io.Writer, value *CheckpointContents) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerCheckpointContents struct {}

func (_ FfiDestroyerCheckpointContents) Destroy(value *CheckpointContents) {
		value.Destroy()
}



// A header for a Checkpoint on the IOTA blockchain.
//
// On the IOTA network, checkpoints define the history of the blockchain. They
// are quite similar to the concept of blocks used by other blockchains like
// Bitcoin or Ethereum. The IOTA blockchain, however, forms checkpoints after
// transaction execution has already happened to provide a certified history of
// the chain, instead of being formed before execution.
//
// Checkpoints commit to a variety of state including but not limited to:
// - The hash of the previous checkpoint.
// - The set of transaction digests, their corresponding effects digests, as
// well as the set of user signatures which authorized its execution.
// - The object's produced by a transaction.
// - The set of live objects that make up the current state of the chain.
// - On epoch transitions, the next validator committee.
//
// `CheckpointSummary`s themselves don't directly include all of the above
// information but they are the top-level type by which all the above are
// committed to transitively via cryptographic hashes included in the summary.
// `CheckpointSummary`s are signed and certified by a quorum of the validator
// committee in a given epoch in order to allow verification of the chain's
// state.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// checkpoint-summary = u64                            ; epoch
// u64                            ; sequence_number
// u64                            ; network_total_transactions
// digest                         ; content_digest
// (option digest)                ; previous_digest
// gas-cost-summary               ; epoch_rolling_gas_cost_summary
// u64                            ; timestamp_ms
// (vector checkpoint-commitment) ; checkpoint_commitments
// (option end-of-epoch-data)     ; end_of_epoch_data
// bytes                          ; version_specific_data
// ```
type CheckpointSummaryInterface interface {
	// Commitments to checkpoint-specific state.
	CheckpointCommitments() []*CheckpointCommitment
	// The hash of the `CheckpointContents` for this checkpoint.
	ContentDigest() *Digest
	Digest() *Digest
	// Extra data only present in the final checkpoint of an epoch.
	EndOfEpochData() *EndOfEpochData
	// Epoch that this checkpoint belongs to.
	Epoch() uint64
	// The running total gas costs of all transactions included in the current
	// epoch so far until this checkpoint.
	EpochRollingGasCostSummary() GasCostSummary
	// Total number of transactions committed since genesis, including those in
	// this checkpoint.
	NetworkTotalTransactions() uint64
	// The hash of the previous `CheckpointSummary`.
	//
	// This will be only be `None` for the first, or genesis checkpoint.
	PreviousDigest() **Digest
	// The height of this checkpoint.
	SequenceNumber() uint64
	SigningMessage() []byte
	SigningMessageHex() string
	// Timestamp of the checkpoint - number of milliseconds from the Unix epoch
	// Checkpoint timestamps are monotonic, but not strongly monotonic -
	// subsequent checkpoints can have same timestamp if they originate
	// from the same underlining consensus commit
	TimestampMs() uint64
	// CheckpointSummary is not an evolvable structure - it must be readable by
	// any version of the code. Therefore, in order to allow extensions to
	// be added to CheckpointSummary, we allow opaque data to be added to
	// checkpoints which can be deserialized based on the current
	// protocol version.
	VersionSpecificData() []byte
}
// A header for a Checkpoint on the IOTA blockchain.
//
// On the IOTA network, checkpoints define the history of the blockchain. They
// are quite similar to the concept of blocks used by other blockchains like
// Bitcoin or Ethereum. The IOTA blockchain, however, forms checkpoints after
// transaction execution has already happened to provide a certified history of
// the chain, instead of being formed before execution.
//
// Checkpoints commit to a variety of state including but not limited to:
// - The hash of the previous checkpoint.
// - The set of transaction digests, their corresponding effects digests, as
// well as the set of user signatures which authorized its execution.
// - The object's produced by a transaction.
// - The set of live objects that make up the current state of the chain.
// - On epoch transitions, the next validator committee.
//
// `CheckpointSummary`s themselves don't directly include all of the above
// information but they are the top-level type by which all the above are
// committed to transitively via cryptographic hashes included in the summary.
// `CheckpointSummary`s are signed and certified by a quorum of the validator
// committee in a given epoch in order to allow verification of the chain's
// state.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// checkpoint-summary = u64                            ; epoch
// u64                            ; sequence_number
// u64                            ; network_total_transactions
// digest                         ; content_digest
// (option digest)                ; previous_digest
// gas-cost-summary               ; epoch_rolling_gas_cost_summary
// u64                            ; timestamp_ms
// (vector checkpoint-commitment) ; checkpoint_commitments
// (option end-of-epoch-data)     ; end_of_epoch_data
// bytes                          ; version_specific_data
// ```
type CheckpointSummary struct {
	ffiObject FfiObject
}
func NewCheckpointSummary(epoch uint64, sequenceNumber uint64, networkTotalTransactions uint64, contentDigest *Digest, previousDigest **Digest, epochRollingGasCostSummary GasCostSummary, timestampMs uint64, checkpointCommitments []*CheckpointCommitment, endOfEpochData *EndOfEpochData, versionSpecificData []byte) *CheckpointSummary {
	return FfiConverterCheckpointSummaryINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_checkpointsummary_new(FfiConverterUint64INSTANCE.Lower(epoch), FfiConverterUint64INSTANCE.Lower(sequenceNumber), FfiConverterUint64INSTANCE.Lower(networkTotalTransactions), FfiConverterDigestINSTANCE.Lower(contentDigest), FfiConverterOptionalDigestINSTANCE.Lower(previousDigest), FfiConverterGasCostSummaryINSTANCE.Lower(epochRollingGasCostSummary), FfiConverterUint64INSTANCE.Lower(timestampMs), FfiConverterSequenceCheckpointCommitmentINSTANCE.Lower(checkpointCommitments), FfiConverterOptionalEndOfEpochDataINSTANCE.Lower(endOfEpochData), FfiConverterBytesINSTANCE.Lower(versionSpecificData),_uniffiStatus)
	}))
}




// Commitments to checkpoint-specific state.
func (_self *CheckpointSummary) CheckpointCommitments() []*CheckpointCommitment {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceCheckpointCommitmentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_checkpoint_commitments(
		_pointer,_uniffiStatus),
	}
	}))
}

// The hash of the `CheckpointContents` for this checkpoint.
func (_self *CheckpointSummary) ContentDigest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_content_digest(
		_pointer,_uniffiStatus)
	}))
}

func (_self *CheckpointSummary) Digest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_digest(
		_pointer,_uniffiStatus)
	}))
}

// Extra data only present in the final checkpoint of an epoch.
func (_self *CheckpointSummary) EndOfEpochData() *EndOfEpochData {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalEndOfEpochDataINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_end_of_epoch_data(
		_pointer,_uniffiStatus),
	}
	}))
}

// Epoch that this checkpoint belongs to.
func (_self *CheckpointSummary) Epoch() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_epoch(
		_pointer,_uniffiStatus)
	}))
}

// The running total gas costs of all transactions included in the current
// epoch so far until this checkpoint.
func (_self *CheckpointSummary) EpochRollingGasCostSummary() GasCostSummary {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterGasCostSummaryINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_epoch_rolling_gas_cost_summary(
		_pointer,_uniffiStatus),
	}
	}))
}

// Total number of transactions committed since genesis, including those in
// this checkpoint.
func (_self *CheckpointSummary) NetworkTotalTransactions() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_network_total_transactions(
		_pointer,_uniffiStatus)
	}))
}

// The hash of the previous `CheckpointSummary`.
//
// This will be only be `None` for the first, or genesis checkpoint.
func (_self *CheckpointSummary) PreviousDigest() **Digest {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_previous_digest(
		_pointer,_uniffiStatus),
	}
	}))
}

// The height of this checkpoint.
func (_self *CheckpointSummary) SequenceNumber() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_sequence_number(
		_pointer,_uniffiStatus)
	}))
}

func (_self *CheckpointSummary) SigningMessage() []byte {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_signing_message(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *CheckpointSummary) SigningMessageHex() string {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_signing_message_hex(
		_pointer,_uniffiStatus),
	}
	}))
}

// Timestamp of the checkpoint - number of milliseconds from the Unix epoch
// Checkpoint timestamps are monotonic, but not strongly monotonic -
// subsequent checkpoints can have same timestamp if they originate
// from the same underlining consensus commit
func (_self *CheckpointSummary) TimestampMs() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_timestamp_ms(
		_pointer,_uniffiStatus)
	}))
}

// CheckpointSummary is not an evolvable structure - it must be readable by
// any version of the code. Therefore, in order to allow extensions to
// be added to CheckpointSummary, we allow opaque data to be added to
// checkpoints which can be deserialized based on the current
// protocol version.
func (_self *CheckpointSummary) VersionSpecificData() []byte {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_version_specific_data(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *CheckpointSummary) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterCheckpointSummary struct {}

var FfiConverterCheckpointSummaryINSTANCE = FfiConverterCheckpointSummary{}


func (c FfiConverterCheckpointSummary) Lift(pointer unsafe.Pointer) *CheckpointSummary {
	result := &CheckpointSummary {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_checkpointsummary(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_checkpointsummary(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*CheckpointSummary).Destroy)
	return result
}

func (c FfiConverterCheckpointSummary) Read(reader io.Reader) *CheckpointSummary {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterCheckpointSummary) Lower(value *CheckpointSummary) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*CheckpointSummary")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterCheckpointSummary) Write(writer io.Writer, value *CheckpointSummary) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerCheckpointSummary struct {}

func (_ FfiDestroyerCheckpointSummary) Destroy(value *CheckpointSummary) {
		value.Destroy()
}



// Transaction information committed to in a checkpoint
type CheckpointTransactionInfoInterface interface {
	Effects() *Digest
	Signatures() []*UserSignature
	Transaction() *Digest
}
// Transaction information committed to in a checkpoint
type CheckpointTransactionInfo struct {
	ffiObject FfiObject
}
func NewCheckpointTransactionInfo(transaction *Digest, effects *Digest, signatures []*UserSignature) *CheckpointTransactionInfo {
	return FfiConverterCheckpointTransactionInfoINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_checkpointtransactioninfo_new(FfiConverterDigestINSTANCE.Lower(transaction), FfiConverterDigestINSTANCE.Lower(effects), FfiConverterSequenceUserSignatureINSTANCE.Lower(signatures),_uniffiStatus)
	}))
}




func (_self *CheckpointTransactionInfo) Effects() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointTransactionInfo")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_effects(
		_pointer,_uniffiStatus)
	}))
}

func (_self *CheckpointTransactionInfo) Signatures() []*UserSignature {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointTransactionInfo")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceUserSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_signatures(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *CheckpointTransactionInfo) Transaction() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*CheckpointTransactionInfo")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_transaction(
		_pointer,_uniffiStatus)
	}))
}
func (object *CheckpointTransactionInfo) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterCheckpointTransactionInfo struct {}

var FfiConverterCheckpointTransactionInfoINSTANCE = FfiConverterCheckpointTransactionInfo{}


func (c FfiConverterCheckpointTransactionInfo) Lift(pointer unsafe.Pointer) *CheckpointTransactionInfo {
	result := &CheckpointTransactionInfo {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_checkpointtransactioninfo(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_checkpointtransactioninfo(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*CheckpointTransactionInfo).Destroy)
	return result
}

func (c FfiConverterCheckpointTransactionInfo) Read(reader io.Reader) *CheckpointTransactionInfo {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterCheckpointTransactionInfo) Lower(value *CheckpointTransactionInfo) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*CheckpointTransactionInfo")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterCheckpointTransactionInfo) Write(writer io.Writer, value *CheckpointTransactionInfo) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerCheckpointTransactionInfo struct {}

func (_ FfiDestroyerCheckpointTransactionInfo) Destroy(value *CheckpointTransactionInfo) {
		value.Destroy()
}



// A G1 point
//
// This represents the canonical decimal representation of the projective
// coordinates in Fq.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// circom-g1 = %x03 3(bn254-field-element)
// ```
type CircomG1Interface interface {
}
// A G1 point
//
// This represents the canonical decimal representation of the projective
// coordinates in Fq.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// circom-g1 = %x03 3(bn254-field-element)
// ```
type CircomG1 struct {
	ffiObject FfiObject
}
func NewCircomG1(el0 *Bn254FieldElement, el1 *Bn254FieldElement, el2 *Bn254FieldElement) *CircomG1 {
	return FfiConverterCircomG1INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_circomg1_new(FfiConverterBn254FieldElementINSTANCE.Lower(el0), FfiConverterBn254FieldElementINSTANCE.Lower(el1), FfiConverterBn254FieldElementINSTANCE.Lower(el2),_uniffiStatus)
	}))
}



func (object *CircomG1) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterCircomG1 struct {}

var FfiConverterCircomG1INSTANCE = FfiConverterCircomG1{}


func (c FfiConverterCircomG1) Lift(pointer unsafe.Pointer) *CircomG1 {
	result := &CircomG1 {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_circomg1(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_circomg1(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*CircomG1).Destroy)
	return result
}

func (c FfiConverterCircomG1) Read(reader io.Reader) *CircomG1 {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterCircomG1) Lower(value *CircomG1) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*CircomG1")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterCircomG1) Write(writer io.Writer, value *CircomG1) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerCircomG1 struct {}

func (_ FfiDestroyerCircomG1) Destroy(value *CircomG1) {
		value.Destroy()
}



// A G2 point
//
// This represents the canonical decimal representation of the coefficients of
// the projective coordinates in Fq2.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// circom-g2 = %x03 3(%x02 2(bn254-field-element))
// ```
type CircomG2Interface interface {
}
// A G2 point
//
// This represents the canonical decimal representation of the coefficients of
// the projective coordinates in Fq2.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// circom-g2 = %x03 3(%x02 2(bn254-field-element))
// ```
type CircomG2 struct {
	ffiObject FfiObject
}
func NewCircomG2(el00 *Bn254FieldElement, el01 *Bn254FieldElement, el10 *Bn254FieldElement, el11 *Bn254FieldElement, el20 *Bn254FieldElement, el21 *Bn254FieldElement) *CircomG2 {
	return FfiConverterCircomG2INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_circomg2_new(FfiConverterBn254FieldElementINSTANCE.Lower(el00), FfiConverterBn254FieldElementINSTANCE.Lower(el01), FfiConverterBn254FieldElementINSTANCE.Lower(el10), FfiConverterBn254FieldElementINSTANCE.Lower(el11), FfiConverterBn254FieldElementINSTANCE.Lower(el20), FfiConverterBn254FieldElementINSTANCE.Lower(el21),_uniffiStatus)
	}))
}



func (object *CircomG2) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterCircomG2 struct {}

var FfiConverterCircomG2INSTANCE = FfiConverterCircomG2{}


func (c FfiConverterCircomG2) Lift(pointer unsafe.Pointer) *CircomG2 {
	result := &CircomG2 {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_circomg2(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_circomg2(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*CircomG2).Destroy)
	return result
}

func (c FfiConverterCircomG2) Read(reader io.Reader) *CircomG2 {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterCircomG2) Lower(value *CircomG2) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*CircomG2")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterCircomG2) Write(writer io.Writer, value *CircomG2) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerCircomG2 struct {}

func (_ FfiDestroyerCircomG2) Destroy(value *CircomG2) {
		value.Destroy()
}



// A builder for creating transactions which uses a GraphQL client to
// automatically resolve inputs. Use `finish` to finalize the transaction data.
type ClientTransactionBuilderInterface interface {
	// Dry run the transaction.
	DryRun(skipChecks bool) (DryRunResult, error)
	// Execute the transaction and optionally wait for finalization.
	Execute(keypair *SimpleKeypair, waitFor *WaitForTx) (*TransactionEffects, error)
	// Execute the transaction and optionally wait for finalization.
	ExecuteWithSponsor(keypair *SimpleKeypair, sponsorKeypair *SimpleKeypair, waitFor *WaitForTx) (*TransactionEffects, error)
	// Set the expiration of the transaction to be a specific epoch.
	Expiration(epoch uint64) *ClientTransactionBuilder
	// Convert this builder into a transaction.
	Finish() (*Transaction, error)
	// Add gas coins that will be consumed. Optional.
	Gas(objectIds []*ObjectId) *ClientTransactionBuilder
	// Set the gas budget for the transaction.
	GasBudget(budget uint64) *ClientTransactionBuilder
	// Set the gas price for the transaction.
	GasPrice(price uint64) *ClientTransactionBuilder
	// Set the gas station sponsor.
	GasStationSponsor(url string, duration *time.Duration, headers *map[string][]string) *ClientTransactionBuilder
	// Make a move vector from a list of elements. The elements must all be of
	// the type indicated by `type_tag`.
	MakeMoveVec(elements []*MoveArg, typeTag *TypeTag, name string) *ClientTransactionBuilder
	// Merge multiple coins into one.
	//
	// This method combines the balances of multiple coins of the same coin
	// type into a single coin. The `primary_coin` will receive the balances
	// from all `consumed_coins`. After merging, the `consumed_coins` will
	// be consumed and no longer exist.
	MergeCoins(primaryCoin *PtbArgument, consumedCoins []*PtbArgument) *ClientTransactionBuilder
	// Call a Move function with the given arguments.
	MoveCall(varPackage *Address, module *Identifier, function *Identifier, arguments []*PtbArgument, typeArgs []*TypeTag, names []string) *ClientTransactionBuilder
	// Publish a list of modules with the given dependencies. The result
	// assigned to `upgrade_cap_name` is the `0x2::package::UpgradeCap`
	// Move type. Note that the upgrade capability needs to be handled
	// after this call:
	// - transfer it to the transaction sender or another address
	// - burn it
	// - wrap it for access control
	// - discard the it to make a package immutable
	//
	// The arguments required for this command are:
	// - `modules`: is the modules' bytecode to be published
	// - `dependencies`: is the list of IDs of the transitive dependencies of
	// the package
	Publish(packageData *MovePackageData, upgradeCapName string) *ClientTransactionBuilder
	// Transfer some coins to a recipient address. If multiple coins are
	// provided then they will be merged.
	//
	// The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
	// equals 1_000_000_000 NANOS.
	// If `amount` is provided, that amount is split from the provided coins
	// and sent.
	// If `amount` is `None`, the entire coins are transferred.
	//
	// All provided coins must have the same coin type. Mixing coins of
	// different types will result in an error.
	//
	// If you intend to transfer all provided coins to another address in a
	// single transaction, consider using
	// `TransactionBuilder::transfer_objects()` instead.
	SendCoins(coins []*PtbArgument, recipient *Address, amount **PtbArgument) *ClientTransactionBuilder
	// Send IOTA to a recipient address.
	//
	// The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
	// equals 1_000_000_000 NANOS. That amount is split from the gas coin and
	// sent.
	SendIota(recipient *Address, amount *PtbArgument) *ClientTransactionBuilder
	// Split a coin into many.
	SplitCoins(coin *PtbArgument, amounts []*PtbArgument, names []string) *ClientTransactionBuilder
	// Set the sponsor of the transaction.
	Sponsor(sponsor *Address) *ClientTransactionBuilder
	// Add stake to a validator's staking pool.
	//
	// This is a high-level function which will split the provided stake amount
	// from the gas coin and then stake using the resulting coin.
	Stake(stake *PtbArgument, validatorAddress *Address) *ClientTransactionBuilder
	// Transfer a list of objects to the given address, without producing any
	// result.
	TransferObjects(recipient *Address, objects []*PtbArgument) *ClientTransactionBuilder
	// Withdraw stake from a validator's staking pool.
	Unstake(stakedIota *PtbArgument) *ClientTransactionBuilder
	// Upgrade a Move package.
	//
	// - `modules`: is the modules' bytecode for the modules to be published
	// - `dependencies`: is the list of IDs of the transitive dependencies of
	// the package to be upgraded
	// - `package`: is the ID of the current package being upgraded
	// - `ticket`: is the upgrade ticket
	//
	// To get the ticket, you have to call the
	// `0x2::package::authorize_upgrade` function, and pass the package
	// ID, the upgrade policy, and package digest.
	Upgrade(packageId *ObjectId, packageData *MovePackageData, upgradeTicket *PtbArgument, name *string) *ClientTransactionBuilder
}
// A builder for creating transactions which uses a GraphQL client to
// automatically resolve inputs. Use `finish` to finalize the transaction data.
type ClientTransactionBuilder struct {
	ffiObject FfiObject
}




// Dry run the transaction.
func (_self *ClientTransactionBuilder) DryRun(skipChecks bool) (DryRunResult, error) {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) DryRunResult {
			return FfiConverterDryRunResultINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_dry_run(
		_pointer,FfiConverterBoolINSTANCE.Lower(skipChecks)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Execute the transaction and optionally wait for finalization.
func (_self *ClientTransactionBuilder) Execute(keypair *SimpleKeypair, waitFor *WaitForTx) (*TransactionEffects, error) {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *TransactionEffects {
			return FfiConverterTransactionEffectsINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_execute(
		_pointer,FfiConverterSimpleKeypairINSTANCE.Lower(keypair), FfiConverterOptionalWaitForTxINSTANCE.Lower(waitFor)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err 
}

// Execute the transaction and optionally wait for finalization.
func (_self *ClientTransactionBuilder) ExecuteWithSponsor(keypair *SimpleKeypair, sponsorKeypair *SimpleKeypair, waitFor *WaitForTx) (*TransactionEffects, error) {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *TransactionEffects {
			return FfiConverterTransactionEffectsINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_execute_with_sponsor(
		_pointer,FfiConverterSimpleKeypairINSTANCE.Lower(keypair), FfiConverterSimpleKeypairINSTANCE.Lower(sponsorKeypair), FfiConverterOptionalWaitForTxINSTANCE.Lower(waitFor)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err 
}

// Set the expiration of the transaction to be a specific epoch.
func (_self *ClientTransactionBuilder) Expiration(epoch uint64) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_expiration(
		_pointer,FfiConverterUint64INSTANCE.Lower(epoch),_uniffiStatus)
	}))
}

// Convert this builder into a transaction.
func (_self *ClientTransactionBuilder) Finish() (*Transaction, error) {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *Transaction {
			return FfiConverterTransactionINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_finish(
		_pointer,),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err 
}

// Add gas coins that will be consumed. Optional.
func (_self *ClientTransactionBuilder) Gas(objectIds []*ObjectId) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas(
		_pointer,FfiConverterSequenceObjectIdINSTANCE.Lower(objectIds),_uniffiStatus)
	}))
}

// Set the gas budget for the transaction.
func (_self *ClientTransactionBuilder) GasBudget(budget uint64) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_budget(
		_pointer,FfiConverterUint64INSTANCE.Lower(budget),_uniffiStatus)
	}))
}

// Set the gas price for the transaction.
func (_self *ClientTransactionBuilder) GasPrice(price uint64) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_price(
		_pointer,FfiConverterUint64INSTANCE.Lower(price),_uniffiStatus)
	}))
}

// Set the gas station sponsor.
func (_self *ClientTransactionBuilder) GasStationSponsor(url string, duration *time.Duration, headers *map[string][]string) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_station_sponsor(
		_pointer,FfiConverterStringINSTANCE.Lower(url), FfiConverterOptionalDurationINSTANCE.Lower(duration), FfiConverterOptionalMapStringSequenceStringINSTANCE.Lower(headers),_uniffiStatus)
	}))
}

// Make a move vector from a list of elements. The elements must all be of
// the type indicated by `type_tag`.
func (_self *ClientTransactionBuilder) MakeMoveVec(elements []*MoveArg, typeTag *TypeTag, name string) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_make_move_vec(
		_pointer,FfiConverterSequenceMoveArgINSTANCE.Lower(elements), FfiConverterTypeTagINSTANCE.Lower(typeTag), FfiConverterStringINSTANCE.Lower(name),_uniffiStatus)
	}))
}

// Merge multiple coins into one.
//
// This method combines the balances of multiple coins of the same coin
// type into a single coin. The `primary_coin` will receive the balances
// from all `consumed_coins`. After merging, the `consumed_coins` will
// be consumed and no longer exist.
func (_self *ClientTransactionBuilder) MergeCoins(primaryCoin *PtbArgument, consumedCoins []*PtbArgument) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_merge_coins(
		_pointer,FfiConverterPtbArgumentINSTANCE.Lower(primaryCoin), FfiConverterSequencePtbArgumentINSTANCE.Lower(consumedCoins),_uniffiStatus)
	}))
}

// Call a Move function with the given arguments.
func (_self *ClientTransactionBuilder) MoveCall(varPackage *Address, module *Identifier, function *Identifier, arguments []*PtbArgument, typeArgs []*TypeTag, names []string) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_move_call(
		_pointer,FfiConverterAddressINSTANCE.Lower(varPackage), FfiConverterIdentifierINSTANCE.Lower(module), FfiConverterIdentifierINSTANCE.Lower(function), FfiConverterSequencePtbArgumentINSTANCE.Lower(arguments), FfiConverterSequenceTypeTagINSTANCE.Lower(typeArgs), FfiConverterSequenceStringINSTANCE.Lower(names),_uniffiStatus)
	}))
}

// Publish a list of modules with the given dependencies. The result
// assigned to `upgrade_cap_name` is the `0x2::package::UpgradeCap`
// Move type. Note that the upgrade capability needs to be handled
// after this call:
// - transfer it to the transaction sender or another address
// - burn it
// - wrap it for access control
// - discard the it to make a package immutable
//
// The arguments required for this command are:
// - `modules`: is the modules' bytecode to be published
// - `dependencies`: is the list of IDs of the transitive dependencies of
// the package
func (_self *ClientTransactionBuilder) Publish(packageData *MovePackageData, upgradeCapName string) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_publish(
		_pointer,FfiConverterMovePackageDataINSTANCE.Lower(packageData), FfiConverterStringINSTANCE.Lower(upgradeCapName),_uniffiStatus)
	}))
}

// Transfer some coins to a recipient address. If multiple coins are
// provided then they will be merged.
//
// The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
// equals 1_000_000_000 NANOS.
// If `amount` is provided, that amount is split from the provided coins
// and sent.
// If `amount` is `None`, the entire coins are transferred.
//
// All provided coins must have the same coin type. Mixing coins of
// different types will result in an error.
//
// If you intend to transfer all provided coins to another address in a
// single transaction, consider using
// `TransactionBuilder::transfer_objects()` instead.
func (_self *ClientTransactionBuilder) SendCoins(coins []*PtbArgument, recipient *Address, amount **PtbArgument) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_send_coins(
		_pointer,FfiConverterSequencePtbArgumentINSTANCE.Lower(coins), FfiConverterAddressINSTANCE.Lower(recipient), FfiConverterOptionalPtbArgumentINSTANCE.Lower(amount),_uniffiStatus)
	}))
}

// Send IOTA to a recipient address.
//
// The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
// equals 1_000_000_000 NANOS. That amount is split from the gas coin and
// sent.
func (_self *ClientTransactionBuilder) SendIota(recipient *Address, amount *PtbArgument) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_send_iota(
		_pointer,FfiConverterAddressINSTANCE.Lower(recipient), FfiConverterPtbArgumentINSTANCE.Lower(amount),_uniffiStatus)
	}))
}

// Split a coin into many.
func (_self *ClientTransactionBuilder) SplitCoins(coin *PtbArgument, amounts []*PtbArgument, names []string) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_split_coins(
		_pointer,FfiConverterPtbArgumentINSTANCE.Lower(coin), FfiConverterSequencePtbArgumentINSTANCE.Lower(amounts), FfiConverterSequenceStringINSTANCE.Lower(names),_uniffiStatus)
	}))
}

// Set the sponsor of the transaction.
func (_self *ClientTransactionBuilder) Sponsor(sponsor *Address) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_sponsor(
		_pointer,FfiConverterAddressINSTANCE.Lower(sponsor),_uniffiStatus)
	}))
}

// Add stake to a validator's staking pool.
//
// This is a high-level function which will split the provided stake amount
// from the gas coin and then stake using the resulting coin.
func (_self *ClientTransactionBuilder) Stake(stake *PtbArgument, validatorAddress *Address) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_stake(
		_pointer,FfiConverterPtbArgumentINSTANCE.Lower(stake), FfiConverterAddressINSTANCE.Lower(validatorAddress),_uniffiStatus)
	}))
}

// Transfer a list of objects to the given address, without producing any
// result.
func (_self *ClientTransactionBuilder) TransferObjects(recipient *Address, objects []*PtbArgument) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_transfer_objects(
		_pointer,FfiConverterAddressINSTANCE.Lower(recipient), FfiConverterSequencePtbArgumentINSTANCE.Lower(objects),_uniffiStatus)
	}))
}

// Withdraw stake from a validator's staking pool.
func (_self *ClientTransactionBuilder) Unstake(stakedIota *PtbArgument) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_unstake(
		_pointer,FfiConverterPtbArgumentINSTANCE.Lower(stakedIota),_uniffiStatus)
	}))
}

// Upgrade a Move package.
//
// - `modules`: is the modules' bytecode for the modules to be published
// - `dependencies`: is the list of IDs of the transitive dependencies of
// the package to be upgraded
// - `package`: is the ID of the current package being upgraded
// - `ticket`: is the upgrade ticket
//
// To get the ticket, you have to call the
// `0x2::package::authorize_upgrade` function, and pass the package
// ID, the upgrade policy, and package digest.
func (_self *ClientTransactionBuilder) Upgrade(packageId *ObjectId, packageData *MovePackageData, upgradeTicket *PtbArgument, name *string) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_upgrade(
		_pointer,FfiConverterObjectIdINSTANCE.Lower(packageId), FfiConverterMovePackageDataINSTANCE.Lower(packageData), FfiConverterPtbArgumentINSTANCE.Lower(upgradeTicket), FfiConverterOptionalStringINSTANCE.Lower(name),_uniffiStatus)
	}))
}
func (object *ClientTransactionBuilder) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterClientTransactionBuilder struct {}

var FfiConverterClientTransactionBuilderINSTANCE = FfiConverterClientTransactionBuilder{}


func (c FfiConverterClientTransactionBuilder) Lift(pointer unsafe.Pointer) *ClientTransactionBuilder {
	result := &ClientTransactionBuilder {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_clienttransactionbuilder(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_clienttransactionbuilder(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ClientTransactionBuilder).Destroy)
	return result
}

func (c FfiConverterClientTransactionBuilder) Read(reader io.Reader) *ClientTransactionBuilder {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterClientTransactionBuilder) Lower(value *ClientTransactionBuilder) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ClientTransactionBuilder")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterClientTransactionBuilder) Write(writer io.Writer, value *ClientTransactionBuilder) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerClientTransactionBuilder struct {}

func (_ FfiDestroyerClientTransactionBuilder) Destroy(value *ClientTransactionBuilder) {
		value.Destroy()
}



type CoinInterface interface {
	Balance() uint64
	CoinType() *TypeTag
	Id() *ObjectId
}
type Coin struct {
	ffiObject FfiObject
}


func CoinTryFromObject(object *Object) (*Coin, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_coin_try_from_object(FfiConverterObjectINSTANCE.Lower(object),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Coin
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCoinINSTANCE.Lift(_uniffiRV), nil
		}
}



func (_self *Coin) Balance() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*Coin")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_coin_balance(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Coin) CoinType() *TypeTag {
	_pointer := _self.ffiObject.incrementPointer("*Coin")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_coin_coin_type(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Coin) Id() *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*Coin")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_coin_id(
		_pointer,_uniffiStatus)
	}))
}
func (object *Coin) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterCoin struct {}

var FfiConverterCoinINSTANCE = FfiConverterCoin{}


func (c FfiConverterCoin) Lift(pointer unsafe.Pointer) *Coin {
	result := &Coin {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_coin(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_coin(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Coin).Destroy)
	return result
}

func (c FfiConverterCoin) Read(reader io.Reader) *Coin {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterCoin) Lower(value *Coin) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Coin")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterCoin) Write(writer io.Writer, value *Coin) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerCoin struct {}

func (_ FfiDestroyerCoin) Destroy(value *Coin) {
		value.Destroy()
}



// A single command in a programmable transaction.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// command =  command-move-call
// =/ command-transfer-objects
// =/ command-split-coins
// =/ command-merge-coins
// =/ command-publish
// =/ command-make-move-vector
// =/ command-upgrade
//
// command-move-call           = %x00 move-call
// command-transfer-objects    = %x01 transfer-objects
// command-split-coins         = %x02 split-coins
// command-merge-coins         = %x03 merge-coins
// command-publish             = %x04 publish
// command-make-move-vector    = %x05 make-move-vector
// command-upgrade             = %x06 upgrade
// ```
type CommandInterface interface {
}
// A single command in a programmable transaction.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// command =  command-move-call
// =/ command-transfer-objects
// =/ command-split-coins
// =/ command-merge-coins
// =/ command-publish
// =/ command-make-move-vector
// =/ command-upgrade
//
// command-move-call           = %x00 move-call
// command-transfer-objects    = %x01 transfer-objects
// command-split-coins         = %x02 split-coins
// command-merge-coins         = %x03 merge-coins
// command-publish             = %x04 publish
// command-make-move-vector    = %x05 make-move-vector
// command-upgrade             = %x06 upgrade
// ```
type Command struct {
	ffiObject FfiObject
}


// Given n-values of the same type, it constructs a vector. For non objects
// or an empty vector, the type tag must be specified.
func CommandNewMakeMoveVector(makeMoveVector *MakeMoveVector) *Command {
	return FfiConverterCommandINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_command_new_make_move_vector(FfiConverterMakeMoveVectorINSTANCE.Lower(makeMoveVector),_uniffiStatus)
	}))
}

// It merges n-coins into the first coin
func CommandNewMergeCoins(mergeCoins *MergeCoins) *Command {
	return FfiConverterCommandINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_command_new_merge_coins(FfiConverterMergeCoinsINSTANCE.Lower(mergeCoins),_uniffiStatus)
	}))
}

// A call to either an entry or a public Move function
func CommandNewMoveCall(moveCall *MoveCall) *Command {
	return FfiConverterCommandINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_command_new_move_call(FfiConverterMoveCallINSTANCE.Lower(moveCall),_uniffiStatus)
	}))
}

// Publishes a Move package. It takes the package bytes and a list of the
// package's transitive dependencies to link against on-chain.
func CommandNewPublish(publish *Publish) *Command {
	return FfiConverterCommandINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_command_new_publish(FfiConverterPublishINSTANCE.Lower(publish),_uniffiStatus)
	}))
}

// It splits off some amounts into a new coins with those amounts
func CommandNewSplitCoins(splitCoins *SplitCoins) *Command {
	return FfiConverterCommandINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_command_new_split_coins(FfiConverterSplitCoinsINSTANCE.Lower(splitCoins),_uniffiStatus)
	}))
}

// It sends n-objects to the specified address. These objects must have
// store (public transfer) and either the previous owner must be an
// address or the object must be newly created.
func CommandNewTransferObjects(transferObjects *TransferObjects) *Command {
	return FfiConverterCommandINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_command_new_transfer_objects(FfiConverterTransferObjectsINSTANCE.Lower(transferObjects),_uniffiStatus)
	}))
}

// Upgrades a Move package
// Takes (in order):
// 1. A vector of serialized modules for the package.
// 2. A vector of object ids for the transitive dependencies of the new
// package.
// 3. The object ID of the package being upgraded.
// 4. An argument holding the `UpgradeTicket` that must have been produced
// from an earlier command in the same programmable transaction.
func CommandNewUpgrade(upgrade *Upgrade) *Command {
	return FfiConverterCommandINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_command_new_upgrade(FfiConverterUpgradeINSTANCE.Lower(upgrade),_uniffiStatus)
	}))
}


func (object *Command) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterCommand struct {}

var FfiConverterCommandINSTANCE = FfiConverterCommand{}


func (c FfiConverterCommand) Lift(pointer unsafe.Pointer) *Command {
	result := &Command {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_command(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_command(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Command).Destroy)
	return result
}

func (c FfiConverterCommand) Read(reader io.Reader) *Command {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterCommand) Lower(value *Command) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Command")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterCommand) Write(writer io.Writer, value *Command) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerCommand struct {}

func (_ FfiDestroyerCommand) Destroy(value *Command) {
		value.Destroy()
}



// V1 of the consensus commit prologue system transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// consensus-commit-prologue-v1 = u64 u64 (option u64) u64 digest
// consensus-determined-version-assignments
// ```
type ConsensusCommitPrologueV1Interface interface {
	// Unix timestamp from consensus
	CommitTimestampMs() uint64
	// Digest of consensus output
	ConsensusCommitDigest() *Digest
	// Stores consensus handler determined shared object version assignments.
	ConsensusDeterminedVersionAssignments() *ConsensusDeterminedVersionAssignments
	// Epoch of the commit prologue transaction
	Epoch() uint64
	// Consensus round of the commit
	Round() uint64
	// The sub DAG index of the consensus commit. This field will be populated
	// if there are multiple consensus commits per round.
	SubDagIndex() *uint64
}
// V1 of the consensus commit prologue system transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// consensus-commit-prologue-v1 = u64 u64 (option u64) u64 digest
// consensus-determined-version-assignments
// ```
type ConsensusCommitPrologueV1 struct {
	ffiObject FfiObject
}
func NewConsensusCommitPrologueV1(epoch uint64, round uint64, subDagIndex *uint64, commitTimestampMs uint64, consensusCommitDigest *Digest, consensusDeterminedVersionAssignments *ConsensusDeterminedVersionAssignments) *ConsensusCommitPrologueV1 {
	return FfiConverterConsensusCommitPrologueV1INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_consensuscommitprologuev1_new(FfiConverterUint64INSTANCE.Lower(epoch), FfiConverterUint64INSTANCE.Lower(round), FfiConverterOptionalUint64INSTANCE.Lower(subDagIndex), FfiConverterUint64INSTANCE.Lower(commitTimestampMs), FfiConverterDigestINSTANCE.Lower(consensusCommitDigest), FfiConverterConsensusDeterminedVersionAssignmentsINSTANCE.Lower(consensusDeterminedVersionAssignments),_uniffiStatus)
	}))
}




// Unix timestamp from consensus
func (_self *ConsensusCommitPrologueV1) CommitTimestampMs() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ConsensusCommitPrologueV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_commit_timestamp_ms(
		_pointer,_uniffiStatus)
	}))
}

// Digest of consensus output
func (_self *ConsensusCommitPrologueV1) ConsensusCommitDigest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*ConsensusCommitPrologueV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_consensus_commit_digest(
		_pointer,_uniffiStatus)
	}))
}

// Stores consensus handler determined shared object version assignments.
func (_self *ConsensusCommitPrologueV1) ConsensusDeterminedVersionAssignments() *ConsensusDeterminedVersionAssignments {
	_pointer := _self.ffiObject.incrementPointer("*ConsensusCommitPrologueV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterConsensusDeterminedVersionAssignmentsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_consensus_determined_version_assignments(
		_pointer,_uniffiStatus)
	}))
}

// Epoch of the commit prologue transaction
func (_self *ConsensusCommitPrologueV1) Epoch() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ConsensusCommitPrologueV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_epoch(
		_pointer,_uniffiStatus)
	}))
}

// Consensus round of the commit
func (_self *ConsensusCommitPrologueV1) Round() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ConsensusCommitPrologueV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_round(
		_pointer,_uniffiStatus)
	}))
}

// The sub DAG index of the consensus commit. This field will be populated
// if there are multiple consensus commits per round.
func (_self *ConsensusCommitPrologueV1) SubDagIndex() *uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ConsensusCommitPrologueV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_sub_dag_index(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *ConsensusCommitPrologueV1) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterConsensusCommitPrologueV1 struct {}

var FfiConverterConsensusCommitPrologueV1INSTANCE = FfiConverterConsensusCommitPrologueV1{}


func (c FfiConverterConsensusCommitPrologueV1) Lift(pointer unsafe.Pointer) *ConsensusCommitPrologueV1 {
	result := &ConsensusCommitPrologueV1 {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_consensuscommitprologuev1(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_consensuscommitprologuev1(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ConsensusCommitPrologueV1).Destroy)
	return result
}

func (c FfiConverterConsensusCommitPrologueV1) Read(reader io.Reader) *ConsensusCommitPrologueV1 {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterConsensusCommitPrologueV1) Lower(value *ConsensusCommitPrologueV1) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ConsensusCommitPrologueV1")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterConsensusCommitPrologueV1) Write(writer io.Writer, value *ConsensusCommitPrologueV1) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerConsensusCommitPrologueV1 struct {}

func (_ FfiDestroyerConsensusCommitPrologueV1) Destroy(value *ConsensusCommitPrologueV1) {
		value.Destroy()
}



type ConsensusDeterminedVersionAssignmentsInterface interface {
	AsCancelledTransactions() []*CancelledTransaction
	IsCancelledTransactions() bool
}
type ConsensusDeterminedVersionAssignments struct {
	ffiObject FfiObject
}


func ConsensusDeterminedVersionAssignmentsNewCancelledTransactions(cancelledTransactions []*CancelledTransaction) *ConsensusDeterminedVersionAssignments {
	return FfiConverterConsensusDeterminedVersionAssignmentsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_consensusdeterminedversionassignments_new_cancelled_transactions(FfiConverterSequenceCancelledTransactionINSTANCE.Lower(cancelledTransactions),_uniffiStatus)
	}))
}



func (_self *ConsensusDeterminedVersionAssignments) AsCancelledTransactions() []*CancelledTransaction {
	_pointer := _self.ffiObject.incrementPointer("*ConsensusDeterminedVersionAssignments")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceCancelledTransactionINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_consensusdeterminedversionassignments_as_cancelled_transactions(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ConsensusDeterminedVersionAssignments) IsCancelledTransactions() bool {
	_pointer := _self.ffiObject.incrementPointer("*ConsensusDeterminedVersionAssignments")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_consensusdeterminedversionassignments_is_cancelled_transactions(
		_pointer,_uniffiStatus)
	}))
}
func (object *ConsensusDeterminedVersionAssignments) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterConsensusDeterminedVersionAssignments struct {}

var FfiConverterConsensusDeterminedVersionAssignmentsINSTANCE = FfiConverterConsensusDeterminedVersionAssignments{}


func (c FfiConverterConsensusDeterminedVersionAssignments) Lift(pointer unsafe.Pointer) *ConsensusDeterminedVersionAssignments {
	result := &ConsensusDeterminedVersionAssignments {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_consensusdeterminedversionassignments(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_consensusdeterminedversionassignments(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ConsensusDeterminedVersionAssignments).Destroy)
	return result
}

func (c FfiConverterConsensusDeterminedVersionAssignments) Read(reader io.Reader) *ConsensusDeterminedVersionAssignments {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterConsensusDeterminedVersionAssignments) Lower(value *ConsensusDeterminedVersionAssignments) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ConsensusDeterminedVersionAssignments")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterConsensusDeterminedVersionAssignments) Write(writer io.Writer, value *ConsensusDeterminedVersionAssignments) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerConsensusDeterminedVersionAssignments struct {}

func (_ FfiDestroyerConsensusDeterminedVersionAssignments) Destroy(value *ConsensusDeterminedVersionAssignments) {
		value.Destroy()
}



// A 32-byte Blake2b256 hash output.
//
// # BCS
//
// A `Digest`'s BCS serialized form is defined by the following:
//
// ```text
// digest = %x20 32OCTET
// ```
//
// Due to historical reasons, even though a `Digest` has a fixed-length of 32,
// IOTA's binary representation of a `Digest` is prefixed with its length
// meaning its serialized binary form (in bcs) is 33 bytes long vs a more
// compact 32 bytes.
type DigestInterface interface {
	ToBase58() string
	ToBytes() []byte
}
// A 32-byte Blake2b256 hash output.
//
// # BCS
//
// A `Digest`'s BCS serialized form is defined by the following:
//
// ```text
// digest = %x20 32OCTET
// ```
//
// Due to historical reasons, even though a `Digest` has a fixed-length of 32,
// IOTA's binary representation of a `Digest` is prefixed with its length
// meaning its serialized binary form (in bcs) is 33 bytes long vs a more
// compact 32 bytes.
type Digest struct {
	ffiObject FfiObject
}


func DigestFromBase58(base58 string) (*Digest, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_digest_from_base58(FfiConverterStringINSTANCE.Lower(base58),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Digest
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterDigestINSTANCE.Lift(_uniffiRV), nil
		}
}

func DigestFromBytes(bytes []byte) (*Digest, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_digest_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Digest
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterDigestINSTANCE.Lift(_uniffiRV), nil
		}
}

func DigestGenerate() *Digest {
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_digest_generate(_uniffiStatus)
	}))
}



func (_self *Digest) ToBase58() string {
	_pointer := _self.ffiObject.incrementPointer("*Digest")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_digest_to_base58(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Digest) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Digest")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_digest_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Digest) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterDigest struct {}

var FfiConverterDigestINSTANCE = FfiConverterDigest{}


func (c FfiConverterDigest) Lift(pointer unsafe.Pointer) *Digest {
	result := &Digest {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_digest(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_digest(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Digest).Destroy)
	return result
}

func (c FfiConverterDigest) Read(reader io.Reader) *Digest {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterDigest) Lower(value *Digest) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Digest")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterDigest) Write(writer io.Writer, value *Digest) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerDigest struct {}

func (_ FfiDestroyerDigest) Destroy(value *Digest) {
		value.Destroy()
}



type Ed25519PrivateKeyInterface interface {
	PublicKey() *Ed25519PublicKey
	Scheme() SignatureScheme
	// Sign a personal message and return a UserSignature.
	SignPersonalMessage(message *PersonalMessage) (*UserSignature, error)
	// Sign a transaction and return a UserSignature.
	SignTransaction(transaction *Transaction) (*UserSignature, error)
	// Encode this private key as `flag || privkey` in Bech32 starting with
	// "iotaprivkey" to a string.
	ToBech32() (string, error)
	// Serialize this private key to bytes.
	ToBytes() []byte
	// Serialize this private key as DER-encoded PKCS#8
	ToDer() ([]byte, error)
	// Serialize this private key as PEM-encoded PKCS#8
	ToPem() (string, error)
	TrySign(message []byte) (*Ed25519Signature, error)
	TrySignSimple(message []byte) (*SimpleSignature, error)
	TrySignUser(message []byte) (*UserSignature, error)
	VerifyingKey() *Ed25519VerifyingKey
}
type Ed25519PrivateKey struct {
	ffiObject FfiObject
}
func NewEd25519PrivateKey(bytes []byte) (*Ed25519PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_new(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}


// Decode a private key from `flag || privkey` in Bech32 starting with
// "iotaprivkey".
func Ed25519PrivateKeyFromBech32(value string) (*Ed25519PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_bech32(FfiConverterStringINSTANCE.Lower(value),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
// format).
func Ed25519PrivateKeyFromDer(bytes []byte) (*Ed25519PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_der(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Construct the private key from a mnemonic phrase
func Ed25519PrivateKeyFromMnemonic(phrase string, accountIndex uint64, password string) (*Ed25519PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_mnemonic(FfiConverterStringINSTANCE.Lower(phrase), FfiConverterUint64INSTANCE.Lower(accountIndex), FfiConverterStringINSTANCE.Lower(password),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create an instance from a mnemonic phrase and a derivation path like
// `"m/44'/4218'/0'/0'/0'"`
func Ed25519PrivateKeyFromMnemonicWithPath(phrase string, path string, password string) (*Ed25519PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_mnemonic_with_path(FfiConverterStringINSTANCE.Lower(phrase), FfiConverterStringINSTANCE.Lower(path), FfiConverterStringINSTANCE.Lower(password),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize PKCS#8-encoded private key from PEM.
func Ed25519PrivateKeyFromPem(s string) (*Ed25519PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_pem(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Ed25519PrivateKeyGenerate() *Ed25519PrivateKey {
	return FfiConverterEd25519PrivateKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_generate(_uniffiStatus)
	}))
}



func (_self *Ed25519PrivateKey) PublicKey() *Ed25519PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterEd25519PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_public_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Ed25519PrivateKey) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

// Sign a personal message and return a UserSignature.
func (_self *Ed25519PrivateKey) SignPersonalMessage(message *PersonalMessage) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_sign_personal_message(
		_pointer,FfiConverterPersonalMessageINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Sign a transaction and return a UserSignature.
func (_self *Ed25519PrivateKey) SignTransaction(transaction *Transaction) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_sign_transaction(
		_pointer,FfiConverterTransactionINSTANCE.Lower(transaction),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Encode this private key as `flag || privkey` in Bech32 starting with
// "iotaprivkey" to a string.
func (_self *Ed25519PrivateKey) ToBech32() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_bech32(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this private key to bytes.
func (_self *Ed25519PrivateKey) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

// Serialize this private key as DER-encoded PKCS#8
func (_self *Ed25519PrivateKey) ToDer() ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_der(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this private key as PEM-encoded PKCS#8
func (_self *Ed25519PrivateKey) ToPem() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_pem(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Ed25519PrivateKey) TrySign(message []byte) (*Ed25519Signature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Ed25519PrivateKey) TrySignSimple(message []byte) (*SimpleSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign_simple(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Ed25519PrivateKey) TrySignUser(message []byte) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign_user(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Ed25519PrivateKey) VerifyingKey() *Ed25519VerifyingKey {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterEd25519VerifyingKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_verifying_key(
		_pointer,_uniffiStatus)
	}))
}
func (object *Ed25519PrivateKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterEd25519PrivateKey struct {}

var FfiConverterEd25519PrivateKeyINSTANCE = FfiConverterEd25519PrivateKey{}


func (c FfiConverterEd25519PrivateKey) Lift(pointer unsafe.Pointer) *Ed25519PrivateKey {
	result := &Ed25519PrivateKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_ed25519privatekey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_ed25519privatekey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Ed25519PrivateKey).Destroy)
	return result
}

func (c FfiConverterEd25519PrivateKey) Read(reader io.Reader) *Ed25519PrivateKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterEd25519PrivateKey) Lower(value *Ed25519PrivateKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Ed25519PrivateKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterEd25519PrivateKey) Write(writer io.Writer, value *Ed25519PrivateKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerEd25519PrivateKey struct {}

func (_ FfiDestroyerEd25519PrivateKey) Destroy(value *Ed25519PrivateKey) {
		value.Destroy()
}



// An ed25519 public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// ed25519-public-key = 32OCTECT
// ```
type Ed25519PublicKeyInterface interface {
	// Derive an `Address` from this Public Key
	//
	// An `Address` can be derived from an `Ed25519PublicKey` by hashing the
	// bytes of the public key with no prefix flag.
	//
	// `hash(32-byte ed25519 public key)`
	DeriveAddress() *Address
	// Returns the signature scheme for this public key.
	Scheme() SignatureScheme
	ToBytes() []byte
	// Returns the bytes with signature scheme flag prepended.
	ToFlaggedBytes() []byte
}
// An ed25519 public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// ed25519-public-key = 32OCTECT
// ```
type Ed25519PublicKey struct {
	ffiObject FfiObject
}


func Ed25519PublicKeyFromBytes(bytes []byte) (*Ed25519PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Ed25519PublicKeyFromStr(s string) (*Ed25519PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Ed25519PublicKeyGenerate() *Ed25519PublicKey {
	return FfiConverterEd25519PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_generate(_uniffiStatus)
	}))
}



// Derive an `Address` from this Public Key
//
// An `Address` can be derived from an `Ed25519PublicKey` by hashing the
// bytes of the public key with no prefix flag.
//
// `hash(32-byte ed25519 public key)`
func (_self *Ed25519PublicKey) DeriveAddress() *Address {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_derive_address(
		_pointer,_uniffiStatus)
	}))
}

// Returns the signature scheme for this public key.
func (_self *Ed25519PublicKey) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Ed25519PublicKey) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

// Returns the bytes with signature scheme flag prepended.
func (_self *Ed25519PublicKey) ToFlaggedBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_to_flagged_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Ed25519PublicKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterEd25519PublicKey struct {}

var FfiConverterEd25519PublicKeyINSTANCE = FfiConverterEd25519PublicKey{}


func (c FfiConverterEd25519PublicKey) Lift(pointer unsafe.Pointer) *Ed25519PublicKey {
	result := &Ed25519PublicKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_ed25519publickey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_ed25519publickey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Ed25519PublicKey).Destroy)
	return result
}

func (c FfiConverterEd25519PublicKey) Read(reader io.Reader) *Ed25519PublicKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterEd25519PublicKey) Lower(value *Ed25519PublicKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Ed25519PublicKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterEd25519PublicKey) Write(writer io.Writer, value *Ed25519PublicKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerEd25519PublicKey struct {}

func (_ FfiDestroyerEd25519PublicKey) Destroy(value *Ed25519PublicKey) {
		value.Destroy()
}



// An ed25519 signature.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// ed25519-signature = 64OCTECT
// ```
type Ed25519SignatureInterface interface {
	ToBytes() []byte
}
// An ed25519 signature.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// ed25519-signature = 64OCTECT
// ```
type Ed25519Signature struct {
	ffiObject FfiObject
}


func Ed25519SignatureFromBytes(bytes []byte) (*Ed25519Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func Ed25519SignatureFromStr(s string) (*Ed25519Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func Ed25519SignatureGenerate() *Ed25519Signature {
	return FfiConverterEd25519SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_generate(_uniffiStatus)
	}))
}



func (_self *Ed25519Signature) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519Signature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519signature_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Ed25519Signature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterEd25519Signature struct {}

var FfiConverterEd25519SignatureINSTANCE = FfiConverterEd25519Signature{}


func (c FfiConverterEd25519Signature) Lift(pointer unsafe.Pointer) *Ed25519Signature {
	result := &Ed25519Signature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_ed25519signature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_ed25519signature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Ed25519Signature).Destroy)
	return result
}

func (c FfiConverterEd25519Signature) Read(reader io.Reader) *Ed25519Signature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterEd25519Signature) Lower(value *Ed25519Signature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Ed25519Signature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterEd25519Signature) Write(writer io.Writer, value *Ed25519Signature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerEd25519Signature struct {}

func (_ FfiDestroyerEd25519Signature) Destroy(value *Ed25519Signature) {
		value.Destroy()
}



type Ed25519VerifierInterface interface {
}
type Ed25519Verifier struct {
	ffiObject FfiObject
}



func (object *Ed25519Verifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterEd25519Verifier struct {}

var FfiConverterEd25519VerifierINSTANCE = FfiConverterEd25519Verifier{}


func (c FfiConverterEd25519Verifier) Lift(pointer unsafe.Pointer) *Ed25519Verifier {
	result := &Ed25519Verifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_ed25519verifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_ed25519verifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Ed25519Verifier).Destroy)
	return result
}

func (c FfiConverterEd25519Verifier) Read(reader io.Reader) *Ed25519Verifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterEd25519Verifier) Lower(value *Ed25519Verifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Ed25519Verifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterEd25519Verifier) Write(writer io.Writer, value *Ed25519Verifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerEd25519Verifier struct {}

func (_ FfiDestroyerEd25519Verifier) Destroy(value *Ed25519Verifier) {
		value.Destroy()
}



type Ed25519VerifyingKeyInterface interface {
	PublicKey() *Ed25519PublicKey
	// Serialize this public key as DER-encoded data
	ToDer() ([]byte, error)
	// Serialize this public key into PEM format
	ToPem() (string, error)
	Verify(message []byte, signature *Ed25519Signature) error
	VerifySimple(message []byte, signature *SimpleSignature) error
	VerifyUser(message []byte, signature *UserSignature) error
}
type Ed25519VerifyingKey struct {
	ffiObject FfiObject
}
func NewEd25519VerifyingKey(publicKey *Ed25519PublicKey) (*Ed25519VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_new(FfiConverterEd25519PublicKeyINSTANCE.Lower(publicKey),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}


// Deserialize public key from ASN.1 DER-encoded data (binary format).
func Ed25519VerifyingKeyFromDer(bytes []byte) (*Ed25519VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_from_der(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize public key from PEM.
func Ed25519VerifyingKeyFromPem(s string) (*Ed25519VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_from_pem(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}



func (_self *Ed25519VerifyingKey) PublicKey() *Ed25519PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterEd25519PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_public_key(
		_pointer,_uniffiStatus)
	}))
}

// Serialize this public key as DER-encoded data
func (_self *Ed25519VerifyingKey) ToDer() ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_to_der(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this public key into PEM format
func (_self *Ed25519VerifyingKey) ToPem() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_to_pem(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Ed25519VerifyingKey) Verify(message []byte, signature *Ed25519Signature) error {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterEd25519SignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *Ed25519VerifyingKey) VerifySimple(message []byte, signature *SimpleSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify_simple(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterSimpleSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *Ed25519VerifyingKey) VerifyUser(message []byte, signature *UserSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Ed25519VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify_user(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterUserSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *Ed25519VerifyingKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterEd25519VerifyingKey struct {}

var FfiConverterEd25519VerifyingKeyINSTANCE = FfiConverterEd25519VerifyingKey{}


func (c FfiConverterEd25519VerifyingKey) Lift(pointer unsafe.Pointer) *Ed25519VerifyingKey {
	result := &Ed25519VerifyingKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_ed25519verifyingkey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_ed25519verifyingkey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Ed25519VerifyingKey).Destroy)
	return result
}

func (c FfiConverterEd25519VerifyingKey) Read(reader io.Reader) *Ed25519VerifyingKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterEd25519VerifyingKey) Lower(value *Ed25519VerifyingKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Ed25519VerifyingKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterEd25519VerifyingKey) Write(writer io.Writer, value *Ed25519VerifyingKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerEd25519VerifyingKey struct {}

func (_ FfiDestroyerEd25519VerifyingKey) Destroy(value *Ed25519VerifyingKey) {
		value.Destroy()
}



// Operation run at the end of an epoch
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// end-of-epoch-transaction-kind   =  eoe-change-epoch
// =/ eoe-authenticator-state-create
// =/ eoe-authenticator-state-expire
// =/ eoe-randomness-state-create
// =/ eoe-deny-list-state-create
// =/ eoe-bridge-state-create
// =/ eoe-bridge-committee-init
// =/ eoe-store-execution-time-observations
//
// eoe-change-epoch                = %x00 change-epoch
// eoe-authenticator-state-create  = %x01
// eoe-authenticator-state-expire  = %x02 authenticator-state-expire
// eoe-randomness-state-create     = %x03
// eoe-deny-list-state-create      = %x04
// eoe-bridge-state-create         = %x05 digest
// eoe-bridge-committee-init       = %x06 u64
// eoe-store-execution-time-observations = %x07 stored-execution-time-observations
// ```
type EndOfEpochTransactionKindInterface interface {
}
// Operation run at the end of an epoch
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// end-of-epoch-transaction-kind   =  eoe-change-epoch
// =/ eoe-authenticator-state-create
// =/ eoe-authenticator-state-expire
// =/ eoe-randomness-state-create
// =/ eoe-deny-list-state-create
// =/ eoe-bridge-state-create
// =/ eoe-bridge-committee-init
// =/ eoe-store-execution-time-observations
//
// eoe-change-epoch                = %x00 change-epoch
// eoe-authenticator-state-create  = %x01
// eoe-authenticator-state-expire  = %x02 authenticator-state-expire
// eoe-randomness-state-create     = %x03
// eoe-deny-list-state-create      = %x04
// eoe-bridge-state-create         = %x05 digest
// eoe-bridge-committee-init       = %x06 u64
// eoe-store-execution-time-observations = %x07 stored-execution-time-observations
// ```
type EndOfEpochTransactionKind struct {
	ffiObject FfiObject
}


func EndOfEpochTransactionKindNewAuthenticatorStateCreate() *EndOfEpochTransactionKind {
	return FfiConverterEndOfEpochTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_authenticator_state_create(_uniffiStatus)
	}))
}

func EndOfEpochTransactionKindNewAuthenticatorStateExpire(tx AuthenticatorStateExpire) *EndOfEpochTransactionKind {
	return FfiConverterEndOfEpochTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_authenticator_state_expire(FfiConverterAuthenticatorStateExpireINSTANCE.Lower(tx),_uniffiStatus)
	}))
}

func EndOfEpochTransactionKindNewChangeEpoch(tx *ChangeEpoch) *EndOfEpochTransactionKind {
	return FfiConverterEndOfEpochTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch(FfiConverterChangeEpochINSTANCE.Lower(tx),_uniffiStatus)
	}))
}

func EndOfEpochTransactionKindNewChangeEpochV2(tx *ChangeEpochV2) *EndOfEpochTransactionKind {
	return FfiConverterEndOfEpochTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch_v2(FfiConverterChangeEpochV2INSTANCE.Lower(tx),_uniffiStatus)
	}))
}

func EndOfEpochTransactionKindNewChangeEpochV3(tx *ChangeEpochV3) *EndOfEpochTransactionKind {
	return FfiConverterEndOfEpochTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch_v3(FfiConverterChangeEpochV3INSTANCE.Lower(tx),_uniffiStatus)
	}))
}


func (object *EndOfEpochTransactionKind) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterEndOfEpochTransactionKind struct {}

var FfiConverterEndOfEpochTransactionKindINSTANCE = FfiConverterEndOfEpochTransactionKind{}


func (c FfiConverterEndOfEpochTransactionKind) Lift(pointer unsafe.Pointer) *EndOfEpochTransactionKind {
	result := &EndOfEpochTransactionKind {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_endofepochtransactionkind(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_endofepochtransactionkind(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*EndOfEpochTransactionKind).Destroy)
	return result
}

func (c FfiConverterEndOfEpochTransactionKind) Read(reader io.Reader) *EndOfEpochTransactionKind {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterEndOfEpochTransactionKind) Lower(value *EndOfEpochTransactionKind) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*EndOfEpochTransactionKind")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterEndOfEpochTransactionKind) Write(writer io.Writer, value *EndOfEpochTransactionKind) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerEndOfEpochTransactionKind struct {}

func (_ FfiDestroyerEndOfEpochTransactionKind) Destroy(value *EndOfEpochTransactionKind) {
		value.Destroy()
}



type ExecutionTimeObservationInterface interface {
	Key() *ExecutionTimeObservationKey
	Observations() []*ValidatorExecutionTimeObservation
}
type ExecutionTimeObservation struct {
	ffiObject FfiObject
}
func NewExecutionTimeObservation(key *ExecutionTimeObservationKey, observations []*ValidatorExecutionTimeObservation) *ExecutionTimeObservation {
	return FfiConverterExecutionTimeObservationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservation_new(FfiConverterExecutionTimeObservationKeyINSTANCE.Lower(key), FfiConverterSequenceValidatorExecutionTimeObservationINSTANCE.Lower(observations),_uniffiStatus)
	}))
}




func (_self *ExecutionTimeObservation) Key() *ExecutionTimeObservationKey {
	_pointer := _self.ffiObject.incrementPointer("*ExecutionTimeObservation")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterExecutionTimeObservationKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_executiontimeobservation_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ExecutionTimeObservation) Observations() []*ValidatorExecutionTimeObservation {
	_pointer := _self.ffiObject.incrementPointer("*ExecutionTimeObservation")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceValidatorExecutionTimeObservationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_executiontimeobservation_observations(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *ExecutionTimeObservation) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterExecutionTimeObservation struct {}

var FfiConverterExecutionTimeObservationINSTANCE = FfiConverterExecutionTimeObservation{}


func (c FfiConverterExecutionTimeObservation) Lift(pointer unsafe.Pointer) *ExecutionTimeObservation {
	result := &ExecutionTimeObservation {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservation(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_executiontimeobservation(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ExecutionTimeObservation).Destroy)
	return result
}

func (c FfiConverterExecutionTimeObservation) Read(reader io.Reader) *ExecutionTimeObservation {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterExecutionTimeObservation) Lower(value *ExecutionTimeObservation) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ExecutionTimeObservation")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterExecutionTimeObservation) Write(writer io.Writer, value *ExecutionTimeObservation) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerExecutionTimeObservation struct {}

func (_ FfiDestroyerExecutionTimeObservation) Destroy(value *ExecutionTimeObservation) {
		value.Destroy()
}



// Key for an execution time observation
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// execution-time-observation-key  =  %x00 move-entry-point
// =/ %x01 ; transfer-objects
// =/ %x02 ; split-coins
// =/ %x03 ; merge-coins
// =/ %x04 ; publish
// =/ %x05 ; make-move-vec
// =/ %x06 ; upgrade
//
// move-entry-point = object-id string string (vec type-tag)
// ```
type ExecutionTimeObservationKeyInterface interface {
}
// Key for an execution time observation
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// execution-time-observation-key  =  %x00 move-entry-point
// =/ %x01 ; transfer-objects
// =/ %x02 ; split-coins
// =/ %x03 ; merge-coins
// =/ %x04 ; publish
// =/ %x05 ; make-move-vec
// =/ %x06 ; upgrade
//
// move-entry-point = object-id string string (vec type-tag)
// ```
type ExecutionTimeObservationKey struct {
	ffiObject FfiObject
}


func ExecutionTimeObservationKeyNewMakeMoveVec() *ExecutionTimeObservationKey {
	return FfiConverterExecutionTimeObservationKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_make_move_vec(_uniffiStatus)
	}))
}

func ExecutionTimeObservationKeyNewMergeCoins() *ExecutionTimeObservationKey {
	return FfiConverterExecutionTimeObservationKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_merge_coins(_uniffiStatus)
	}))
}

func ExecutionTimeObservationKeyNewMoveEntryPoint(varPackage *ObjectId, module string, function string, typeArguments []*TypeTag) *ExecutionTimeObservationKey {
	return FfiConverterExecutionTimeObservationKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_move_entry_point(FfiConverterObjectIdINSTANCE.Lower(varPackage), FfiConverterStringINSTANCE.Lower(module), FfiConverterStringINSTANCE.Lower(function), FfiConverterSequenceTypeTagINSTANCE.Lower(typeArguments),_uniffiStatus)
	}))
}

func ExecutionTimeObservationKeyNewPublish() *ExecutionTimeObservationKey {
	return FfiConverterExecutionTimeObservationKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_publish(_uniffiStatus)
	}))
}

func ExecutionTimeObservationKeyNewSplitCoins() *ExecutionTimeObservationKey {
	return FfiConverterExecutionTimeObservationKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_split_coins(_uniffiStatus)
	}))
}

func ExecutionTimeObservationKeyNewTransferObjects() *ExecutionTimeObservationKey {
	return FfiConverterExecutionTimeObservationKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_transfer_objects(_uniffiStatus)
	}))
}

func ExecutionTimeObservationKeyNewUpgrade() *ExecutionTimeObservationKey {
	return FfiConverterExecutionTimeObservationKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_upgrade(_uniffiStatus)
	}))
}


func (object *ExecutionTimeObservationKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterExecutionTimeObservationKey struct {}

var FfiConverterExecutionTimeObservationKeyINSTANCE = FfiConverterExecutionTimeObservationKey{}


func (c FfiConverterExecutionTimeObservationKey) Lift(pointer unsafe.Pointer) *ExecutionTimeObservationKey {
	result := &ExecutionTimeObservationKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservationkey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_executiontimeobservationkey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ExecutionTimeObservationKey).Destroy)
	return result
}

func (c FfiConverterExecutionTimeObservationKey) Read(reader io.Reader) *ExecutionTimeObservationKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterExecutionTimeObservationKey) Lower(value *ExecutionTimeObservationKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ExecutionTimeObservationKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterExecutionTimeObservationKey) Write(writer io.Writer, value *ExecutionTimeObservationKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerExecutionTimeObservationKey struct {}

func (_ FfiDestroyerExecutionTimeObservationKey) Destroy(value *ExecutionTimeObservationKey) {
		value.Destroy()
}



// Set of Execution Time Observations from the committee.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// stored-execution-time-observations =  %x00 v1-stored-execution-time-observations
//
// v1-stored-execution-time-observations = (vec
// execution-time-observation-key
// (vec execution-time-observation)
// )
// ```
type ExecutionTimeObservationsInterface interface {
}
// Set of Execution Time Observations from the committee.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// stored-execution-time-observations =  %x00 v1-stored-execution-time-observations
//
// v1-stored-execution-time-observations = (vec
// execution-time-observation-key
// (vec execution-time-observation)
// )
// ```
type ExecutionTimeObservations struct {
	ffiObject FfiObject
}


func ExecutionTimeObservationsNewV1(executionTimeObservations []*ExecutionTimeObservation) *ExecutionTimeObservations {
	return FfiConverterExecutionTimeObservationsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservations_new_v1(FfiConverterSequenceExecutionTimeObservationINSTANCE.Lower(executionTimeObservations),_uniffiStatus)
	}))
}


func (object *ExecutionTimeObservations) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterExecutionTimeObservations struct {}

var FfiConverterExecutionTimeObservationsINSTANCE = FfiConverterExecutionTimeObservations{}


func (c FfiConverterExecutionTimeObservations) Lift(pointer unsafe.Pointer) *ExecutionTimeObservations {
	result := &ExecutionTimeObservations {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservations(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_executiontimeobservations(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ExecutionTimeObservations).Destroy)
	return result
}

func (c FfiConverterExecutionTimeObservations) Read(reader io.Reader) *ExecutionTimeObservations {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterExecutionTimeObservations) Lower(value *ExecutionTimeObservations) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ExecutionTimeObservations")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterExecutionTimeObservations) Write(writer io.Writer, value *ExecutionTimeObservations) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerExecutionTimeObservations struct {}

func (_ FfiDestroyerExecutionTimeObservations) Destroy(value *ExecutionTimeObservations) {
		value.Destroy()
}



type FaucetClientInterface interface {
	// Request gas from the faucet. Note that this will return the UUID of the
	// request and not wait until the token is received. Use
	// `request_and_wait` to wait for the token.
	Request(address *Address) (*string, error)
	// Request gas from the faucet and wait until the request is completed and
	// token is transferred. Returns `FaucetReceipt` if the request is
	// successful, which contains the list of tokens transferred, and the
	// transaction digest.
	//
	// Note that the faucet is heavily rate-limited, so calling repeatedly the
	// faucet would likely result in a 429 code or 502 code.
	RequestAndWait(address *Address) (*FaucetReceipt, error)
	// Check the faucet request status.
	//
	// Possible statuses are defined in: `BatchSendStatusType`
	RequestStatus(id string) (*BatchSendStatus, error)
}
type FaucetClient struct {
	ffiObject FfiObject
}
// Construct a new `FaucetClient` with the given faucet service URL. This
// `FaucetClient` expects that the service provides two endpoints:
// /v1/gas and /v1/status. As such, do not provide the request
// endpoint, just the top level service endpoint.
//
// - /v1/gas is used to request gas
// - /v1/status/taks-uuid is used to check the status of the request
func NewFaucetClient(faucetUrl string) *FaucetClient {
	return FfiConverterFaucetClientINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new(FfiConverterStringINSTANCE.Lower(faucetUrl),_uniffiStatus)
	}))
}


// Create a new Faucet client connected to the `devnet` faucet.
func FaucetClientNewDevnet() *FaucetClient {
	return FfiConverterFaucetClientINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_devnet(_uniffiStatus)
	}))
}

// Create a new Faucet client connected to a `localnet` faucet.
func FaucetClientNewLocalnet() *FaucetClient {
	return FfiConverterFaucetClientINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_localnet(_uniffiStatus)
	}))
}

// Create a new Faucet client connected to the `testnet` faucet.
func FaucetClientNewTestnet() *FaucetClient {
	return FfiConverterFaucetClientINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_testnet(_uniffiStatus)
	}))
}



// Request gas from the faucet. Note that this will return the UUID of the
// request and not wait until the token is received. Use
// `request_and_wait` to wait for the token.
func (_self *FaucetClient) Request(address *Address) (*string, error) {
	_pointer := _self.ffiObject.incrementPointer("*FaucetClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_faucetclient_request(
		_pointer,FfiConverterAddressINSTANCE.Lower(address)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Request gas from the faucet and wait until the request is completed and
// token is transferred. Returns `FaucetReceipt` if the request is
// successful, which contains the list of tokens transferred, and the
// transaction digest.
//
// Note that the faucet is heavily rate-limited, so calling repeatedly the
// faucet would likely result in a 429 code or 502 code.
func (_self *FaucetClient) RequestAndWait(address *Address) (*FaucetReceipt, error) {
	_pointer := _self.ffiObject.incrementPointer("*FaucetClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *FaucetReceipt {
			return FfiConverterOptionalFaucetReceiptINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_faucetclient_request_and_wait(
		_pointer,FfiConverterAddressINSTANCE.Lower(address)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Check the faucet request status.
//
// Possible statuses are defined in: `BatchSendStatusType`
func (_self *FaucetClient) RequestStatus(id string) (*BatchSendStatus, error) {
	_pointer := _self.ffiObject.incrementPointer("*FaucetClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *BatchSendStatus {
			return FfiConverterOptionalBatchSendStatusINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_faucetclient_request_status(
		_pointer,FfiConverterStringINSTANCE.Lower(id)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}
func (object *FaucetClient) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterFaucetClient struct {}

var FfiConverterFaucetClientINSTANCE = FfiConverterFaucetClient{}


func (c FfiConverterFaucetClient) Lift(pointer unsafe.Pointer) *FaucetClient {
	result := &FaucetClient {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_faucetclient(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_faucetclient(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*FaucetClient).Destroy)
	return result
}

func (c FfiConverterFaucetClient) Read(reader io.Reader) *FaucetClient {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterFaucetClient) Lower(value *FaucetClient) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*FaucetClient")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterFaucetClient) Write(writer io.Writer, value *FaucetClient) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerFaucetClient struct {}

func (_ FfiDestroyerFaucetClient) Destroy(value *FaucetClient) {
		value.Destroy()
}



// An object part of the initial chain state
//
// `GenesisObject`'s are included as a part of genesis, the initial
// checkpoint/transaction, that initializes the state of the blockchain.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// genesis-object = object-data owner
// ```
type GenesisObjectInterface interface {
	Data() *ObjectData
	ObjectId() *ObjectId
	ObjectType() *ObjectType
	Owner() *Owner
	Version() uint64
}
// An object part of the initial chain state
//
// `GenesisObject`'s are included as a part of genesis, the initial
// checkpoint/transaction, that initializes the state of the blockchain.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// genesis-object = object-data owner
// ```
type GenesisObject struct {
	ffiObject FfiObject
}
func NewGenesisObject(data *ObjectData, owner *Owner) *GenesisObject {
	return FfiConverterGenesisObjectINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_genesisobject_new(FfiConverterObjectDataINSTANCE.Lower(data), FfiConverterOwnerINSTANCE.Lower(owner),_uniffiStatus)
	}))
}




func (_self *GenesisObject) Data() *ObjectData {
	_pointer := _self.ffiObject.incrementPointer("*GenesisObject")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectDataINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_genesisobject_data(
		_pointer,_uniffiStatus)
	}))
}

func (_self *GenesisObject) ObjectId() *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*GenesisObject")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_genesisobject_object_id(
		_pointer,_uniffiStatus)
	}))
}

func (_self *GenesisObject) ObjectType() *ObjectType {
	_pointer := _self.ffiObject.incrementPointer("*GenesisObject")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectTypeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_genesisobject_object_type(
		_pointer,_uniffiStatus)
	}))
}

func (_self *GenesisObject) Owner() *Owner {
	_pointer := _self.ffiObject.incrementPointer("*GenesisObject")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOwnerINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_genesisobject_owner(
		_pointer,_uniffiStatus)
	}))
}

func (_self *GenesisObject) Version() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*GenesisObject")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_genesisobject_version(
		_pointer,_uniffiStatus)
	}))
}
func (object *GenesisObject) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterGenesisObject struct {}

var FfiConverterGenesisObjectINSTANCE = FfiConverterGenesisObject{}


func (c FfiConverterGenesisObject) Lift(pointer unsafe.Pointer) *GenesisObject {
	result := &GenesisObject {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_genesisobject(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_genesisobject(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*GenesisObject).Destroy)
	return result
}

func (c FfiConverterGenesisObject) Read(reader io.Reader) *GenesisObject {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterGenesisObject) Lower(value *GenesisObject) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*GenesisObject")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterGenesisObject) Write(writer io.Writer, value *GenesisObject) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerGenesisObject struct {}

func (_ FfiDestroyerGenesisObject) Destroy(value *GenesisObject) {
		value.Destroy()
}



// The genesis transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// genesis-transaction = (vector genesis-object)
// ```
type GenesisTransactionInterface interface {
	Events() []Event
	Objects() []*GenesisObject
}
// The genesis transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// genesis-transaction = (vector genesis-object)
// ```
type GenesisTransaction struct {
	ffiObject FfiObject
}
func NewGenesisTransaction(objects []*GenesisObject, events []Event) *GenesisTransaction {
	return FfiConverterGenesisTransactionINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_genesistransaction_new(FfiConverterSequenceGenesisObjectINSTANCE.Lower(objects), FfiConverterSequenceEventINSTANCE.Lower(events),_uniffiStatus)
	}))
}




func (_self *GenesisTransaction) Events() []Event {
	_pointer := _self.ffiObject.incrementPointer("*GenesisTransaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceEventINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_genesistransaction_events(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *GenesisTransaction) Objects() []*GenesisObject {
	_pointer := _self.ffiObject.incrementPointer("*GenesisTransaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceGenesisObjectINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_genesistransaction_objects(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *GenesisTransaction) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterGenesisTransaction struct {}

var FfiConverterGenesisTransactionINSTANCE = FfiConverterGenesisTransaction{}


func (c FfiConverterGenesisTransaction) Lift(pointer unsafe.Pointer) *GenesisTransaction {
	result := &GenesisTransaction {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_genesistransaction(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_genesistransaction(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*GenesisTransaction).Destroy)
	return result
}

func (c FfiConverterGenesisTransaction) Read(reader io.Reader) *GenesisTransaction {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterGenesisTransaction) Lower(value *GenesisTransaction) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*GenesisTransaction")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterGenesisTransaction) Write(writer io.Writer, value *GenesisTransaction) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerGenesisTransaction struct {}

func (_ FfiDestroyerGenesisTransaction) Destroy(value *GenesisTransaction) {
		value.Destroy()
}



// The GraphQL client for interacting with the IOTA blockchain.
type GraphQlClientInterface interface {
	// Get the list of active validators for the provided epoch, including
	// related metadata. If no epoch is provided, it will return the active
	// validators for the current epoch.
	ActiveValidators(epoch *uint64, paginationFilter *PaginationFilter) (ValidatorPage, error)
	// Get the balance of all the coins owned by address for the provided coin
	// type. Coin type will default to `0x2::coin::Coin<0x2::iota::IOTA>`
	// if not provided.
	Balance(address *Address, coinType *string) (*uint64, error)
	// Get the chain identifier.
	ChainId() (string, error)
	// Get the `CheckpointSummary` for a given checkpoint digest or
	// checkpoint id. If none is provided, it will use the last known
	// checkpoint id.
	Checkpoint(digest **Digest, seqNum *uint64) (**CheckpointSummary, error)
	// Get a page of `CheckpointSummary` for the provided parameters.
	Checkpoints(paginationFilter *PaginationFilter) (CheckpointSummaryPage, error)
	// Get the coin metadata for the coin type.
	CoinMetadata(coinType string) (*CoinMetadata, error)
	// Get the list of coins for the specified address.
	//
	// If `coin_type` is not provided, all coins will be returned. For IOTA
	// coins, pass in the coin type: `0x2::iota::IOTA`.
	Coins(owner *Address, paginationFilter *PaginationFilter, coinType **StructTag) (CoinPage, error)
	// Dry run a `Transaction` and return the transaction effects and dry run
	// error (if any).
	//
	// `skipChecks` optional flag disables the usual verification checks that
	// prevent access to objects that are owned by addresses other than the
	// sender, and calling non-public, non-entry functions, and some other
	// checks. Defaults to false.
	DryRunTx(tx *Transaction, skipChecks bool) (DryRunResult, error)
	// Dry run a `TransactionKind` and return the transaction effects and dry
	// run error (if any).
	//
	// `skipChecks` optional flag disables the usual verification checks that
	// prevent access to objects that are owned by addresses other than the
	// sender, and calling non-public, non-entry functions, and some other
	// checks. Defaults to false.
	//
	// `tx_meta` is the transaction metadata.
	DryRunTxKind(txKind *TransactionKind, txMeta TransactionMetadata, skipChecks bool) (DryRunResult, error)
	// Access a dynamic field on an object using its name. Names are arbitrary
	// Move values whose type have copy, drop, and store, and are specified
	// using their type, and their BCS contents, Base64 encoded.
	//
	// The `name` argument is a json serialized type.
	//
	// This returns `DynamicFieldOutput` which contains the name, the value
	// as json, and object.
	DynamicField(address *Address, typeTag *TypeTag, name Value) (*DynamicFieldOutput, error)
	// Get a page of dynamic fields for the provided address. Note that this
	// will also fetch dynamic fields on wrapped objects.
	//
	// This returns a page of `DynamicFieldOutput`s.
	DynamicFields(address *Address, paginationFilter *PaginationFilter) (DynamicFieldOutputPage, error)
	// Access a dynamic object field on an object using its name. Names are
	// arbitrary Move values whose type have copy, drop, and store, and are
	// specified using their type, and their BCS contents, Base64 encoded.
	//
	// The `name` argument is a json serialized type.
	//
	// This returns `DynamicFieldOutput` which contains the name, the value
	// as json, and object.
	DynamicObjectField(address *Address, typeTag *TypeTag, name Value) (*DynamicFieldOutput, error)
	// Return the epoch information for the provided epoch. If no epoch is
	// provided, it will return the last known epoch.
	Epoch(epoch *uint64) (*Epoch, error)
	// Return the number of checkpoints in this epoch. This will return
	// `Ok(None)` if the epoch requested is not available in the GraphQL
	// service (e.g., due to pruning).
	EpochTotalCheckpoints(epoch *uint64) (*uint64, error)
	// Return the number of transaction blocks in this epoch. This will return
	// `Ok(None)` if the epoch requested is not available in the GraphQL
	// service (e.g., due to pruning).
	EpochTotalTransactionBlocks(epoch *uint64) (*uint64, error)
	// Return a page of tuple (event, transaction digest) based on the
	// (optional) event filter.
	Events(filter *EventFilter, paginationFilter *PaginationFilter) (EventPage, error)
	// Execute a transaction.
	ExecuteTx(signatures []*UserSignature, tx *Transaction, waitFor *WaitForTx) (*TransactionEffects, error)
	// Get the list of gas coins for the specified address.
	GasCoins(owner *Address, paginationFilter *PaginationFilter) (CoinPage, error)
	// Get the default name pointing to this address, if one exists.
	IotaNamesDefaultName(address *Address, format *NameFormat) (**Name, error)
	// Return the resolved address for the given name.
	IotaNamesLookup(name string) (**Address, error)
	// Find all registration NFTs for the given address.
	IotaNamesRegistrations(address *Address, paginationFilter PaginationFilter) (NameRegistrationPage, error)
	// Returns whether the transaction for the given digest has been included
	// in a checkpoint (finalized).
	IsTxFinalized(digest *Digest) (bool, error)
	// Returns whether the transaction for the given digest has been indexed
	// on the node. This means that it can be queries by its digest and its
	// effects will be usable for subsequent transactions. To check for
	// full finalization, use `is_tx_finalized`.
	IsTxIndexedOnNode(digest *Digest) (bool, error)
	// Return the sequence number of the latest checkpoint that has been
	// executed.
	LatestCheckpointSequenceNumber() (*uint64, error)
	// Lazily fetch the max page size
	MaxPageSize() (int32, error)
	// Return the contents' JSON of an object that is a Move object.
	//
	// If the object does not exist (e.g., due to pruning), this will return
	// `Ok(None)`. Similarly, if this is not an object but an address, it
	// will return `Ok(None)`.
	MoveObjectContents(objectId *ObjectId, version *uint64) (*Value, error)
	// Return the BCS of an object that is a Move object.
	//
	// If the object does not exist (e.g., due to pruning), this will return
	// `Ok(None)`. Similarly, if this is not an object but an address, it
	// will return `Ok(None)`.
	MoveObjectContentsBcs(objectId *ObjectId, version *uint64) (*[]byte, error)
	// Return the normalized Move function data for the provided package,
	// module, and function.
	NormalizedMoveFunction(varPackage *Address, module string, function string, version *uint64) (**MoveFunction, error)
	// Return the normalized Move module data for the provided module.
	NormalizedMoveModule(varPackage *Address, module string, version *uint64, paginationFilterEnums *PaginationFilter, paginationFilterFriends *PaginationFilter, paginationFilterFunctions *PaginationFilter, paginationFilterStructs *PaginationFilter) (*MoveModule, error)
	// Return an object based on the provided `Address`.
	//
	// If the object does not exist (e.g., due to pruning), this will return
	// `Ok(None)`. Similarly, if this is not an object but an address, it
	// will return `Ok(None)`.
	Object(objectId *ObjectId, version *uint64) (**Object, error)
	// Return the object's bcs content `Vec<u8>` based on the provided
	// `Address`.
	ObjectBcs(objectId *ObjectId) (*[]byte, error)
	// Return a page of objects based on the provided parameters.
	//
	// Use this function together with the `ObjectFilter::owner` to get the
	// objects owned by an address.
	Objects(filter *ObjectFilter, paginationFilter *PaginationFilter) (ObjectPage, error)
	// The package corresponding to the given address (at the optionally given
	// version). When no version is given, the package is loaded directly
	// from the address given. Otherwise, the address is translated before
	// loading to point to the package whose original ID matches
	// the package at address, but whose version is version. For non-system
	// packages, this might result in a different address than address
	// because different versions of a package, introduced by upgrades,
	// exist at distinct addresses.
	//
	// Note that this interpretation of version is different from a historical
	// object read (the interpretation of version for the object query).
	Package(address *Address, version *uint64) (**MovePackage, error)
	// Fetch the latest version of the package at address.
	// This corresponds to the package with the highest version that shares its
	// original ID with the package at address.
	PackageLatest(address *Address) (**MovePackage, error)
	// Fetch all versions of package at address (packages that share this
	// package's original ID), optionally bounding the versions exclusively
	// from below with afterVersion, or from above with beforeVersion.
	PackageVersions(address *Address, afterVersion *uint64, beforeVersion *uint64, paginationFilter *PaginationFilter) (MovePackagePage, error)
	// The Move packages that exist in the network, optionally filtered to be
	// strictly before beforeCheckpoint and/or strictly after
	// afterCheckpoint.
	//
	// This query returns all versions of a given user package that appear
	// between the specified checkpoints, but only records the latest
	// versions of system packages.
	Packages(afterCheckpoint *uint64, beforeCheckpoint *uint64, paginationFilter *PaginationFilter) (MovePackagePage, error)
	// Get the protocol configuration.
	ProtocolConfig(version *uint64) (ProtocolConfigs, error)
	// Get the reference gas price for the provided epoch or the last known one
	// if no epoch is provided.
	//
	// This will return `Ok(None)` if the epoch requested is not available in
	// the GraphQL service (e.g., due to pruning).
	ReferenceGasPrice(epoch *uint64) (*uint64, error)
	// Run a query.
	RunQuery(query Query) (Value, error)
	// Get the GraphQL service configuration, including complexity limits, read
	// and mutation limits, supported versions, and others.
	ServiceConfig() (ServiceConfig, error)
	// Set the server address for the GraphQL GraphQL client. It should be a
	// valid URL with a host and optionally a port number.
	SetRpcServer(server string) error
	// Get total supply for the coin type.
	TotalSupply(coinType string) (*uint64, error)
	// The total number of transaction blocks in the network by the end of the
	// last known checkpoint.
	TotalTransactionBlocks() (*uint64, error)
	// The total number of transaction blocks in the network by the end of the
	// provided checkpoint digest.
	TotalTransactionBlocksByDigest(digest *Digest) (*uint64, error)
	// The total number of transaction blocks in the network by the end of the
	// provided checkpoint sequence number.
	TotalTransactionBlocksBySeqNum(seqNum uint64) (*uint64, error)
	// Get a transaction by its digest.
	Transaction(digest *Digest) (*SignedTransaction, error)
	// Get a transaction's data and effects by its digest.
	TransactionDataEffects(digest *Digest) (*TransactionDataEffects, error)
	// Get a transaction's effects by its digest.
	TransactionEffects(digest *Digest) (**TransactionEffects, error)
	// Get a page of transactions based on the provided filters.
	Transactions(filter *TransactionsFilter, paginationFilter *PaginationFilter) (SignedTransactionPage, error)
	// Get a page of transactions' data and effects based on the provided
	// filters.
	TransactionsDataEffects(filter *TransactionsFilter, paginationFilter *PaginationFilter) (TransactionDataEffectsPage, error)
	// Get a page of transactions' effects based on the provided filters.
	TransactionsEffects(filter *TransactionsFilter, paginationFilter *PaginationFilter) (TransactionEffectsPage, error)
	// Wait for the indexing or finalization of a transaction
	// by its digest. An optional timeout can be provided, which, if
	// exceeded, will return an error (default 60s).
	WaitForTx(digest *Digest, waitFor WaitForTx, timeout *time.Duration) error
}
// The GraphQL client for interacting with the IOTA blockchain.
type GraphQlClient struct {
	ffiObject FfiObject
}
// Create a new GraphQL client with the provided server address.
func NewGraphQlClient(server string) (*GraphQlClient, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new(FfiConverterStringINSTANCE.Lower(server),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *GraphQlClient
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterGraphQlClientINSTANCE.Lift(_uniffiRV), nil
		}
}


// Create a new GraphQL client connected to the `devnet` GraphQL server:
// {DEVNET_HOST}.
func GraphQlClientNewDevnet() *GraphQlClient {
	return FfiConverterGraphQlClientINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_devnet(_uniffiStatus)
	}))
}

// Create a new GraphQL client connected to the `localhost` GraphQL server:
// {DEFAULT_LOCAL_HOST}.
func GraphQlClientNewLocalnet() *GraphQlClient {
	return FfiConverterGraphQlClientINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_localnet(_uniffiStatus)
	}))
}

// Create a new GraphQL client connected to the `mainnet` GraphQL server:
// {MAINNET_HOST}.
func GraphQlClientNewMainnet() *GraphQlClient {
	return FfiConverterGraphQlClientINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_mainnet(_uniffiStatus)
	}))
}

// Create a new GraphQL client connected to the `testnet` GraphQL server:
// {TESTNET_HOST}.
func GraphQlClientNewTestnet() *GraphQlClient {
	return FfiConverterGraphQlClientINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_testnet(_uniffiStatus)
	}))
}



// Get the list of active validators for the provided epoch, including
// related metadata. If no epoch is provided, it will return the active
// validators for the current epoch.
func (_self *GraphQlClient) ActiveValidators(epoch *uint64, paginationFilter *PaginationFilter) (ValidatorPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) ValidatorPage {
			return FfiConverterValidatorPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_active_validators(
		_pointer,FfiConverterOptionalUint64INSTANCE.Lower(epoch), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get the balance of all the coins owned by address for the provided coin
// type. Coin type will default to `0x2::coin::Coin<0x2::iota::IOTA>`
// if not provided.
func (_self *GraphQlClient) Balance(address *Address, coinType *string) (*uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *uint64 {
			return FfiConverterOptionalUint64INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_balance(
		_pointer,FfiConverterAddressINSTANCE.Lower(address), FfiConverterOptionalStringINSTANCE.Lower(coinType)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get the chain identifier.
func (_self *GraphQlClient) ChainId() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_chain_id(
		_pointer,),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get the `CheckpointSummary` for a given checkpoint digest or
// checkpoint id. If none is provided, it will use the last known
// checkpoint id.
func (_self *GraphQlClient) Checkpoint(digest **Digest, seqNum *uint64) (**CheckpointSummary, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) **CheckpointSummary {
			return FfiConverterOptionalCheckpointSummaryINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_checkpoint(
		_pointer,FfiConverterOptionalDigestINSTANCE.Lower(digest), FfiConverterOptionalUint64INSTANCE.Lower(seqNum)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get a page of `CheckpointSummary` for the provided parameters.
func (_self *GraphQlClient) Checkpoints(paginationFilter *PaginationFilter) (CheckpointSummaryPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) CheckpointSummaryPage {
			return FfiConverterCheckpointSummaryPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_checkpoints(
		_pointer,FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get the coin metadata for the coin type.
func (_self *GraphQlClient) CoinMetadata(coinType string) (*CoinMetadata, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *CoinMetadata {
			return FfiConverterOptionalCoinMetadataINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_coin_metadata(
		_pointer,FfiConverterStringINSTANCE.Lower(coinType)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get the list of coins for the specified address.
//
// If `coin_type` is not provided, all coins will be returned. For IOTA
// coins, pass in the coin type: `0x2::iota::IOTA`.
func (_self *GraphQlClient) Coins(owner *Address, paginationFilter *PaginationFilter, coinType **StructTag) (CoinPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) CoinPage {
			return FfiConverterCoinPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_coins(
		_pointer,FfiConverterAddressINSTANCE.Lower(owner), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter), FfiConverterOptionalStructTagINSTANCE.Lower(coinType)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Dry run a `Transaction` and return the transaction effects and dry run
// error (if any).
//
// `skipChecks` optional flag disables the usual verification checks that
// prevent access to objects that are owned by addresses other than the
// sender, and calling non-public, non-entry functions, and some other
// checks. Defaults to false.
func (_self *GraphQlClient) DryRunTx(tx *Transaction, skipChecks bool) (DryRunResult, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) DryRunResult {
			return FfiConverterDryRunResultINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dry_run_tx(
		_pointer,FfiConverterTransactionINSTANCE.Lower(tx), FfiConverterBoolINSTANCE.Lower(skipChecks)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Dry run a `TransactionKind` and return the transaction effects and dry
// run error (if any).
//
// `skipChecks` optional flag disables the usual verification checks that
// prevent access to objects that are owned by addresses other than the
// sender, and calling non-public, non-entry functions, and some other
// checks. Defaults to false.
//
// `tx_meta` is the transaction metadata.
func (_self *GraphQlClient) DryRunTxKind(txKind *TransactionKind, txMeta TransactionMetadata, skipChecks bool) (DryRunResult, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) DryRunResult {
			return FfiConverterDryRunResultINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dry_run_tx_kind(
		_pointer,FfiConverterTransactionKindINSTANCE.Lower(txKind), FfiConverterTransactionMetadataINSTANCE.Lower(txMeta), FfiConverterBoolINSTANCE.Lower(skipChecks)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Access a dynamic field on an object using its name. Names are arbitrary
// Move values whose type have copy, drop, and store, and are specified
// using their type, and their BCS contents, Base64 encoded.
//
// The `name` argument is a json serialized type.
//
// This returns `DynamicFieldOutput` which contains the name, the value
// as json, and object.
func (_self *GraphQlClient) DynamicField(address *Address, typeTag *TypeTag, name Value) (*DynamicFieldOutput, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *DynamicFieldOutput {
			return FfiConverterOptionalDynamicFieldOutputINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_field(
		_pointer,FfiConverterAddressINSTANCE.Lower(address), FfiConverterTypeTagINSTANCE.Lower(typeTag), FfiConverterTypeValueINSTANCE.Lower(name)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get a page of dynamic fields for the provided address. Note that this
// will also fetch dynamic fields on wrapped objects.
//
// This returns a page of `DynamicFieldOutput`s.
func (_self *GraphQlClient) DynamicFields(address *Address, paginationFilter *PaginationFilter) (DynamicFieldOutputPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) DynamicFieldOutputPage {
			return FfiConverterDynamicFieldOutputPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_fields(
		_pointer,FfiConverterAddressINSTANCE.Lower(address), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Access a dynamic object field on an object using its name. Names are
// arbitrary Move values whose type have copy, drop, and store, and are
// specified using their type, and their BCS contents, Base64 encoded.
//
// The `name` argument is a json serialized type.
//
// This returns `DynamicFieldOutput` which contains the name, the value
// as json, and object.
func (_self *GraphQlClient) DynamicObjectField(address *Address, typeTag *TypeTag, name Value) (*DynamicFieldOutput, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *DynamicFieldOutput {
			return FfiConverterOptionalDynamicFieldOutputINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_object_field(
		_pointer,FfiConverterAddressINSTANCE.Lower(address), FfiConverterTypeTagINSTANCE.Lower(typeTag), FfiConverterTypeValueINSTANCE.Lower(name)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return the epoch information for the provided epoch. If no epoch is
// provided, it will return the last known epoch.
func (_self *GraphQlClient) Epoch(epoch *uint64) (*Epoch, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *Epoch {
			return FfiConverterOptionalEpochINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch(
		_pointer,FfiConverterOptionalUint64INSTANCE.Lower(epoch)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return the number of checkpoints in this epoch. This will return
// `Ok(None)` if the epoch requested is not available in the GraphQL
// service (e.g., due to pruning).
func (_self *GraphQlClient) EpochTotalCheckpoints(epoch *uint64) (*uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *uint64 {
			return FfiConverterOptionalUint64INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch_total_checkpoints(
		_pointer,FfiConverterOptionalUint64INSTANCE.Lower(epoch)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return the number of transaction blocks in this epoch. This will return
// `Ok(None)` if the epoch requested is not available in the GraphQL
// service (e.g., due to pruning).
func (_self *GraphQlClient) EpochTotalTransactionBlocks(epoch *uint64) (*uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *uint64 {
			return FfiConverterOptionalUint64INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch_total_transaction_blocks(
		_pointer,FfiConverterOptionalUint64INSTANCE.Lower(epoch)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return a page of tuple (event, transaction digest) based on the
// (optional) event filter.
func (_self *GraphQlClient) Events(filter *EventFilter, paginationFilter *PaginationFilter) (EventPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) EventPage {
			return FfiConverterEventPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_events(
		_pointer,FfiConverterOptionalEventFilterINSTANCE.Lower(filter), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Execute a transaction.
func (_self *GraphQlClient) ExecuteTx(signatures []*UserSignature, tx *Transaction, waitFor *WaitForTx) (*TransactionEffects, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *TransactionEffects {
			return FfiConverterTransactionEffectsINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_execute_tx(
		_pointer,FfiConverterSequenceUserSignatureINSTANCE.Lower(signatures), FfiConverterTransactionINSTANCE.Lower(tx), FfiConverterOptionalWaitForTxINSTANCE.Lower(waitFor)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err 
}

// Get the list of gas coins for the specified address.
func (_self *GraphQlClient) GasCoins(owner *Address, paginationFilter *PaginationFilter) (CoinPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) CoinPage {
			return FfiConverterCoinPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_gas_coins(
		_pointer,FfiConverterAddressINSTANCE.Lower(owner), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get the default name pointing to this address, if one exists.
func (_self *GraphQlClient) IotaNamesDefaultName(address *Address, format *NameFormat) (**Name, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) **Name {
			return FfiConverterOptionalNameINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_default_name(
		_pointer,FfiConverterAddressINSTANCE.Lower(address), FfiConverterOptionalNameFormatINSTANCE.Lower(format)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return the resolved address for the given name.
func (_self *GraphQlClient) IotaNamesLookup(name string) (**Address, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) **Address {
			return FfiConverterOptionalAddressINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_lookup(
		_pointer,FfiConverterStringINSTANCE.Lower(name)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Find all registration NFTs for the given address.
func (_self *GraphQlClient) IotaNamesRegistrations(address *Address, paginationFilter PaginationFilter) (NameRegistrationPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) NameRegistrationPage {
			return FfiConverterNameRegistrationPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_registrations(
		_pointer,FfiConverterAddressINSTANCE.Lower(address), FfiConverterPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Returns whether the transaction for the given digest has been included
// in a checkpoint (finalized).
func (_self *GraphQlClient) IsTxFinalized(digest *Digest) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_is_tx_finalized(
		_pointer,FfiConverterDigestINSTANCE.Lower(digest)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err 
}

// Returns whether the transaction for the given digest has been indexed
// on the node. This means that it can be queries by its digest and its
// effects will be usable for subsequent transactions. To check for
// full finalization, use `is_tx_finalized`.
func (_self *GraphQlClient) IsTxIndexedOnNode(digest *Digest) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_is_tx_indexed_on_node(
		_pointer,FfiConverterDigestINSTANCE.Lower(digest)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err 
}

// Return the sequence number of the latest checkpoint that has been
// executed.
func (_self *GraphQlClient) LatestCheckpointSequenceNumber() (*uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *uint64 {
			return FfiConverterOptionalUint64INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_latest_checkpoint_sequence_number(
		_pointer,),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Lazily fetch the max page size
func (_self *GraphQlClient) MaxPageSize() (int32, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int32_t {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_i32(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int32_t) int32 {
			return FfiConverterInt32INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_max_page_size(
		_pointer,),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_i32(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_i32(handle)
		},
	)

	return res, err 
}

// Return the contents' JSON of an object that is a Move object.
//
// If the object does not exist (e.g., due to pruning), this will return
// `Ok(None)`. Similarly, if this is not an object but an address, it
// will return `Ok(None)`.
func (_self *GraphQlClient) MoveObjectContents(objectId *ObjectId, version *uint64) (*Value, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *Value {
			return FfiConverterOptionalTypeValueINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_move_object_contents(
		_pointer,FfiConverterObjectIdINSTANCE.Lower(objectId), FfiConverterOptionalUint64INSTANCE.Lower(version)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return the BCS of an object that is a Move object.
//
// If the object does not exist (e.g., due to pruning), this will return
// `Ok(None)`. Similarly, if this is not an object but an address, it
// will return `Ok(None)`.
func (_self *GraphQlClient) MoveObjectContentsBcs(objectId *ObjectId, version *uint64) (*[]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *[]byte {
			return FfiConverterOptionalBytesINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_move_object_contents_bcs(
		_pointer,FfiConverterObjectIdINSTANCE.Lower(objectId), FfiConverterOptionalUint64INSTANCE.Lower(version)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return the normalized Move function data for the provided package,
// module, and function.
func (_self *GraphQlClient) NormalizedMoveFunction(varPackage *Address, module string, function string, version *uint64) (**MoveFunction, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) **MoveFunction {
			return FfiConverterOptionalMoveFunctionINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_normalized_move_function(
		_pointer,FfiConverterAddressINSTANCE.Lower(varPackage), FfiConverterStringINSTANCE.Lower(module), FfiConverterStringINSTANCE.Lower(function), FfiConverterOptionalUint64INSTANCE.Lower(version)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return the normalized Move module data for the provided module.
func (_self *GraphQlClient) NormalizedMoveModule(varPackage *Address, module string, version *uint64, paginationFilterEnums *PaginationFilter, paginationFilterFriends *PaginationFilter, paginationFilterFunctions *PaginationFilter, paginationFilterStructs *PaginationFilter) (*MoveModule, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *MoveModule {
			return FfiConverterOptionalMoveModuleINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_normalized_move_module(
		_pointer,FfiConverterAddressINSTANCE.Lower(varPackage), FfiConverterStringINSTANCE.Lower(module), FfiConverterOptionalUint64INSTANCE.Lower(version), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilterEnums), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilterFriends), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilterFunctions), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilterStructs)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return an object based on the provided `Address`.
//
// If the object does not exist (e.g., due to pruning), this will return
// `Ok(None)`. Similarly, if this is not an object but an address, it
// will return `Ok(None)`.
func (_self *GraphQlClient) Object(objectId *ObjectId, version *uint64) (**Object, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) **Object {
			return FfiConverterOptionalObjectINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_object(
		_pointer,FfiConverterObjectIdINSTANCE.Lower(objectId), FfiConverterOptionalUint64INSTANCE.Lower(version)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return the object's bcs content `Vec<u8>` based on the provided
// `Address`.
func (_self *GraphQlClient) ObjectBcs(objectId *ObjectId) (*[]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *[]byte {
			return FfiConverterOptionalBytesINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_object_bcs(
		_pointer,FfiConverterObjectIdINSTANCE.Lower(objectId)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Return a page of objects based on the provided parameters.
//
// Use this function together with the `ObjectFilter::owner` to get the
// objects owned by an address.
func (_self *GraphQlClient) Objects(filter *ObjectFilter, paginationFilter *PaginationFilter) (ObjectPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) ObjectPage {
			return FfiConverterObjectPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_objects(
		_pointer,FfiConverterOptionalObjectFilterINSTANCE.Lower(filter), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// The package corresponding to the given address (at the optionally given
// version). When no version is given, the package is loaded directly
// from the address given. Otherwise, the address is translated before
// loading to point to the package whose original ID matches
// the package at address, but whose version is version. For non-system
// packages, this might result in a different address than address
// because different versions of a package, introduced by upgrades,
// exist at distinct addresses.
//
// Note that this interpretation of version is different from a historical
// object read (the interpretation of version for the object query).
func (_self *GraphQlClient) Package(address *Address, version *uint64) (**MovePackage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) **MovePackage {
			return FfiConverterOptionalMovePackageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package(
		_pointer,FfiConverterAddressINSTANCE.Lower(address), FfiConverterOptionalUint64INSTANCE.Lower(version)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Fetch the latest version of the package at address.
// This corresponds to the package with the highest version that shares its
// original ID with the package at address.
func (_self *GraphQlClient) PackageLatest(address *Address) (**MovePackage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) **MovePackage {
			return FfiConverterOptionalMovePackageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package_latest(
		_pointer,FfiConverterAddressINSTANCE.Lower(address)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Fetch all versions of package at address (packages that share this
// package's original ID), optionally bounding the versions exclusively
// from below with afterVersion, or from above with beforeVersion.
func (_self *GraphQlClient) PackageVersions(address *Address, afterVersion *uint64, beforeVersion *uint64, paginationFilter *PaginationFilter) (MovePackagePage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) MovePackagePage {
			return FfiConverterMovePackagePageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package_versions(
		_pointer,FfiConverterAddressINSTANCE.Lower(address), FfiConverterOptionalUint64INSTANCE.Lower(afterVersion), FfiConverterOptionalUint64INSTANCE.Lower(beforeVersion), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// The Move packages that exist in the network, optionally filtered to be
// strictly before beforeCheckpoint and/or strictly after
// afterCheckpoint.
//
// This query returns all versions of a given user package that appear
// between the specified checkpoints, but only records the latest
// versions of system packages.
func (_self *GraphQlClient) Packages(afterCheckpoint *uint64, beforeCheckpoint *uint64, paginationFilter *PaginationFilter) (MovePackagePage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) MovePackagePage {
			return FfiConverterMovePackagePageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_packages(
		_pointer,FfiConverterOptionalUint64INSTANCE.Lower(afterCheckpoint), FfiConverterOptionalUint64INSTANCE.Lower(beforeCheckpoint), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get the protocol configuration.
func (_self *GraphQlClient) ProtocolConfig(version *uint64) (ProtocolConfigs, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) ProtocolConfigs {
			return FfiConverterProtocolConfigsINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_protocol_config(
		_pointer,FfiConverterOptionalUint64INSTANCE.Lower(version)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get the reference gas price for the provided epoch or the last known one
// if no epoch is provided.
//
// This will return `Ok(None)` if the epoch requested is not available in
// the GraphQL service (e.g., due to pruning).
func (_self *GraphQlClient) ReferenceGasPrice(epoch *uint64) (*uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *uint64 {
			return FfiConverterOptionalUint64INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_reference_gas_price(
		_pointer,FfiConverterOptionalUint64INSTANCE.Lower(epoch)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Run a query.
func (_self *GraphQlClient) RunQuery(query Query) (Value, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) Value {
			return FfiConverterTypeValueINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_run_query(
		_pointer,FfiConverterQueryINSTANCE.Lower(query)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get the GraphQL service configuration, including complexity limits, read
// and mutation limits, supported versions, and others.
func (_self *GraphQlClient) ServiceConfig() (ServiceConfig, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) ServiceConfig {
			return FfiConverterServiceConfigINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_service_config(
		_pointer,),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Set the server address for the GraphQL GraphQL client. It should be a
// valid URL with a host and optionally a port number.
func (_self *GraphQlClient) SetRpcServer(server string) error {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 _, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_iota_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_set_rpc_server(
		_pointer,FfiConverterStringINSTANCE.Lower(server)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err 
}

// Get total supply for the coin type.
func (_self *GraphQlClient) TotalSupply(coinType string) (*uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *uint64 {
			return FfiConverterOptionalUint64INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_supply(
		_pointer,FfiConverterStringINSTANCE.Lower(coinType)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// The total number of transaction blocks in the network by the end of the
// last known checkpoint.
func (_self *GraphQlClient) TotalTransactionBlocks() (*uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *uint64 {
			return FfiConverterOptionalUint64INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks(
		_pointer,),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// The total number of transaction blocks in the network by the end of the
// provided checkpoint digest.
func (_self *GraphQlClient) TotalTransactionBlocksByDigest(digest *Digest) (*uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *uint64 {
			return FfiConverterOptionalUint64INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks_by_digest(
		_pointer,FfiConverterDigestINSTANCE.Lower(digest)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// The total number of transaction blocks in the network by the end of the
// provided checkpoint sequence number.
func (_self *GraphQlClient) TotalTransactionBlocksBySeqNum(seqNum uint64) (*uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *uint64 {
			return FfiConverterOptionalUint64INSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks_by_seq_num(
		_pointer,FfiConverterUint64INSTANCE.Lower(seqNum)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get a transaction by its digest.
func (_self *GraphQlClient) Transaction(digest *Digest) (*SignedTransaction, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *SignedTransaction {
			return FfiConverterOptionalSignedTransactionINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction(
		_pointer,FfiConverterDigestINSTANCE.Lower(digest)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get a transaction's data and effects by its digest.
func (_self *GraphQlClient) TransactionDataEffects(digest *Digest) (*TransactionDataEffects, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) *TransactionDataEffects {
			return FfiConverterOptionalTransactionDataEffectsINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction_data_effects(
		_pointer,FfiConverterDigestINSTANCE.Lower(digest)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get a transaction's effects by its digest.
func (_self *GraphQlClient) TransactionEffects(digest *Digest) (**TransactionEffects, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) **TransactionEffects {
			return FfiConverterOptionalTransactionEffectsINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction_effects(
		_pointer,FfiConverterDigestINSTANCE.Lower(digest)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get a page of transactions based on the provided filters.
func (_self *GraphQlClient) Transactions(filter *TransactionsFilter, paginationFilter *PaginationFilter) (SignedTransactionPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) SignedTransactionPage {
			return FfiConverterSignedTransactionPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions(
		_pointer,FfiConverterOptionalTransactionsFilterINSTANCE.Lower(filter), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get a page of transactions' data and effects based on the provided
// filters.
func (_self *GraphQlClient) TransactionsDataEffects(filter *TransactionsFilter, paginationFilter *PaginationFilter) (TransactionDataEffectsPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) TransactionDataEffectsPage {
			return FfiConverterTransactionDataEffectsPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions_data_effects(
		_pointer,FfiConverterOptionalTransactionsFilterINSTANCE.Lower(filter), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Get a page of transactions' effects based on the provided filters.
func (_self *GraphQlClient) TransactionsEffects(filter *TransactionsFilter, paginationFilter *PaginationFilter) (TransactionEffectsPage, error) {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) TransactionEffectsPage {
			return FfiConverterTransactionEffectsPageINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions_effects(
		_pointer,FfiConverterOptionalTransactionsFilterINSTANCE.Lower(filter), FfiConverterOptionalPaginationFilterINSTANCE.Lower(paginationFilter)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Wait for the indexing or finalization of a transaction
// by its digest. An optional timeout can be provided, which, if
// exceeded, will return an error (default 60s).
func (_self *GraphQlClient) WaitForTx(digest *Digest, waitFor WaitForTx, timeout *time.Duration) error {
	_pointer := _self.ffiObject.incrementPointer("*GraphQlClient")
	defer _self.ffiObject.decrementPointer()
	 _, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_iota_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_iota_sdk_ffi_fn_method_graphqlclient_wait_for_tx(
		_pointer,FfiConverterDigestINSTANCE.Lower(digest), FfiConverterWaitForTxINSTANCE.Lower(waitFor), FfiConverterOptionalDurationINSTANCE.Lower(timeout)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err 
}
func (object *GraphQlClient) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterGraphQlClient struct {}

var FfiConverterGraphQlClientINSTANCE = FfiConverterGraphQlClient{}


func (c FfiConverterGraphQlClient) Lift(pointer unsafe.Pointer) *GraphQlClient {
	result := &GraphQlClient {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_graphqlclient(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_graphqlclient(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*GraphQlClient).Destroy)
	return result
}

func (c FfiConverterGraphQlClient) Read(reader io.Reader) *GraphQlClient {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterGraphQlClient) Lower(value *GraphQlClient) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*GraphQlClient")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterGraphQlClient) Write(writer io.Writer, value *GraphQlClient) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerGraphQlClient struct {}

func (_ FfiDestroyerGraphQlClient) Destroy(value *GraphQlClient) {
		value.Destroy()
}



// A move identifier
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// identifier = %x01-80    ; length of the identifier
// (ALPHA *127(ALPHA / DIGIT / UNDERSCORE)) /
// (UNDERSCORE 1*127(ALPHA / DIGIT / UNDERSCORE))
//
// UNDERSCORE = %x95
// ```
type IdentifierInterface interface {
	AsStr() string
}
// A move identifier
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// identifier = %x01-80    ; length of the identifier
// (ALPHA *127(ALPHA / DIGIT / UNDERSCORE)) /
// (UNDERSCORE 1*127(ALPHA / DIGIT / UNDERSCORE))
//
// UNDERSCORE = %x95
// ```
type Identifier struct {
	ffiObject FfiObject
}
func NewIdentifier(identifier string) (*Identifier, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_identifier_new(FfiConverterStringINSTANCE.Lower(identifier),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Identifier
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterIdentifierINSTANCE.Lift(_uniffiRV), nil
		}
}




func (_self *Identifier) AsStr() string {
	_pointer := _self.ffiObject.incrementPointer("*Identifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_identifier_as_str(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Identifier) Hash() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*Identifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_identifier_uniffi_trait_hash(
		_pointer,_uniffiStatus)
	}))
}


func (object *Identifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterIdentifier struct {}

var FfiConverterIdentifierINSTANCE = FfiConverterIdentifier{}


func (c FfiConverterIdentifier) Lift(pointer unsafe.Pointer) *Identifier {
	result := &Identifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_identifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_identifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Identifier).Destroy)
	return result
}

func (c FfiConverterIdentifier) Read(reader io.Reader) *Identifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterIdentifier) Lower(value *Identifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Identifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterIdentifier) Write(writer io.Writer, value *Identifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerIdentifier struct {}

func (_ FfiDestroyerIdentifier) Destroy(value *Identifier) {
		value.Destroy()
}



// An input to a user transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// input = input-pure / input-immutable-or-owned / input-shared / input-receiving
//
// input-pure                  = %x00 bytes
// input-immutable-or-owned    = %x01 object-ref
// input-shared                = %x02 object-id u64 bool
// input-receiving             = %x04 object-ref
// ```
type InputInterface interface {
}
// An input to a user transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// input = input-pure / input-immutable-or-owned / input-shared / input-receiving
//
// input-pure                  = %x00 bytes
// input-immutable-or-owned    = %x01 object-ref
// input-shared                = %x02 object-id u64 bool
// input-receiving             = %x04 object-ref
// ```
type Input struct {
	ffiObject FfiObject
}


// A move object that is either immutable or address owned
func InputNewImmutableOrOwned(objectRef ObjectReference) *Input {
	return FfiConverterInputINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_input_new_immutable_or_owned(FfiConverterObjectReferenceINSTANCE.Lower(objectRef),_uniffiStatus)
	}))
}

// For normal operations this is required to be a move primitive type and
// not contain structs or objects.
func InputNewPure(value []byte) *Input {
	return FfiConverterInputINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_input_new_pure(FfiConverterBytesINSTANCE.Lower(value),_uniffiStatus)
	}))
}

func InputNewReceiving(objectRef ObjectReference) *Input {
	return FfiConverterInputINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_input_new_receiving(FfiConverterObjectReferenceINSTANCE.Lower(objectRef),_uniffiStatus)
	}))
}

// A move object whose owner is "Shared"
func InputNewShared(objectId *ObjectId, initialSharedVersion uint64, mutable bool) *Input {
	return FfiConverterInputINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_input_new_shared(FfiConverterObjectIdINSTANCE.Lower(objectId), FfiConverterUint64INSTANCE.Lower(initialSharedVersion), FfiConverterBoolINSTANCE.Lower(mutable),_uniffiStatus)
	}))
}


func (object *Input) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterInput struct {}

var FfiConverterInputINSTANCE = FfiConverterInput{}


func (c FfiConverterInput) Lift(pointer unsafe.Pointer) *Input {
	result := &Input {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_input(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_input(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Input).Destroy)
	return result
}

func (c FfiConverterInput) Read(reader io.Reader) *Input {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterInput) Lower(value *Input) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Input")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterInput) Write(writer io.Writer, value *Input) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerInput struct {}

func (_ FfiDestroyerInput) Destroy(value *Input) {
		value.Destroy()
}



// Command to build a move vector out of a set of individual elements
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// make-move-vector = (option type-tag) (vector argument)
// ```
type MakeMoveVectorInterface interface {
	// The set individual elements to build the vector with
	Elements() []*Argument
	// Type of the individual elements
	//
	// This is required to be set when the type can't be inferred, for example
	// when the set of provided arguments are all pure input values.
	TypeTag() **TypeTag
}
// Command to build a move vector out of a set of individual elements
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// make-move-vector = (option type-tag) (vector argument)
// ```
type MakeMoveVector struct {
	ffiObject FfiObject
}
func NewMakeMoveVector(typeTag **TypeTag, elements []*Argument) *MakeMoveVector {
	return FfiConverterMakeMoveVectorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_makemovevector_new(FfiConverterOptionalTypeTagINSTANCE.Lower(typeTag), FfiConverterSequenceArgumentINSTANCE.Lower(elements),_uniffiStatus)
	}))
}




// The set individual elements to build the vector with
func (_self *MakeMoveVector) Elements() []*Argument {
	_pointer := _self.ffiObject.incrementPointer("*MakeMoveVector")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_makemovevector_elements(
		_pointer,_uniffiStatus),
	}
	}))
}

// Type of the individual elements
//
// This is required to be set when the type can't be inferred, for example
// when the set of provided arguments are all pure input values.
func (_self *MakeMoveVector) TypeTag() **TypeTag {
	_pointer := _self.ffiObject.incrementPointer("*MakeMoveVector")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_makemovevector_type_tag(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *MakeMoveVector) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMakeMoveVector struct {}

var FfiConverterMakeMoveVectorINSTANCE = FfiConverterMakeMoveVector{}


func (c FfiConverterMakeMoveVector) Lift(pointer unsafe.Pointer) *MakeMoveVector {
	result := &MakeMoveVector {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_makemovevector(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_makemovevector(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MakeMoveVector).Destroy)
	return result
}

func (c FfiConverterMakeMoveVector) Read(reader io.Reader) *MakeMoveVector {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMakeMoveVector) Lower(value *MakeMoveVector) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MakeMoveVector")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMakeMoveVector) Write(writer io.Writer, value *MakeMoveVector) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMakeMoveVector struct {}

func (_ FfiDestroyerMakeMoveVector) Destroy(value *MakeMoveVector) {
		value.Destroy()
}



// Command to merge multiple coins of the same type into a single coin
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// merge-coins = argument (vector argument)
// ```
type MergeCoinsInterface interface {
	// Coin to merge coins into
	Coin() *Argument
	// Set of coins to merge into `coin`
	//
	// All listed coins must be of the same type and be the same type as `coin`
	CoinsToMerge() []*Argument
}
// Command to merge multiple coins of the same type into a single coin
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// merge-coins = argument (vector argument)
// ```
type MergeCoins struct {
	ffiObject FfiObject
}
func NewMergeCoins(coin *Argument, coinsToMerge []*Argument) *MergeCoins {
	return FfiConverterMergeCoinsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_mergecoins_new(FfiConverterArgumentINSTANCE.Lower(coin), FfiConverterSequenceArgumentINSTANCE.Lower(coinsToMerge),_uniffiStatus)
	}))
}




// Coin to merge coins into
func (_self *MergeCoins) Coin() *Argument {
	_pointer := _self.ffiObject.incrementPointer("*MergeCoins")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_mergecoins_coin(
		_pointer,_uniffiStatus)
	}))
}

// Set of coins to merge into `coin`
//
// All listed coins must be of the same type and be the same type as `coin`
func (_self *MergeCoins) CoinsToMerge() []*Argument {
	_pointer := _self.ffiObject.incrementPointer("*MergeCoins")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_mergecoins_coins_to_merge(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *MergeCoins) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMergeCoins struct {}

var FfiConverterMergeCoinsINSTANCE = FfiConverterMergeCoins{}


func (c FfiConverterMergeCoins) Lift(pointer unsafe.Pointer) *MergeCoins {
	result := &MergeCoins {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_mergecoins(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_mergecoins(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MergeCoins).Destroy)
	return result
}

func (c FfiConverterMergeCoins) Read(reader io.Reader) *MergeCoins {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMergeCoins) Lower(value *MergeCoins) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MergeCoins")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMergeCoins) Write(writer io.Writer, value *MergeCoins) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMergeCoins struct {}

func (_ FfiDestroyerMergeCoins) Destroy(value *MergeCoins) {
		value.Destroy()
}



type MoveArgInterface interface {
}
type MoveArg struct {
	ffiObject FfiObject
}


func MoveArgAddress(address *Address) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_address(FfiConverterAddressINSTANCE.Lower(address),_uniffiStatus)
	}))
}

func MoveArgAddressFromHex(hex string) (*MoveArg, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_from_hex(FfiConverterStringINSTANCE.Lower(hex),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MoveArg
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveArgINSTANCE.Lift(_uniffiRV), nil
		}
}

func MoveArgAddressVec(addresses []*Address) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_vec(FfiConverterSequenceAddressINSTANCE.Lower(addresses),_uniffiStatus)
	}))
}

func MoveArgAddressVecFromHex(addresses []string) (*MoveArg, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_vec_from_hex(FfiConverterSequenceStringINSTANCE.Lower(addresses),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MoveArg
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveArgINSTANCE.Lift(_uniffiRV), nil
		}
}

func MoveArgBool(value bool) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_bool(FfiConverterBoolINSTANCE.Lower(value),_uniffiStatus)
	}))
}

func MoveArgBoolVec(values []bool) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_bool_vec(FfiConverterSequenceBoolINSTANCE.Lower(values),_uniffiStatus)
	}))
}

func MoveArgDigest(digest *Digest) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest(FfiConverterDigestINSTANCE.Lower(digest),_uniffiStatus)
	}))
}

func MoveArgDigestFromBase58(base58 string) (*MoveArg, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_from_base58(FfiConverterStringINSTANCE.Lower(base58),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MoveArg
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveArgINSTANCE.Lift(_uniffiRV), nil
		}
}

func MoveArgDigestVec(digests []*Digest) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_vec(FfiConverterSequenceDigestINSTANCE.Lower(digests),_uniffiStatus)
	}))
}

func MoveArgDigestVecFromBase58(digests []string) (*MoveArg, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_vec_from_base58(FfiConverterSequenceStringINSTANCE.Lower(digests),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MoveArg
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveArgINSTANCE.Lift(_uniffiRV), nil
		}
}

func MoveArgOption(value **MoveArg) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_option(FfiConverterOptionalMoveArgINSTANCE.Lower(value),_uniffiStatus)
	}))
}

func MoveArgString(string string) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_string(FfiConverterStringINSTANCE.Lower(string),_uniffiStatus)
	}))
}

func MoveArgStringVec(addresses []string) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_string_vec(FfiConverterSequenceStringINSTANCE.Lower(addresses),_uniffiStatus)
	}))
}

func MoveArgU128(value string) (*MoveArg, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u128(FfiConverterStringINSTANCE.Lower(value),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MoveArg
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveArgINSTANCE.Lift(_uniffiRV), nil
		}
}

func MoveArgU128Vec(values []string) (*MoveArg, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u128_vec(FfiConverterSequenceStringINSTANCE.Lower(values),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MoveArg
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveArgINSTANCE.Lift(_uniffiRV), nil
		}
}

func MoveArgU16(value uint16) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u16(FfiConverterUint16INSTANCE.Lower(value),_uniffiStatus)
	}))
}

func MoveArgU16Vec(values []uint16) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u16_vec(FfiConverterSequenceUint16INSTANCE.Lower(values),_uniffiStatus)
	}))
}

func MoveArgU256(value string) (*MoveArg, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u256(FfiConverterStringINSTANCE.Lower(value),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MoveArg
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveArgINSTANCE.Lift(_uniffiRV), nil
		}
}

func MoveArgU256Vec(values []string) (*MoveArg, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u256_vec(FfiConverterSequenceStringINSTANCE.Lower(values),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MoveArg
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveArgINSTANCE.Lift(_uniffiRV), nil
		}
}

func MoveArgU32(value uint32) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u32(FfiConverterUint32INSTANCE.Lower(value),_uniffiStatus)
	}))
}

func MoveArgU32Vec(values []uint32) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u32_vec(FfiConverterSequenceUint32INSTANCE.Lower(values),_uniffiStatus)
	}))
}

func MoveArgU64(value uint64) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u64(FfiConverterUint64INSTANCE.Lower(value),_uniffiStatus)
	}))
}

func MoveArgU64Vec(values []uint64) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u64_vec(FfiConverterSequenceUint64INSTANCE.Lower(values),_uniffiStatus)
	}))
}

func MoveArgU8(value uint8) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u8(FfiConverterUint8INSTANCE.Lower(value),_uniffiStatus)
	}))
}

func MoveArgU8Vec(values []byte) *MoveArg {
	return FfiConverterMoveArgINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movearg_u8_vec(FfiConverterBytesINSTANCE.Lower(values),_uniffiStatus)
	}))
}


func (object *MoveArg) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMoveArg struct {}

var FfiConverterMoveArgINSTANCE = FfiConverterMoveArg{}


func (c FfiConverterMoveArg) Lift(pointer unsafe.Pointer) *MoveArg {
	result := &MoveArg {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_movearg(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_movearg(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MoveArg).Destroy)
	return result
}

func (c FfiConverterMoveArg) Read(reader io.Reader) *MoveArg {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMoveArg) Lower(value *MoveArg) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MoveArg")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMoveArg) Write(writer io.Writer, value *MoveArg) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMoveArg struct {}

func (_ FfiDestroyerMoveArg) Destroy(value *MoveArg) {
		value.Destroy()
}



// Command to call a move function
//
// Functions that can be called by a `MoveCall` command are those that have a
// function signature that is either `entry` or `public` (which don't have a
// reference return type).
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// move-call = object-id           ; package id
// identifier          ; module name
// identifier          ; function name
// (vector type-tag)   ; type arguments, if any
// (vector argument)   ; input arguments
// ```
type MoveCallInterface interface {
	// The arguments to the function.
	Arguments() []*Argument
	// The function to be called.
	Function() *Identifier
	// The specific module in the package containing the function.
	Module() *Identifier
	// The package containing the module and function.
	Package() *ObjectId
	// The type arguments to the function.
	TypeArguments() []*TypeTag
}
// Command to call a move function
//
// Functions that can be called by a `MoveCall` command are those that have a
// function signature that is either `entry` or `public` (which don't have a
// reference return type).
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// move-call = object-id           ; package id
// identifier          ; module name
// identifier          ; function name
// (vector type-tag)   ; type arguments, if any
// (vector argument)   ; input arguments
// ```
type MoveCall struct {
	ffiObject FfiObject
}
func NewMoveCall(varPackage *ObjectId, module *Identifier, function *Identifier, typeArguments []*TypeTag, arguments []*Argument) *MoveCall {
	return FfiConverterMoveCallINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movecall_new(FfiConverterObjectIdINSTANCE.Lower(varPackage), FfiConverterIdentifierINSTANCE.Lower(module), FfiConverterIdentifierINSTANCE.Lower(function), FfiConverterSequenceTypeTagINSTANCE.Lower(typeArguments), FfiConverterSequenceArgumentINSTANCE.Lower(arguments),_uniffiStatus)
	}))
}




// The arguments to the function.
func (_self *MoveCall) Arguments() []*Argument {
	_pointer := _self.ffiObject.incrementPointer("*MoveCall")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movecall_arguments(
		_pointer,_uniffiStatus),
	}
	}))
}

// The function to be called.
func (_self *MoveCall) Function() *Identifier {
	_pointer := _self.ffiObject.incrementPointer("*MoveCall")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterIdentifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_movecall_function(
		_pointer,_uniffiStatus)
	}))
}

// The specific module in the package containing the function.
func (_self *MoveCall) Module() *Identifier {
	_pointer := _self.ffiObject.incrementPointer("*MoveCall")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterIdentifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_movecall_module(
		_pointer,_uniffiStatus)
	}))
}

// The package containing the module and function.
func (_self *MoveCall) Package() *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*MoveCall")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_movecall_package(
		_pointer,_uniffiStatus)
	}))
}

// The type arguments to the function.
func (_self *MoveCall) TypeArguments() []*TypeTag {
	_pointer := _self.ffiObject.incrementPointer("*MoveCall")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movecall_type_arguments(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *MoveCall) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMoveCall struct {}

var FfiConverterMoveCallINSTANCE = FfiConverterMoveCall{}


func (c FfiConverterMoveCall) Lift(pointer unsafe.Pointer) *MoveCall {
	result := &MoveCall {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_movecall(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_movecall(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MoveCall).Destroy)
	return result
}

func (c FfiConverterMoveCall) Read(reader io.Reader) *MoveCall {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMoveCall) Lower(value *MoveCall) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MoveCall")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMoveCall) Write(writer io.Writer, value *MoveCall) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMoveCall struct {}

func (_ FfiDestroyerMoveCall) Destroy(value *MoveCall) {
		value.Destroy()
}



type MoveFunctionInterface interface {
	IsEntry() bool
	Name() string
	Parameters() *[]OpenMoveType
	ReturnType() *[]OpenMoveType
	TypeParameters() *[]MoveFunctionTypeParameter
	Visibility() *MoveVisibility
}
type MoveFunction struct {
	ffiObject FfiObject
}




func (_self *MoveFunction) IsEntry() bool {
	_pointer := _self.ffiObject.incrementPointer("*MoveFunction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_movefunction_is_entry(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MoveFunction) Name() string {
	_pointer := _self.ffiObject.incrementPointer("*MoveFunction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movefunction_name(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MoveFunction) Parameters() *[]OpenMoveType {
	_pointer := _self.ffiObject.incrementPointer("*MoveFunction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSequenceOpenMoveTypeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movefunction_parameters(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MoveFunction) ReturnType() *[]OpenMoveType {
	_pointer := _self.ffiObject.incrementPointer("*MoveFunction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSequenceOpenMoveTypeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movefunction_return_type(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MoveFunction) TypeParameters() *[]MoveFunctionTypeParameter {
	_pointer := _self.ffiObject.incrementPointer("*MoveFunction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSequenceMoveFunctionTypeParameterINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movefunction_type_parameters(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MoveFunction) Visibility() *MoveVisibility {
	_pointer := _self.ffiObject.incrementPointer("*MoveFunction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalMoveVisibilityINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movefunction_visibility(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MoveFunction) String() string {
	_pointer := _self.ffiObject.incrementPointer("*MoveFunction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movefunction_uniffi_trait_display(
		_pointer,_uniffiStatus),
	}
	}))
}


func (object *MoveFunction) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMoveFunction struct {}

var FfiConverterMoveFunctionINSTANCE = FfiConverterMoveFunction{}


func (c FfiConverterMoveFunction) Lift(pointer unsafe.Pointer) *MoveFunction {
	result := &MoveFunction {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_movefunction(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_movefunction(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MoveFunction).Destroy)
	return result
}

func (c FfiConverterMoveFunction) Read(reader io.Reader) *MoveFunction {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMoveFunction) Lower(value *MoveFunction) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MoveFunction")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMoveFunction) Write(writer io.Writer, value *MoveFunction) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMoveFunction struct {}

func (_ FfiDestroyerMoveFunction) Destroy(value *MoveFunction) {
		value.Destroy()
}



// A move package
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object-move-package = object-id u64 move-modules type-origin-table linkage-table
//
// move-modules = map (identifier bytes)
// type-origin-table = vector type-origin
// linkage-table = map (object-id upgrade-info)
// ```
type MovePackageInterface interface {
	Id() *ObjectId
	LinkageTable() map[*ObjectId]UpgradeInfo
	Modules() map[*Identifier][]byte
	TypeOriginTable() []TypeOrigin
	Version() uint64
}
// A move package
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object-move-package = object-id u64 move-modules type-origin-table linkage-table
//
// move-modules = map (identifier bytes)
// type-origin-table = vector type-origin
// linkage-table = map (object-id upgrade-info)
// ```
type MovePackage struct {
	ffiObject FfiObject
}
func NewMovePackage(id *ObjectId, version uint64, modules map[*Identifier][]byte, typeOriginTable []TypeOrigin, linkageTable map[*ObjectId]UpgradeInfo) (*MovePackage, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movepackage_new(FfiConverterObjectIdINSTANCE.Lower(id), FfiConverterUint64INSTANCE.Lower(version), FfiConverterMapIdentifierBytesINSTANCE.Lower(modules), FfiConverterSequenceTypeOriginINSTANCE.Lower(typeOriginTable), FfiConverterMapObjectIdUpgradeInfoINSTANCE.Lower(linkageTable),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MovePackage
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMovePackageINSTANCE.Lift(_uniffiRV), nil
		}
}




func (_self *MovePackage) Id() *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*MovePackage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_movepackage_id(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MovePackage) LinkageTable() map[*ObjectId]UpgradeInfo {
	_pointer := _self.ffiObject.incrementPointer("*MovePackage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMapObjectIdUpgradeInfoINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movepackage_linkage_table(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MovePackage) Modules() map[*Identifier][]byte {
	_pointer := _self.ffiObject.incrementPointer("*MovePackage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMapIdentifierBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movepackage_modules(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MovePackage) TypeOriginTable() []TypeOrigin {
	_pointer := _self.ffiObject.incrementPointer("*MovePackage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceTypeOriginINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movepackage_type_origin_table(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MovePackage) Version() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*MovePackage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_movepackage_version(
		_pointer,_uniffiStatus)
	}))
}
func (object *MovePackage) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMovePackage struct {}

var FfiConverterMovePackageINSTANCE = FfiConverterMovePackage{}


func (c FfiConverterMovePackage) Lift(pointer unsafe.Pointer) *MovePackage {
	result := &MovePackage {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_movepackage(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_movepackage(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MovePackage).Destroy)
	return result
}

func (c FfiConverterMovePackage) Read(reader io.Reader) *MovePackage {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMovePackage) Lower(value *MovePackage) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MovePackage")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMovePackage) Write(writer io.Writer, value *MovePackage) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMovePackage struct {}

func (_ FfiDestroyerMovePackage) Destroy(value *MovePackage) {
		value.Destroy()
}



// Type corresponding to the output of `iota move build
// --dump-bytecode-as-base64`
type MovePackageDataInterface interface {
	// Returns the package dependencies.
	Dependencies() []*ObjectId
	// Returns the package digest.
	Digest() *Digest
	// Returns the package modules.
	Modules() [][]byte
	ToBase64() string
	ToJson() string
}
// Type corresponding to the output of `iota move build
// --dump-bytecode-as-base64`
type MovePackageData struct {
	ffiObject FfiObject
}
func NewMovePackageData(modules [][]byte, dependencies []*ObjectId) *MovePackageData {
	return FfiConverterMovePackageDataINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_new(FfiConverterSequenceBytesINSTANCE.Lower(modules), FfiConverterSequenceObjectIdINSTANCE.Lower(dependencies),_uniffiStatus)
	}))
}


func MovePackageDataFromBase64(base64 string) (*MovePackageData, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_from_base64(FfiConverterStringINSTANCE.Lower(base64),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MovePackageData
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMovePackageDataINSTANCE.Lift(_uniffiRV), nil
		}
}

func MovePackageDataFromJson(json string) (*MovePackageData, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_from_json(FfiConverterStringINSTANCE.Lower(json),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MovePackageData
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMovePackageDataINSTANCE.Lift(_uniffiRV), nil
		}
}



// Returns the package dependencies.
func (_self *MovePackageData) Dependencies() []*ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*MovePackageData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movepackagedata_dependencies(
		_pointer,_uniffiStatus),
	}
	}))
}

// Returns the package digest.
func (_self *MovePackageData) Digest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*MovePackageData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_movepackagedata_digest(
		_pointer,_uniffiStatus)
	}))
}

// Returns the package modules.
func (_self *MovePackageData) Modules() [][]byte {
	_pointer := _self.ffiObject.incrementPointer("*MovePackageData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movepackagedata_modules(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MovePackageData) ToBase64() string {
	_pointer := _self.ffiObject.incrementPointer("*MovePackageData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movepackagedata_to_base64(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MovePackageData) ToJson() string {
	_pointer := _self.ffiObject.incrementPointer("*MovePackageData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_movepackagedata_to_json(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *MovePackageData) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMovePackageData struct {}

var FfiConverterMovePackageDataINSTANCE = FfiConverterMovePackageData{}


func (c FfiConverterMovePackageData) Lift(pointer unsafe.Pointer) *MovePackageData {
	result := &MovePackageData {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_movepackagedata(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_movepackagedata(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MovePackageData).Destroy)
	return result
}

func (c FfiConverterMovePackageData) Read(reader io.Reader) *MovePackageData {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMovePackageData) Lower(value *MovePackageData) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MovePackageData")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMovePackageData) Write(writer io.Writer, value *MovePackageData) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMovePackageData struct {}

func (_ FfiDestroyerMovePackageData) Destroy(value *MovePackageData) {
		value.Destroy()
}



// Aggregated signature from members of a multisig committee.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-aggregated-signature = (vector multisig-member-signature)
// u16     ; bitmap
// multisig-committee
// ```
//
// There is also a legacy encoding for this type defined as:
//
// ```text
// legacy-multisig-aggregated-signature = (vector multisig-member-signature)
// roaring-bitmap   ; bitmap
// legacy-multisig-committee
// roaring-bitmap = bytes  ; where the contents of the bytes are valid
// ; according to the serialized spec for
// ; roaring bitmaps
// ```
//
// See <https://github.com/RoaringBitmap/RoaringFormatSpec> for the specification for the
// serialized format of RoaringBitmaps.
type MultisigAggregatedSignatureInterface interface {
	// The bitmap that indicates which committee members provided their
	// signature.
	Bitmap() uint16
	Committee() *MultisigCommittee
	// The list of signatures from committee members
	Signatures() []*MultisigMemberSignature
}
// Aggregated signature from members of a multisig committee.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-aggregated-signature = (vector multisig-member-signature)
// u16     ; bitmap
// multisig-committee
// ```
//
// There is also a legacy encoding for this type defined as:
//
// ```text
// legacy-multisig-aggregated-signature = (vector multisig-member-signature)
// roaring-bitmap   ; bitmap
// legacy-multisig-committee
// roaring-bitmap = bytes  ; where the contents of the bytes are valid
// ; according to the serialized spec for
// ; roaring bitmaps
// ```
//
// See <https://github.com/RoaringBitmap/RoaringFormatSpec> for the specification for the
// serialized format of RoaringBitmaps.
type MultisigAggregatedSignature struct {
	ffiObject FfiObject
}
// Construct a new aggregated multisig signature.
//
// Since the list of signatures doesn't contain sufficient information to
// identify which committee member provided the signature, it is up to
// the caller to ensure that the provided signature list is in the same
// order as it's corresponding member in the provided committee
// and that it's position in the provided bitmap is set.
func NewMultisigAggregatedSignature(committee *MultisigCommittee, signatures []*MultisigMemberSignature, bitmap uint16) *MultisigAggregatedSignature {
	return FfiConverterMultisigAggregatedSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregatedsignature_new(FfiConverterMultisigCommitteeINSTANCE.Lower(committee), FfiConverterSequenceMultisigMemberSignatureINSTANCE.Lower(signatures), FfiConverterUint16INSTANCE.Lower(bitmap),_uniffiStatus)
	}))
}




// The bitmap that indicates which committee members provided their
// signature.
func (_self *MultisigAggregatedSignature) Bitmap() uint16 {
	_pointer := _self.ffiObject.incrementPointer("*MultisigAggregatedSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint16INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_bitmap(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigAggregatedSignature) Committee() *MultisigCommittee {
	_pointer := _self.ffiObject.incrementPointer("*MultisigAggregatedSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMultisigCommitteeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_committee(
		_pointer,_uniffiStatus)
	}))
}

// The list of signatures from committee members
func (_self *MultisigAggregatedSignature) Signatures() []*MultisigMemberSignature {
	_pointer := _self.ffiObject.incrementPointer("*MultisigAggregatedSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceMultisigMemberSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_signatures(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *MultisigAggregatedSignature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMultisigAggregatedSignature struct {}

var FfiConverterMultisigAggregatedSignatureINSTANCE = FfiConverterMultisigAggregatedSignature{}


func (c FfiConverterMultisigAggregatedSignature) Lift(pointer unsafe.Pointer) *MultisigAggregatedSignature {
	result := &MultisigAggregatedSignature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_multisigaggregatedsignature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_multisigaggregatedsignature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MultisigAggregatedSignature).Destroy)
	return result
}

func (c FfiConverterMultisigAggregatedSignature) Read(reader io.Reader) *MultisigAggregatedSignature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMultisigAggregatedSignature) Lower(value *MultisigAggregatedSignature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MultisigAggregatedSignature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMultisigAggregatedSignature) Write(writer io.Writer, value *MultisigAggregatedSignature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMultisigAggregatedSignature struct {}

func (_ FfiDestroyerMultisigAggregatedSignature) Destroy(value *MultisigAggregatedSignature) {
		value.Destroy()
}



type MultisigAggregatorInterface interface {
	Finish() (*MultisigAggregatedSignature, error)
	Verifier() *MultisigVerifier
	WithSignature(signature *UserSignature) (*MultisigAggregator, error)
	WithVerifier(verifier *MultisigVerifier) *MultisigAggregator
}
type MultisigAggregator struct {
	ffiObject FfiObject
}


func MultisigAggregatorNewWithMessage(committee *MultisigCommittee, message []byte) *MultisigAggregator {
	return FfiConverterMultisigAggregatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregator_new_with_message(FfiConverterMultisigCommitteeINSTANCE.Lower(committee), FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	}))
}

func MultisigAggregatorNewWithTransaction(committee *MultisigCommittee, transaction *Transaction) *MultisigAggregator {
	return FfiConverterMultisigAggregatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregator_new_with_transaction(FfiConverterMultisigCommitteeINSTANCE.Lower(committee), FfiConverterTransactionINSTANCE.Lower(transaction),_uniffiStatus)
	}))
}



func (_self *MultisigAggregator) Finish() (*MultisigAggregatedSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*MultisigAggregator")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_finish(
		_pointer,_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MultisigAggregatedSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMultisigAggregatedSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *MultisigAggregator) Verifier() *MultisigVerifier {
	_pointer := _self.ffiObject.incrementPointer("*MultisigAggregator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMultisigVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_verifier(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigAggregator) WithSignature(signature *UserSignature) (*MultisigAggregator, error) {
	_pointer := _self.ffiObject.incrementPointer("*MultisigAggregator")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_with_signature(
		_pointer,FfiConverterUserSignatureINSTANCE.Lower(signature),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MultisigAggregator
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMultisigAggregatorINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *MultisigAggregator) WithVerifier(verifier *MultisigVerifier) *MultisigAggregator {
	_pointer := _self.ffiObject.incrementPointer("*MultisigAggregator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMultisigAggregatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_with_verifier(
		_pointer,FfiConverterMultisigVerifierINSTANCE.Lower(verifier),_uniffiStatus)
	}))
}
func (object *MultisigAggregator) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMultisigAggregator struct {}

var FfiConverterMultisigAggregatorINSTANCE = FfiConverterMultisigAggregator{}


func (c FfiConverterMultisigAggregator) Lift(pointer unsafe.Pointer) *MultisigAggregator {
	result := &MultisigAggregator {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_multisigaggregator(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_multisigaggregator(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MultisigAggregator).Destroy)
	return result
}

func (c FfiConverterMultisigAggregator) Read(reader io.Reader) *MultisigAggregator {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMultisigAggregator) Lower(value *MultisigAggregator) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MultisigAggregator")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMultisigAggregator) Write(writer io.Writer, value *MultisigAggregator) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMultisigAggregator struct {}

func (_ FfiDestroyerMultisigAggregator) Destroy(value *MultisigAggregator) {
		value.Destroy()
}



// A multisig committee
//
// A `MultisigCommittee` is a set of members who collectively control a single
// `Address` on the IOTA blockchain. The number of required signatures to
// authorize the execution of a transaction is determined by
// `(signature_0_weight + signature_1_weight ..) >= threshold`.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-committee = (vector multisig-member)
// u16    ; threshold
// ```
//
// There is also a legacy encoding for this type defined as:
//
// ```text
// legacy-multisig-committee = (vector legacy-multisig-member)
// u16     ; threshold
// ```
type MultisigCommitteeInterface interface {
	// Derive an `Address` from this MultisigCommittee.
	//
	// A MultiSig address
	// is defined as the 32-byte Blake2b hash of serializing the
	// `SignatureScheme` flag (0x03), the threshold (in little endian), and
	// the concatenation of all n flag, public keys and its weight.
	//
	// `hash(0x03 || threshold || flag_1 || pk_1 || weight_1
	// || ... || flag_n || pk_n || weight_n)`.
	//
	// When flag_i is ZkLogin, the pk_i for the `ZkLoginPublicIdentifier`
	// refers to the same input used when deriving the address using the
	// `ZkLoginPublicIdentifier::derive_address_padded` method (using the
	// full 32-byte `address_seed` value).
	DeriveAddress() *Address
	// Checks if the Committee is valid.
	//
	// A valid committee is one that:
	// - Has a nonzero threshold
	// - Has at least one member
	// - Has at most ten members
	// - No member has weight 0
	// - the sum of the weights of all members must be larger than the
	// threshold
	// - contains no duplicate members
	IsValid() bool
	// The members of the committee
	Members() []*MultisigMember
	// Return the flag for this signature scheme
	Scheme() SignatureScheme
	// The total signature weight required to authorize a transaction for the
	// address corresponding to this `MultisigCommittee`.
	Threshold() uint16
}
// A multisig committee
//
// A `MultisigCommittee` is a set of members who collectively control a single
// `Address` on the IOTA blockchain. The number of required signatures to
// authorize the execution of a transaction is determined by
// `(signature_0_weight + signature_1_weight ..) >= threshold`.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-committee = (vector multisig-member)
// u16    ; threshold
// ```
//
// There is also a legacy encoding for this type defined as:
//
// ```text
// legacy-multisig-committee = (vector legacy-multisig-member)
// u16     ; threshold
// ```
type MultisigCommittee struct {
	ffiObject FfiObject
}
// Construct a new committee from a list of `MultisigMember`s and a
// `threshold`.
//
// Note that the order of the members is significant towards deriving the
// `Address` governed by this committee.
func NewMultisigCommittee(members []*MultisigMember, threshold uint16) *MultisigCommittee {
	return FfiConverterMultisigCommitteeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_multisigcommittee_new(FfiConverterSequenceMultisigMemberINSTANCE.Lower(members), FfiConverterUint16INSTANCE.Lower(threshold),_uniffiStatus)
	}))
}




// Derive an `Address` from this MultisigCommittee.
//
// A MultiSig address
// is defined as the 32-byte Blake2b hash of serializing the
// `SignatureScheme` flag (0x03), the threshold (in little endian), and
// the concatenation of all n flag, public keys and its weight.
//
// `hash(0x03 || threshold || flag_1 || pk_1 || weight_1
// || ... || flag_n || pk_n || weight_n)`.
//
// When flag_i is ZkLogin, the pk_i for the `ZkLoginPublicIdentifier`
// refers to the same input used when deriving the address using the
// `ZkLoginPublicIdentifier::derive_address_padded` method (using the
// full 32-byte `address_seed` value).
func (_self *MultisigCommittee) DeriveAddress() *Address {
	_pointer := _self.ffiObject.incrementPointer("*MultisigCommittee")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_derive_address(
		_pointer,_uniffiStatus)
	}))
}

// Checks if the Committee is valid.
//
// A valid committee is one that:
// - Has a nonzero threshold
// - Has at least one member
// - Has at most ten members
// - No member has weight 0
// - the sum of the weights of all members must be larger than the
// threshold
// - contains no duplicate members
func (_self *MultisigCommittee) IsValid() bool {
	_pointer := _self.ffiObject.incrementPointer("*MultisigCommittee")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_is_valid(
		_pointer,_uniffiStatus)
	}))
}

// The members of the committee
func (_self *MultisigCommittee) Members() []*MultisigMember {
	_pointer := _self.ffiObject.incrementPointer("*MultisigCommittee")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceMultisigMemberINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_members(
		_pointer,_uniffiStatus),
	}
	}))
}

// Return the flag for this signature scheme
func (_self *MultisigCommittee) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*MultisigCommittee")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

// The total signature weight required to authorize a transaction for the
// address corresponding to this `MultisigCommittee`.
func (_self *MultisigCommittee) Threshold() uint16 {
	_pointer := _self.ffiObject.incrementPointer("*MultisigCommittee")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint16INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_threshold(
		_pointer,_uniffiStatus)
	}))
}
func (object *MultisigCommittee) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMultisigCommittee struct {}

var FfiConverterMultisigCommitteeINSTANCE = FfiConverterMultisigCommittee{}


func (c FfiConverterMultisigCommittee) Lift(pointer unsafe.Pointer) *MultisigCommittee {
	result := &MultisigCommittee {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_multisigcommittee(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_multisigcommittee(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MultisigCommittee).Destroy)
	return result
}

func (c FfiConverterMultisigCommittee) Read(reader io.Reader) *MultisigCommittee {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMultisigCommittee) Lower(value *MultisigCommittee) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MultisigCommittee")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMultisigCommittee) Write(writer io.Writer, value *MultisigCommittee) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMultisigCommittee struct {}

func (_ FfiDestroyerMultisigCommittee) Destroy(value *MultisigCommittee) {
		value.Destroy()
}



// A member in a multisig committee
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-member = multisig-member-public-key
// u8    ; weight
// ```
//
// There is also a legacy encoding for this type defined as:
//
// ```text
// legacy-multisig-member = legacy-multisig-member-public-key
// u8     ; weight
// ```
type MultisigMemberInterface interface {
	// This member's public key.
	PublicKey() *MultisigMemberPublicKey
	// Weight of this member's signature.
	Weight() uint8
}
// A member in a multisig committee
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-member = multisig-member-public-key
// u8    ; weight
// ```
//
// There is also a legacy encoding for this type defined as:
//
// ```text
// legacy-multisig-member = legacy-multisig-member-public-key
// u8     ; weight
// ```
type MultisigMember struct {
	ffiObject FfiObject
}
// Construct a new member from a `MultisigMemberPublicKey` and a `weight`.
func NewMultisigMember(publicKey *MultisigMemberPublicKey, weight uint8) *MultisigMember {
	return FfiConverterMultisigMemberINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_multisigmember_new(FfiConverterMultisigMemberPublicKeyINSTANCE.Lower(publicKey), FfiConverterUint8INSTANCE.Lower(weight),_uniffiStatus)
	}))
}




// This member's public key.
func (_self *MultisigMember) PublicKey() *MultisigMemberPublicKey {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMember")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMultisigMemberPublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmember_public_key(
		_pointer,_uniffiStatus)
	}))
}

// Weight of this member's signature.
func (_self *MultisigMember) Weight() uint8 {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMember")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint8INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmember_weight(
		_pointer,_uniffiStatus)
	}))
}
func (object *MultisigMember) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMultisigMember struct {}

var FfiConverterMultisigMemberINSTANCE = FfiConverterMultisigMember{}


func (c FfiConverterMultisigMember) Lift(pointer unsafe.Pointer) *MultisigMember {
	result := &MultisigMember {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_multisigmember(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_multisigmember(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MultisigMember).Destroy)
	return result
}

func (c FfiConverterMultisigMember) Read(reader io.Reader) *MultisigMember {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMultisigMember) Lower(value *MultisigMember) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MultisigMember")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMultisigMember) Write(writer io.Writer, value *MultisigMember) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMultisigMember struct {}

func (_ FfiDestroyerMultisigMember) Destroy(value *MultisigMember) {
		value.Destroy()
}



// Enum of valid public keys for multisig committee members
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-member-public-key = ed25519-multisig-member-public-key /
// secp256k1-multisig-member-public-key /
// secp256r1-multisig-member-public-key /
// zklogin-multisig-member-public-key
//
// ed25519-multisig-member-public-key   = %x00 ed25519-public-key
// secp256k1-multisig-member-public-key = %x01 secp256k1-public-key
// secp256r1-multisig-member-public-key = %x02 secp256r1-public-key
// zklogin-multisig-member-public-key   = %x03 zklogin-public-identifier
// ```
//
// There is also a legacy encoding for this type defined as:
//
// ```text
// legacy-multisig-member-public-key = string ; which is valid base64 encoded
// ; and the decoded bytes are defined
// ; by legacy-public-key
// legacy-public-key = (ed25519-flag ed25519-public-key) /
// (secp256k1-flag secp256k1-public-key) /
// (secp256r1-flag secp256r1-public-key)
// ```
type MultisigMemberPublicKeyInterface interface {
	AsEd25519() *Ed25519PublicKey
	AsEd25519Opt() **Ed25519PublicKey
	AsSecp256k1() *Secp256k1PublicKey
	AsSecp256k1Opt() **Secp256k1PublicKey
	AsSecp256r1() *Secp256r1PublicKey
	AsSecp256r1Opt() **Secp256r1PublicKey
	AsZklogin() *ZkLoginPublicIdentifier
	AsZkloginOpt() **ZkLoginPublicIdentifier
	IsEd25519() bool
	IsSecp256k1() bool
	IsSecp256r1() bool
	IsZklogin() bool
}
// Enum of valid public keys for multisig committee members
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-member-public-key = ed25519-multisig-member-public-key /
// secp256k1-multisig-member-public-key /
// secp256r1-multisig-member-public-key /
// zklogin-multisig-member-public-key
//
// ed25519-multisig-member-public-key   = %x00 ed25519-public-key
// secp256k1-multisig-member-public-key = %x01 secp256k1-public-key
// secp256r1-multisig-member-public-key = %x02 secp256r1-public-key
// zklogin-multisig-member-public-key   = %x03 zklogin-public-identifier
// ```
//
// There is also a legacy encoding for this type defined as:
//
// ```text
// legacy-multisig-member-public-key = string ; which is valid base64 encoded
// ; and the decoded bytes are defined
// ; by legacy-public-key
// legacy-public-key = (ed25519-flag ed25519-public-key) /
// (secp256k1-flag secp256k1-public-key) /
// (secp256r1-flag secp256r1-public-key)
// ```
type MultisigMemberPublicKey struct {
	ffiObject FfiObject
}




func (_self *MultisigMemberPublicKey) AsEd25519() *Ed25519PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterEd25519PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_ed25519(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberPublicKey) AsEd25519Opt() **Ed25519PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalEd25519PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_ed25519_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MultisigMemberPublicKey) AsSecp256k1() *Secp256k1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256k1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256k1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberPublicKey) AsSecp256k1Opt() **Secp256k1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSecp256k1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256k1_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MultisigMemberPublicKey) AsSecp256r1() *Secp256r1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256r1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256r1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberPublicKey) AsSecp256r1Opt() **Secp256r1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSecp256r1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256r1_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MultisigMemberPublicKey) AsZklogin() *ZkLoginPublicIdentifier {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterZkLoginPublicIdentifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_zklogin(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberPublicKey) AsZkloginOpt() **ZkLoginPublicIdentifier {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalZkLoginPublicIdentifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_zklogin_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MultisigMemberPublicKey) IsEd25519() bool {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_ed25519(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberPublicKey) IsSecp256k1() bool {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_secp256k1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberPublicKey) IsSecp256r1() bool {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_secp256r1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberPublicKey) IsZklogin() bool {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_zklogin(
		_pointer,_uniffiStatus)
	}))
}
func (object *MultisigMemberPublicKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMultisigMemberPublicKey struct {}

var FfiConverterMultisigMemberPublicKeyINSTANCE = FfiConverterMultisigMemberPublicKey{}


func (c FfiConverterMultisigMemberPublicKey) Lift(pointer unsafe.Pointer) *MultisigMemberPublicKey {
	result := &MultisigMemberPublicKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_multisigmemberpublickey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_multisigmemberpublickey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MultisigMemberPublicKey).Destroy)
	return result
}

func (c FfiConverterMultisigMemberPublicKey) Read(reader io.Reader) *MultisigMemberPublicKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMultisigMemberPublicKey) Lower(value *MultisigMemberPublicKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MultisigMemberPublicKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMultisigMemberPublicKey) Write(writer io.Writer, value *MultisigMemberPublicKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMultisigMemberPublicKey struct {}

func (_ FfiDestroyerMultisigMemberPublicKey) Destroy(value *MultisigMemberPublicKey) {
		value.Destroy()
}



// A signature from a member of a multisig committee.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-member-signature = ed25519-multisig-member-signature /
// secp256k1-multisig-member-signature /
// secp256r1-multisig-member-signature /
// zklogin-multisig-member-signature
//
// ed25519-multisig-member-signature   = %x00 ed25519-signature
// secp256k1-multisig-member-signature = %x01 secp256k1-signature
// secp256r1-multisig-member-signature = %x02 secp256r1-signature
// zklogin-multisig-member-signature   = %x03 zklogin-authenticator
// ```
type MultisigMemberSignatureInterface interface {
	AsEd25519() *Ed25519Signature
	AsEd25519Opt() **Ed25519Signature
	AsSecp256k1() *Secp256k1Signature
	AsSecp256k1Opt() **Secp256k1Signature
	AsSecp256r1() *Secp256r1Signature
	AsSecp256r1Opt() **Secp256r1Signature
	AsZklogin() *ZkLoginAuthenticator
	AsZkloginOpt() **ZkLoginAuthenticator
	IsEd25519() bool
	IsSecp256k1() bool
	IsSecp256r1() bool
	IsZklogin() bool
}
// A signature from a member of a multisig committee.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// multisig-member-signature = ed25519-multisig-member-signature /
// secp256k1-multisig-member-signature /
// secp256r1-multisig-member-signature /
// zklogin-multisig-member-signature
//
// ed25519-multisig-member-signature   = %x00 ed25519-signature
// secp256k1-multisig-member-signature = %x01 secp256k1-signature
// secp256r1-multisig-member-signature = %x02 secp256r1-signature
// zklogin-multisig-member-signature   = %x03 zklogin-authenticator
// ```
type MultisigMemberSignature struct {
	ffiObject FfiObject
}




func (_self *MultisigMemberSignature) AsEd25519() *Ed25519Signature {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterEd25519SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_ed25519(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberSignature) AsEd25519Opt() **Ed25519Signature {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalEd25519SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_ed25519_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MultisigMemberSignature) AsSecp256k1() *Secp256k1Signature {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256k1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256k1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberSignature) AsSecp256k1Opt() **Secp256k1Signature {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSecp256k1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256k1_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MultisigMemberSignature) AsSecp256r1() *Secp256r1Signature {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256r1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256r1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberSignature) AsSecp256r1Opt() **Secp256r1Signature {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSecp256r1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256r1_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MultisigMemberSignature) AsZklogin() *ZkLoginAuthenticator {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterZkLoginAuthenticatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_zklogin(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberSignature) AsZkloginOpt() **ZkLoginAuthenticator {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalZkLoginAuthenticatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_zklogin_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *MultisigMemberSignature) IsEd25519() bool {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_ed25519(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberSignature) IsSecp256k1() bool {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_secp256k1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberSignature) IsSecp256r1() bool {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_secp256r1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *MultisigMemberSignature) IsZklogin() bool {
	_pointer := _self.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_zklogin(
		_pointer,_uniffiStatus)
	}))
}
func (object *MultisigMemberSignature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMultisigMemberSignature struct {}

var FfiConverterMultisigMemberSignatureINSTANCE = FfiConverterMultisigMemberSignature{}


func (c FfiConverterMultisigMemberSignature) Lift(pointer unsafe.Pointer) *MultisigMemberSignature {
	result := &MultisigMemberSignature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_multisigmembersignature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_multisigmembersignature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MultisigMemberSignature).Destroy)
	return result
}

func (c FfiConverterMultisigMemberSignature) Read(reader io.Reader) *MultisigMemberSignature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMultisigMemberSignature) Lower(value *MultisigMemberSignature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MultisigMemberSignature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMultisigMemberSignature) Write(writer io.Writer, value *MultisigMemberSignature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMultisigMemberSignature struct {}

func (_ FfiDestroyerMultisigMemberSignature) Destroy(value *MultisigMemberSignature) {
		value.Destroy()
}



type MultisigVerifierInterface interface {
	Verify(message []byte, signature *MultisigAggregatedSignature) error
	WithZkloginVerifier(zkloginVerifier *ZkloginVerifier) *MultisigVerifier
	ZkloginVerifier() **ZkloginVerifier
}
type MultisigVerifier struct {
	ffiObject FfiObject
}
func NewMultisigVerifier() *MultisigVerifier {
	return FfiConverterMultisigVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_multisigverifier_new(_uniffiStatus)
	}))
}




func (_self *MultisigVerifier) Verify(message []byte, signature *MultisigAggregatedSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*MultisigVerifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_multisigverifier_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterMultisigAggregatedSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *MultisigVerifier) WithZkloginVerifier(zkloginVerifier *ZkloginVerifier) *MultisigVerifier {
	_pointer := _self.ffiObject.incrementPointer("*MultisigVerifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMultisigVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_multisigverifier_with_zklogin_verifier(
		_pointer,FfiConverterZkloginVerifierINSTANCE.Lower(zkloginVerifier),_uniffiStatus)
	}))
}

func (_self *MultisigVerifier) ZkloginVerifier() **ZkloginVerifier {
	_pointer := _self.ffiObject.incrementPointer("*MultisigVerifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalZkloginVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_multisigverifier_zklogin_verifier(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *MultisigVerifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMultisigVerifier struct {}

var FfiConverterMultisigVerifierINSTANCE = FfiConverterMultisigVerifier{}


func (c FfiConverterMultisigVerifier) Lift(pointer unsafe.Pointer) *MultisigVerifier {
	result := &MultisigVerifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_multisigverifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_multisigverifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MultisigVerifier).Destroy)
	return result
}

func (c FfiConverterMultisigVerifier) Read(reader io.Reader) *MultisigVerifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMultisigVerifier) Lower(value *MultisigVerifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MultisigVerifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMultisigVerifier) Write(writer io.Writer, value *MultisigVerifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMultisigVerifier struct {}

func (_ FfiDestroyerMultisigVerifier) Destroy(value *MultisigVerifier) {
		value.Destroy()
}



type NameInterface interface {
	// Formats a name into a string based on the available output formats.
	// The default separator is `.`
	Format(format NameFormat) string
	// Returns whether this name is a second-level name (Ex. `test.iota`)
	IsSln() bool
	// Returns whether this name is a subname (Ex. `sub.test.iota`)
	IsSubname() bool
	// Get the label at the given index
	Label(index uint32) *string
	// Get all of the labels. NOTE: These are in reverse order starting with
	// the top-level name and proceeding to subnames.
	Labels() []string
	// Returns the number of labels including TLN.
	NumLabels() uint32
	// parents; second-level names return `None`.
	Parent() **Name
}
type Name struct {
	ffiObject FfiObject
}


func NameFromStr(s string) (*Name, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_name_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Name
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterNameINSTANCE.Lift(_uniffiRV), nil
		}
}



// Formats a name into a string based on the available output formats.
// The default separator is `.`
func (_self *Name) Format(format NameFormat) string {
	_pointer := _self.ffiObject.incrementPointer("*Name")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_name_format(
		_pointer,FfiConverterNameFormatINSTANCE.Lower(format),_uniffiStatus),
	}
	}))
}

// Returns whether this name is a second-level name (Ex. `test.iota`)
func (_self *Name) IsSln() bool {
	_pointer := _self.ffiObject.incrementPointer("*Name")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_name_is_sln(
		_pointer,_uniffiStatus)
	}))
}

// Returns whether this name is a subname (Ex. `sub.test.iota`)
func (_self *Name) IsSubname() bool {
	_pointer := _self.ffiObject.incrementPointer("*Name")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_name_is_subname(
		_pointer,_uniffiStatus)
	}))
}

// Get the label at the given index
func (_self *Name) Label(index uint32) *string {
	_pointer := _self.ffiObject.incrementPointer("*Name")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_name_label(
		_pointer,FfiConverterUint32INSTANCE.Lower(index),_uniffiStatus),
	}
	}))
}

// Get all of the labels. NOTE: These are in reverse order starting with
// the top-level name and proceeding to subnames.
func (_self *Name) Labels() []string {
	_pointer := _self.ffiObject.incrementPointer("*Name")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_name_labels(
		_pointer,_uniffiStatus),
	}
	}))
}

// Returns the number of labels including TLN.
func (_self *Name) NumLabels() uint32 {
	_pointer := _self.ffiObject.incrementPointer("*Name")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint32INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint32_t {
		return C.uniffi_iota_sdk_ffi_fn_method_name_num_labels(
		_pointer,_uniffiStatus)
	}))
}

// parents; second-level names return `None`.
func (_self *Name) Parent() **Name {
	_pointer := _self.ffiObject.incrementPointer("*Name")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalNameINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_name_parent(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Name) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterName struct {}

var FfiConverterNameINSTANCE = FfiConverterName{}


func (c FfiConverterName) Lift(pointer unsafe.Pointer) *Name {
	result := &Name {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_name(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_name(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Name).Destroy)
	return result
}

func (c FfiConverterName) Read(reader io.Reader) *Name {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterName) Lower(value *Name) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Name")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterName) Write(writer io.Writer, value *Name) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerName struct {}

func (_ FfiDestroyerName) Destroy(value *Name) {
		value.Destroy()
}



// An object to manage a second-level name (SLN).
type NameRegistrationInterface interface {
	ExpirationTimestampMs() uint64
	Id() *ObjectId
	Name() *Name
	NameStr() string
}
// An object to manage a second-level name (SLN).
type NameRegistration struct {
	ffiObject FfiObject
}
func NewNameRegistration(id *ObjectId, name *Name, nameStr string, expirationTimestampMs uint64) *NameRegistration {
	return FfiConverterNameRegistrationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_nameregistration_new(FfiConverterObjectIdINSTANCE.Lower(id), FfiConverterNameINSTANCE.Lower(name), FfiConverterStringINSTANCE.Lower(nameStr), FfiConverterUint64INSTANCE.Lower(expirationTimestampMs),_uniffiStatus)
	}))
}




func (_self *NameRegistration) ExpirationTimestampMs() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*NameRegistration")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_nameregistration_expiration_timestamp_ms(
		_pointer,_uniffiStatus)
	}))
}

func (_self *NameRegistration) Id() *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*NameRegistration")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_nameregistration_id(
		_pointer,_uniffiStatus)
	}))
}

func (_self *NameRegistration) Name() *Name {
	_pointer := _self.ffiObject.incrementPointer("*NameRegistration")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterNameINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_nameregistration_name(
		_pointer,_uniffiStatus)
	}))
}

func (_self *NameRegistration) NameStr() string {
	_pointer := _self.ffiObject.incrementPointer("*NameRegistration")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_nameregistration_name_str(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *NameRegistration) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterNameRegistration struct {}

var FfiConverterNameRegistrationINSTANCE = FfiConverterNameRegistration{}


func (c FfiConverterNameRegistration) Lift(pointer unsafe.Pointer) *NameRegistration {
	result := &NameRegistration {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_nameregistration(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_nameregistration(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*NameRegistration).Destroy)
	return result
}

func (c FfiConverterNameRegistration) Read(reader io.Reader) *NameRegistration {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterNameRegistration) Lower(value *NameRegistration) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*NameRegistration")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterNameRegistration) Write(writer io.Writer, value *NameRegistration) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerNameRegistration struct {}

func (_ FfiDestroyerNameRegistration) Destroy(value *NameRegistration) {
		value.Destroy()
}



// An object on the IOTA blockchain
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object = object-data owner digest u64
// ```
type ObjectInterface interface {
	// Interpret this object as a move package
	AsPackage() *MovePackage
	// Try to interpret this object as a move package
	AsPackageOpt() **MovePackage
	// Interpret this object as a move struct
	AsStruct() MoveStruct
	// Try to interpret this object as a move struct
	AsStructOpt() *MoveStruct
	// Return this object's data
	Data() *ObjectData
	// Calculate the digest of this `Object`
	//
	// This is done by hashing the BCS bytes of this `Object` prefixed
	Digest() *Digest
	// Return this object's id
	ObjectId() *ObjectId
	// Return this object's reference
	ObjectRef() ObjectReference
	// Return this object's type
	ObjectType() *ObjectType
	// Return this object's owner
	Owner() *Owner
	// Return the digest of the transaction that last modified this object
	PreviousTransaction() *Digest
	// Return the storage rebate locked in this object
	//
	// Storage rebates are credited to the gas coin used in a transaction that
	// deletes this object.
	StorageRebate() uint64
	// Return this object's version
	Version() uint64
}
// An object on the IOTA blockchain
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object = object-data owner digest u64
// ```
type Object struct {
	ffiObject FfiObject
}
func NewObject(data *ObjectData, owner *Owner, previousTransaction *Digest, storageRebate uint64) *Object {
	return FfiConverterObjectINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_object_new(FfiConverterObjectDataINSTANCE.Lower(data), FfiConverterOwnerINSTANCE.Lower(owner), FfiConverterDigestINSTANCE.Lower(previousTransaction), FfiConverterUint64INSTANCE.Lower(storageRebate),_uniffiStatus)
	}))
}




// Interpret this object as a move package
func (_self *Object) AsPackage() *MovePackage {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMovePackageINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_object_as_package(
		_pointer,_uniffiStatus)
	}))
}

// Try to interpret this object as a move package
func (_self *Object) AsPackageOpt() **MovePackage {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalMovePackageINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_object_as_package_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

// Interpret this object as a move struct
func (_self *Object) AsStruct() MoveStruct {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMoveStructINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_object_as_struct(
		_pointer,_uniffiStatus),
	}
	}))
}

// Try to interpret this object as a move struct
func (_self *Object) AsStructOpt() *MoveStruct {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalMoveStructINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_object_as_struct_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

// Return this object's data
func (_self *Object) Data() *ObjectData {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectDataINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_object_data(
		_pointer,_uniffiStatus)
	}))
}

// Calculate the digest of this `Object`
//
// This is done by hashing the BCS bytes of this `Object` prefixed
func (_self *Object) Digest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_object_digest(
		_pointer,_uniffiStatus)
	}))
}

// Return this object's id
func (_self *Object) ObjectId() *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_object_object_id(
		_pointer,_uniffiStatus)
	}))
}

// Return this object's reference
func (_self *Object) ObjectRef() ObjectReference {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectReferenceINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_object_object_ref(
		_pointer,_uniffiStatus),
	}
	}))
}

// Return this object's type
func (_self *Object) ObjectType() *ObjectType {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectTypeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_object_object_type(
		_pointer,_uniffiStatus)
	}))
}

// Return this object's owner
func (_self *Object) Owner() *Owner {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOwnerINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_object_owner(
		_pointer,_uniffiStatus)
	}))
}

// Return the digest of the transaction that last modified this object
func (_self *Object) PreviousTransaction() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_object_previous_transaction(
		_pointer,_uniffiStatus)
	}))
}

// Return the storage rebate locked in this object
//
// Storage rebates are credited to the gas coin used in a transaction that
// deletes this object.
func (_self *Object) StorageRebate() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_object_storage_rebate(
		_pointer,_uniffiStatus)
	}))
}

// Return this object's version
func (_self *Object) Version() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*Object")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_object_version(
		_pointer,_uniffiStatus)
	}))
}
func (object *Object) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterObject struct {}

var FfiConverterObjectINSTANCE = FfiConverterObject{}


func (c FfiConverterObject) Lift(pointer unsafe.Pointer) *Object {
	result := &Object {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_object(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_object(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Object).Destroy)
	return result
}

func (c FfiConverterObject) Read(reader io.Reader) *Object {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterObject) Lower(value *Object) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Object")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterObject) Write(writer io.Writer, value *Object) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerObject struct {}

func (_ FfiDestroyerObject) Destroy(value *Object) {
		value.Destroy()
}



// Object data, either a package or struct
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object-data = object-data-struct / object-data-package
//
// object-data-struct  = %x00 object-move-struct
// object-data-package = %x01 object-move-package
// ```
type ObjectDataInterface interface {
	// Try to interpret this object as a `MovePackage`
	AsPackageOpt() **MovePackage
	// Try to interpret this object as a `MoveStruct`
	AsStructOpt() *MoveStruct
	// Return whether this object is a `MovePackage`
	IsPackage() bool
	// Return whether this object is a `MoveStruct`
	IsStruct() bool
}
// Object data, either a package or struct
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object-data = object-data-struct / object-data-package
//
// object-data-struct  = %x00 object-move-struct
// object-data-package = %x01 object-move-package
// ```
type ObjectData struct {
	ffiObject FfiObject
}


// Create an `ObjectData` from  `MovePackage`
func ObjectDataNewMovePackage(movePackage *MovePackage) *ObjectData {
	return FfiConverterObjectDataINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objectdata_new_move_package(FfiConverterMovePackageINSTANCE.Lower(movePackage),_uniffiStatus)
	}))
}

// Create an `ObjectData` from a `MoveStruct`
func ObjectDataNewMoveStruct(moveStruct MoveStruct) *ObjectData {
	return FfiConverterObjectDataINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objectdata_new_move_struct(FfiConverterMoveStructINSTANCE.Lower(moveStruct),_uniffiStatus)
	}))
}



// Try to interpret this object as a `MovePackage`
func (_self *ObjectData) AsPackageOpt() **MovePackage {
	_pointer := _self.ffiObject.incrementPointer("*ObjectData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalMovePackageINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_objectdata_as_package_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

// Try to interpret this object as a `MoveStruct`
func (_self *ObjectData) AsStructOpt() *MoveStruct {
	_pointer := _self.ffiObject.incrementPointer("*ObjectData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalMoveStructINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_objectdata_as_struct_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

// Return whether this object is a `MovePackage`
func (_self *ObjectData) IsPackage() bool {
	_pointer := _self.ffiObject.incrementPointer("*ObjectData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_objectdata_is_package(
		_pointer,_uniffiStatus)
	}))
}

// Return whether this object is a `MoveStruct`
func (_self *ObjectData) IsStruct() bool {
	_pointer := _self.ffiObject.incrementPointer("*ObjectData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_objectdata_is_struct(
		_pointer,_uniffiStatus)
	}))
}
func (object *ObjectData) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterObjectData struct {}

var FfiConverterObjectDataINSTANCE = FfiConverterObjectData{}


func (c FfiConverterObjectData) Lift(pointer unsafe.Pointer) *ObjectData {
	result := &ObjectData {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_objectdata(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_objectdata(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ObjectData).Destroy)
	return result
}

func (c FfiConverterObjectData) Read(reader io.Reader) *ObjectData {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterObjectData) Lower(value *ObjectData) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ObjectData")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterObjectData) Write(writer io.Writer, value *ObjectData) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerObjectData struct {}

func (_ FfiDestroyerObjectData) Destroy(value *ObjectData) {
		value.Destroy()
}



// An `ObjectId` is a 32-byte identifier used to uniquely identify an object on
// the IOTA blockchain.
//
// ## Relationship to Address
//
// `Address`es and `ObjectId`s share the same 32-byte addressable space but
// are derived leveraging different domain-separator values to ensure,
// cryptographically, that there won't be any overlap, e.g. there can't be a
// valid `Object` whose `ObjectId` is equal to that of the `Address` of a user
// account.
//
// # BCS
//
// An `ObjectId`'s BCS serialized form is defined by the following:
//
// ```text
// object-id = 32*OCTET
// ```
type ObjectIdInterface interface {
	// Derive an ObjectId for a Dynamic Child Object.
	//
	// hash(parent || len(key) || key || key_type_tag)
	DeriveDynamicChildId(keyTypeTag *TypeTag, keyBytes []byte) *ObjectId
	ToAddress() *Address
	ToBytes() []byte
	ToHex() string
}
// An `ObjectId` is a 32-byte identifier used to uniquely identify an object on
// the IOTA blockchain.
//
// ## Relationship to Address
//
// `Address`es and `ObjectId`s share the same 32-byte addressable space but
// are derived leveraging different domain-separator values to ensure,
// cryptographically, that there won't be any overlap, e.g. there can't be a
// valid `Object` whose `ObjectId` is equal to that of the `Address` of a user
// account.
//
// # BCS
//
// An `ObjectId`'s BCS serialized form is defined by the following:
//
// ```text
// object-id = 32*OCTET
// ```
type ObjectId struct {
	ffiObject FfiObject
}


func ObjectIdClock() *ObjectId {
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objectid_clock(_uniffiStatus)
	}))
}

// Create an ObjectId from a transaction digest and the number of objects
// that have been created during a transactions.
func ObjectIdDeriveId(digest *Digest, count uint64) *ObjectId {
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objectid_derive_id(FfiConverterDigestINSTANCE.Lower(digest), FfiConverterUint64INSTANCE.Lower(count),_uniffiStatus)
	}))
}

func ObjectIdFromBytes(bytes []byte) (*ObjectId, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objectid_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ObjectId
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterObjectIdINSTANCE.Lift(_uniffiRV), nil
		}
}

func ObjectIdFromHex(hex string) (*ObjectId, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objectid_from_hex(FfiConverterStringINSTANCE.Lower(hex),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ObjectId
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterObjectIdINSTANCE.Lift(_uniffiRV), nil
		}
}

func ObjectIdSystem() *ObjectId {
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objectid_system(_uniffiStatus)
	}))
}

func ObjectIdZero() *ObjectId {
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objectid_zero(_uniffiStatus)
	}))
}



// Derive an ObjectId for a Dynamic Child Object.
//
// hash(parent || len(key) || key || key_type_tag)
func (_self *ObjectId) DeriveDynamicChildId(keyTypeTag *TypeTag, keyBytes []byte) *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*ObjectId")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_objectid_derive_dynamic_child_id(
		_pointer,FfiConverterTypeTagINSTANCE.Lower(keyTypeTag), FfiConverterBytesINSTANCE.Lower(keyBytes),_uniffiStatus)
	}))
}

func (_self *ObjectId) ToAddress() *Address {
	_pointer := _self.ffiObject.incrementPointer("*ObjectId")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_objectid_to_address(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ObjectId) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*ObjectId")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_objectid_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ObjectId) ToHex() string {
	_pointer := _self.ffiObject.incrementPointer("*ObjectId")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_objectid_to_hex(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ObjectId) Hash() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ObjectId")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_objectid_uniffi_trait_hash(
		_pointer,_uniffiStatus)
	}))
}


func (object *ObjectId) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterObjectId struct {}

var FfiConverterObjectIdINSTANCE = FfiConverterObjectId{}


func (c FfiConverterObjectId) Lift(pointer unsafe.Pointer) *ObjectId {
	result := &ObjectId {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_objectid(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_objectid(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ObjectId).Destroy)
	return result
}

func (c FfiConverterObjectId) Read(reader io.Reader) *ObjectId {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterObjectId) Lower(value *ObjectId) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ObjectId")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterObjectId) Write(writer io.Writer, value *ObjectId) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerObjectId struct {}

func (_ FfiDestroyerObjectId) Destroy(value *ObjectId) {
		value.Destroy()
}



// Type of an IOTA object
type ObjectTypeInterface interface {
	AsStruct() *StructTag
	AsStructOpt() **StructTag
	IsPackage() bool
	IsStruct() bool
}
// Type of an IOTA object
type ObjectType struct {
	ffiObject FfiObject
}


func ObjectTypeNewPackage() *ObjectType {
	return FfiConverterObjectTypeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objecttype_new_package(_uniffiStatus)
	}))
}

func ObjectTypeNewStruct(structTag *StructTag) *ObjectType {
	return FfiConverterObjectTypeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_objecttype_new_struct(FfiConverterStructTagINSTANCE.Lower(structTag),_uniffiStatus)
	}))
}



func (_self *ObjectType) AsStruct() *StructTag {
	_pointer := _self.ffiObject.incrementPointer("*ObjectType")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_objecttype_as_struct(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ObjectType) AsStructOpt() **StructTag {
	_pointer := _self.ffiObject.incrementPointer("*ObjectType")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_objecttype_as_struct_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ObjectType) IsPackage() bool {
	_pointer := _self.ffiObject.incrementPointer("*ObjectType")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_objecttype_is_package(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ObjectType) IsStruct() bool {
	_pointer := _self.ffiObject.incrementPointer("*ObjectType")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_objecttype_is_struct(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ObjectType) String() string {
	_pointer := _self.ffiObject.incrementPointer("*ObjectType")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_objecttype_uniffi_trait_display(
		_pointer,_uniffiStatus),
	}
	}))
}


func (object *ObjectType) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterObjectType struct {}

var FfiConverterObjectTypeINSTANCE = FfiConverterObjectType{}


func (c FfiConverterObjectType) Lift(pointer unsafe.Pointer) *ObjectType {
	result := &ObjectType {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_objecttype(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_objecttype(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ObjectType).Destroy)
	return result
}

func (c FfiConverterObjectType) Read(reader io.Reader) *ObjectType {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterObjectType) Lower(value *ObjectType) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ObjectType")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterObjectType) Write(writer io.Writer, value *ObjectType) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerObjectType struct {}

func (_ FfiDestroyerObjectType) Destroy(value *ObjectType) {
		value.Destroy()
}



// Enum of different types of ownership for an object.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// owner = owner-address / owner-object / owner-shared / owner-immutable
//
// owner-address   = %x00 address
// owner-object    = %x01 object-id
// owner-shared    = %x02 u64
// owner-immutable = %x03
// ```
type OwnerInterface interface {
	AsAddress() *Address
	AsAddressOpt() **Address
	AsObject() *ObjectId
	AsObjectOpt() **ObjectId
	AsShared() uint64
	AsSharedOpt() *uint64
	IsAddress() bool
	IsImmutable() bool
	IsObject() bool
	IsShared() bool
}
// Enum of different types of ownership for an object.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// owner = owner-address / owner-object / owner-shared / owner-immutable
//
// owner-address   = %x00 address
// owner-object    = %x01 object-id
// owner-shared    = %x02 u64
// owner-immutable = %x03
// ```
type Owner struct {
	ffiObject FfiObject
}


func OwnerNewAddress(address *Address) *Owner {
	return FfiConverterOwnerINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_owner_new_address(FfiConverterAddressINSTANCE.Lower(address),_uniffiStatus)
	}))
}

func OwnerNewImmutable() *Owner {
	return FfiConverterOwnerINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_owner_new_immutable(_uniffiStatus)
	}))
}

func OwnerNewObject(id *ObjectId) *Owner {
	return FfiConverterOwnerINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_owner_new_object(FfiConverterObjectIdINSTANCE.Lower(id),_uniffiStatus)
	}))
}

func OwnerNewShared(version uint64) *Owner {
	return FfiConverterOwnerINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_owner_new_shared(FfiConverterUint64INSTANCE.Lower(version),_uniffiStatus)
	}))
}



func (_self *Owner) AsAddress() *Address {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_owner_as_address(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Owner) AsAddressOpt() **Address {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_owner_as_address_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Owner) AsObject() *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_owner_as_object(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Owner) AsObjectOpt() **ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_owner_as_object_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Owner) AsShared() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_owner_as_shared(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Owner) AsSharedOpt() *uint64 {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_owner_as_shared_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Owner) IsAddress() bool {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_owner_is_address(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Owner) IsImmutable() bool {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_owner_is_immutable(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Owner) IsObject() bool {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_owner_is_object(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Owner) IsShared() bool {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_owner_is_shared(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Owner) String() string {
	_pointer := _self.ffiObject.incrementPointer("*Owner")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_owner_uniffi_trait_display(
		_pointer,_uniffiStatus),
	}
	}))
}


func (object *Owner) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterOwner struct {}

var FfiConverterOwnerINSTANCE = FfiConverterOwner{}


func (c FfiConverterOwner) Lift(pointer unsafe.Pointer) *Owner {
	result := &Owner {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_owner(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_owner(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Owner).Destroy)
	return result
}

func (c FfiConverterOwner) Read(reader io.Reader) *Owner {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterOwner) Lower(value *Owner) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Owner")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterOwner) Write(writer io.Writer, value *Owner) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerOwner struct {}

func (_ FfiDestroyerOwner) Destroy(value *Owner) {
		value.Destroy()
}



type PtbArgumentInterface interface {
}
type PtbArgument struct {
	ffiObject FfiObject
}


func PtbArgumentAddress(address *Address) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address(FfiConverterAddressINSTANCE.Lower(address),_uniffiStatus)
	}))
}

func PtbArgumentAddressFromHex(hex string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_from_hex(FfiConverterStringINSTANCE.Lower(hex),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentAddressVec(addresses []*Address) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_vec(FfiConverterSequenceAddressINSTANCE.Lower(addresses),_uniffiStatus)
	}))
}

func PtbArgumentAddressVecFromHex(addresses []string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_vec_from_hex(FfiConverterSequenceStringINSTANCE.Lower(addresses),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentBool(value bool) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_bool(FfiConverterBoolINSTANCE.Lower(value),_uniffiStatus)
	}))
}

func PtbArgumentBoolVec(values []bool) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_bool_vec(FfiConverterSequenceBoolINSTANCE.Lower(values),_uniffiStatus)
	}))
}

func PtbArgumentDigest(digest *Digest) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest(FfiConverterDigestINSTANCE.Lower(digest),_uniffiStatus)
	}))
}

func PtbArgumentDigestFromBase58(base58 string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_from_base58(FfiConverterStringINSTANCE.Lower(base58),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentDigestVec(digests []*Digest) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_vec(FfiConverterSequenceDigestINSTANCE.Lower(digests),_uniffiStatus)
	}))
}

func PtbArgumentDigestVecFromBase58(digests []string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_vec_from_base58(FfiConverterSequenceStringINSTANCE.Lower(digests),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentGas() *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_gas(_uniffiStatus)
	}))
}

func PtbArgumentMoveArg(arg *MoveArg) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_move_arg(FfiConverterMoveArgINSTANCE.Lower(arg),_uniffiStatus)
	}))
}

func PtbArgumentObjectId(id *ObjectId) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_id(FfiConverterObjectIdINSTANCE.Lower(id),_uniffiStatus)
	}))
}

func PtbArgumentObjectIdFromHex(hex string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_id_from_hex(FfiConverterStringINSTANCE.Lower(hex),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentObjectRef(id ObjectReference) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_ref(FfiConverterObjectReferenceINSTANCE.Lower(id),_uniffiStatus)
	}))
}

func PtbArgumentOption(value **MoveArg) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_option(FfiConverterOptionalMoveArgINSTANCE.Lower(value),_uniffiStatus)
	}))
}

func PtbArgumentReceiving(id *ObjectId) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_receiving(FfiConverterObjectIdINSTANCE.Lower(id),_uniffiStatus)
	}))
}

func PtbArgumentReceivingFromHex(hex string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_receiving_from_hex(FfiConverterStringINSTANCE.Lower(hex),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentRes(name string) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_res(FfiConverterStringINSTANCE.Lower(name),_uniffiStatus)
	}))
}

func PtbArgumentShared(id *ObjectId) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared(FfiConverterObjectIdINSTANCE.Lower(id),_uniffiStatus)
	}))
}

func PtbArgumentSharedFromHex(hex string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_from_hex(FfiConverterStringINSTANCE.Lower(hex),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentSharedMut(id *ObjectId) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_mut(FfiConverterObjectIdINSTANCE.Lower(id),_uniffiStatus)
	}))
}

func PtbArgumentSharedMutFromHex(hex string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_mut_from_hex(FfiConverterStringINSTANCE.Lower(hex),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentString(string string) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_string(FfiConverterStringINSTANCE.Lower(string),_uniffiStatus)
	}))
}

func PtbArgumentU128(value string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u128(FfiConverterStringINSTANCE.Lower(value),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentU128Vec(values []string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u128_vec(FfiConverterSequenceStringINSTANCE.Lower(values),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentU16(value uint16) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u16(FfiConverterUint16INSTANCE.Lower(value),_uniffiStatus)
	}))
}

func PtbArgumentU16Vec(values []uint16) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u16_vec(FfiConverterSequenceUint16INSTANCE.Lower(values),_uniffiStatus)
	}))
}

func PtbArgumentU256(value string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u256(FfiConverterStringINSTANCE.Lower(value),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentU256Vec(values []string) (*PtbArgument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u256_vec(FfiConverterSequenceStringINSTANCE.Lower(values),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PtbArgument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPtbArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

func PtbArgumentU32(value uint32) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u32(FfiConverterUint32INSTANCE.Lower(value),_uniffiStatus)
	}))
}

func PtbArgumentU32Vec(values []uint32) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u32_vec(FfiConverterSequenceUint32INSTANCE.Lower(values),_uniffiStatus)
	}))
}

func PtbArgumentU64(value uint64) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u64(FfiConverterUint64INSTANCE.Lower(value),_uniffiStatus)
	}))
}

func PtbArgumentU64Vec(values []uint64) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u64_vec(FfiConverterSequenceUint64INSTANCE.Lower(values),_uniffiStatus)
	}))
}

func PtbArgumentU8(value uint8) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u8(FfiConverterUint8INSTANCE.Lower(value),_uniffiStatus)
	}))
}

func PtbArgumentU8Vec(values []byte) *PtbArgument {
	return FfiConverterPtbArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u8_vec(FfiConverterBytesINSTANCE.Lower(values),_uniffiStatus)
	}))
}


func (object *PtbArgument) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterPtbArgument struct {}

var FfiConverterPtbArgumentINSTANCE = FfiConverterPtbArgument{}


func (c FfiConverterPtbArgument) Lift(pointer unsafe.Pointer) *PtbArgument {
	result := &PtbArgument {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_ptbargument(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_ptbargument(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*PtbArgument).Destroy)
	return result
}

func (c FfiConverterPtbArgument) Read(reader io.Reader) *PtbArgument {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterPtbArgument) Lower(value *PtbArgument) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*PtbArgument")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterPtbArgument) Write(writer io.Writer, value *PtbArgument) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerPtbArgument struct {}

func (_ FfiDestroyerPtbArgument) Destroy(value *PtbArgument) {
		value.Destroy()
}



// A passkey authenticator.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// passkey-bcs = bytes               ; where the contents of the bytes are
// ; defined by <passkey>
// passkey     = passkey-flag
// bytes               ; passkey authenticator data
// client-data-json    ; valid json
// simple-signature    ; required to be a secp256r1 signature
//
// client-data-json = string ; valid json
// ```
//
// See <https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata> for
// the required json-schema for the `client-data-json` rule. In addition, IOTA
// currently requires that the `CollectedClientData.type` field is required to
// be `webauthn.get`.
//
// Note: Due to historical reasons, signatures are serialized slightly
// different from the majority of the types in IOTA. In particular if a
// signature is ever embedded in another structure it generally is serialized
// as `bytes` meaning it has a length prefix that defines the length of
// the completely serialized signature.
type PasskeyAuthenticatorInterface interface {
	// Opaque authenticator data for this passkey signature.
	//
	// See <https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data>
	// for more information on this field.
	AuthenticatorData() []byte
	// The parsed challenge message for this passkey signature.
	//
	// This is parsed by decoding the base64url data from the
	// `client_data_json.challenge` field.
	Challenge() []byte
	// Structured, unparsed, JSON for this passkey signature.
	//
	// See <https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata>
	// for more information on this field.
	ClientDataJson() string
	// The passkey public key
	PublicKey() *PasskeyPublicKey
	// The passkey signature.
	Signature() *SimpleSignature
}
// A passkey authenticator.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// passkey-bcs = bytes               ; where the contents of the bytes are
// ; defined by <passkey>
// passkey     = passkey-flag
// bytes               ; passkey authenticator data
// client-data-json    ; valid json
// simple-signature    ; required to be a secp256r1 signature
//
// client-data-json = string ; valid json
// ```
//
// See <https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata> for
// the required json-schema for the `client-data-json` rule. In addition, IOTA
// currently requires that the `CollectedClientData.type` field is required to
// be `webauthn.get`.
//
// Note: Due to historical reasons, signatures are serialized slightly
// different from the majority of the types in IOTA. In particular if a
// signature is ever embedded in another structure it generally is serialized
// as `bytes` meaning it has a length prefix that defines the length of
// the completely serialized signature.
type PasskeyAuthenticator struct {
	ffiObject FfiObject
}




// Opaque authenticator data for this passkey signature.
//
// See <https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data>
// for more information on this field.
func (_self *PasskeyAuthenticator) AuthenticatorData() []byte {
	_pointer := _self.ffiObject.incrementPointer("*PasskeyAuthenticator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_authenticator_data(
		_pointer,_uniffiStatus),
	}
	}))
}

// The parsed challenge message for this passkey signature.
//
// This is parsed by decoding the base64url data from the
// `client_data_json.challenge` field.
func (_self *PasskeyAuthenticator) Challenge() []byte {
	_pointer := _self.ffiObject.incrementPointer("*PasskeyAuthenticator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_challenge(
		_pointer,_uniffiStatus),
	}
	}))
}

// Structured, unparsed, JSON for this passkey signature.
//
// See <https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata>
// for more information on this field.
func (_self *PasskeyAuthenticator) ClientDataJson() string {
	_pointer := _self.ffiObject.incrementPointer("*PasskeyAuthenticator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_client_data_json(
		_pointer,_uniffiStatus),
	}
	}))
}

// The passkey public key
func (_self *PasskeyAuthenticator) PublicKey() *PasskeyPublicKey {
	_pointer := _self.ffiObject.incrementPointer("*PasskeyAuthenticator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterPasskeyPublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_public_key(
		_pointer,_uniffiStatus)
	}))
}

// The passkey signature.
func (_self *PasskeyAuthenticator) Signature() *SimpleSignature {
	_pointer := _self.ffiObject.incrementPointer("*PasskeyAuthenticator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSimpleSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_signature(
		_pointer,_uniffiStatus)
	}))
}
func (object *PasskeyAuthenticator) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterPasskeyAuthenticator struct {}

var FfiConverterPasskeyAuthenticatorINSTANCE = FfiConverterPasskeyAuthenticator{}


func (c FfiConverterPasskeyAuthenticator) Lift(pointer unsafe.Pointer) *PasskeyAuthenticator {
	result := &PasskeyAuthenticator {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_passkeyauthenticator(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_passkeyauthenticator(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*PasskeyAuthenticator).Destroy)
	return result
}

func (c FfiConverterPasskeyAuthenticator) Read(reader io.Reader) *PasskeyAuthenticator {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterPasskeyAuthenticator) Lower(value *PasskeyAuthenticator) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*PasskeyAuthenticator")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterPasskeyAuthenticator) Write(writer io.Writer, value *PasskeyAuthenticator) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerPasskeyAuthenticator struct {}

func (_ FfiDestroyerPasskeyAuthenticator) Destroy(value *PasskeyAuthenticator) {
		value.Destroy()
}



// Public key of a `PasskeyAuthenticator`.
//
// This is used to derive the onchain `Address` for a `PasskeyAuthenticator`.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// passkey-public-key = passkey-flag secp256r1-public-key
// ```
type PasskeyPublicKeyInterface interface {
	// Derive an `Address` from this Passkey Public Key
	//
	// An `Address` can be derived from a `PasskeyPublicKey` by hashing the
	// bytes of the `Secp256r1PublicKey` that corresponds to this passkey
	// prefixed with the Passkey `SignatureScheme` flag (`0x06`).
	//
	// `hash( 0x06 || 33-byte secp256r1 public key)`
	DeriveAddress() *Address
	Inner() *Secp256r1PublicKey
}
// Public key of a `PasskeyAuthenticator`.
//
// This is used to derive the onchain `Address` for a `PasskeyAuthenticator`.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// passkey-public-key = passkey-flag secp256r1-public-key
// ```
type PasskeyPublicKey struct {
	ffiObject FfiObject
}
func NewPasskeyPublicKey(publicKey *Secp256r1PublicKey) *PasskeyPublicKey {
	return FfiConverterPasskeyPublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_passkeypublickey_new(FfiConverterSecp256r1PublicKeyINSTANCE.Lower(publicKey),_uniffiStatus)
	}))
}




// Derive an `Address` from this Passkey Public Key
//
// An `Address` can be derived from a `PasskeyPublicKey` by hashing the
// bytes of the `Secp256r1PublicKey` that corresponds to this passkey
// prefixed with the Passkey `SignatureScheme` flag (`0x06`).
//
// `hash( 0x06 || 33-byte secp256r1 public key)`
func (_self *PasskeyPublicKey) DeriveAddress() *Address {
	_pointer := _self.ffiObject.incrementPointer("*PasskeyPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_passkeypublickey_derive_address(
		_pointer,_uniffiStatus)
	}))
}

func (_self *PasskeyPublicKey) Inner() *Secp256r1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*PasskeyPublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256r1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_passkeypublickey_inner(
		_pointer,_uniffiStatus)
	}))
}
func (object *PasskeyPublicKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterPasskeyPublicKey struct {}

var FfiConverterPasskeyPublicKeyINSTANCE = FfiConverterPasskeyPublicKey{}


func (c FfiConverterPasskeyPublicKey) Lift(pointer unsafe.Pointer) *PasskeyPublicKey {
	result := &PasskeyPublicKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_passkeypublickey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_passkeypublickey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*PasskeyPublicKey).Destroy)
	return result
}

func (c FfiConverterPasskeyPublicKey) Read(reader io.Reader) *PasskeyPublicKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterPasskeyPublicKey) Lower(value *PasskeyPublicKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*PasskeyPublicKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterPasskeyPublicKey) Write(writer io.Writer, value *PasskeyPublicKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerPasskeyPublicKey struct {}

func (_ FfiDestroyerPasskeyPublicKey) Destroy(value *PasskeyPublicKey) {
		value.Destroy()
}



type PasskeyVerifierInterface interface {
	Verify(message []byte, authenticator *PasskeyAuthenticator) error
}
type PasskeyVerifier struct {
	ffiObject FfiObject
}
func NewPasskeyVerifier() *PasskeyVerifier {
	return FfiConverterPasskeyVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_passkeyverifier_new(_uniffiStatus)
	}))
}




func (_self *PasskeyVerifier) Verify(message []byte, authenticator *PasskeyAuthenticator) error {
	_pointer := _self.ffiObject.incrementPointer("*PasskeyVerifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_passkeyverifier_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterPasskeyAuthenticatorINSTANCE.Lower(authenticator),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *PasskeyVerifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterPasskeyVerifier struct {}

var FfiConverterPasskeyVerifierINSTANCE = FfiConverterPasskeyVerifier{}


func (c FfiConverterPasskeyVerifier) Lift(pointer unsafe.Pointer) *PasskeyVerifier {
	result := &PasskeyVerifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_passkeyverifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_passkeyverifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*PasskeyVerifier).Destroy)
	return result
}

func (c FfiConverterPasskeyVerifier) Read(reader io.Reader) *PasskeyVerifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterPasskeyVerifier) Lower(value *PasskeyVerifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*PasskeyVerifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterPasskeyVerifier) Write(writer io.Writer, value *PasskeyVerifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerPasskeyVerifier struct {}

func (_ FfiDestroyerPasskeyVerifier) Destroy(value *PasskeyVerifier) {
		value.Destroy()
}



type PersonalMessageInterface interface {
	MessageBytes() []byte
	SigningDigest() []byte
	SigningDigestHex() string
}
type PersonalMessage struct {
	ffiObject FfiObject
}
func NewPersonalMessage(messageBytes []byte) *PersonalMessage {
	return FfiConverterPersonalMessageINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_personalmessage_new(FfiConverterBytesINSTANCE.Lower(messageBytes),_uniffiStatus)
	}))
}




func (_self *PersonalMessage) MessageBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*PersonalMessage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_personalmessage_message_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *PersonalMessage) SigningDigest() []byte {
	_pointer := _self.ffiObject.incrementPointer("*PersonalMessage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_personalmessage_signing_digest(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *PersonalMessage) SigningDigestHex() string {
	_pointer := _self.ffiObject.incrementPointer("*PersonalMessage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_personalmessage_signing_digest_hex(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *PersonalMessage) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterPersonalMessage struct {}

var FfiConverterPersonalMessageINSTANCE = FfiConverterPersonalMessage{}


func (c FfiConverterPersonalMessage) Lift(pointer unsafe.Pointer) *PersonalMessage {
	result := &PersonalMessage {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_personalmessage(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_personalmessage(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*PersonalMessage).Destroy)
	return result
}

func (c FfiConverterPersonalMessage) Read(reader io.Reader) *PersonalMessage {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterPersonalMessage) Lower(value *PersonalMessage) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*PersonalMessage")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterPersonalMessage) Write(writer io.Writer, value *PersonalMessage) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerPersonalMessage struct {}

func (_ FfiDestroyerPersonalMessage) Destroy(value *PersonalMessage) {
		value.Destroy()
}



// A user transaction
//
// Contains a series of native commands and move calls where the results of one
// command can be used in future commands.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// ptb = (vector input) (vector command)
// ```
type ProgrammableTransactionInterface interface {
	// The commands to be executed sequentially. A failure in any command will
	// result in the failure of the entire transaction.
	Commands() []*Command
	// Input objects or primitive values
	Inputs() []*Input
}
// A user transaction
//
// Contains a series of native commands and move calls where the results of one
// command can be used in future commands.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// ptb = (vector input) (vector command)
// ```
type ProgrammableTransaction struct {
	ffiObject FfiObject
}
func NewProgrammableTransaction(inputs []*Input, commands []*Command) *ProgrammableTransaction {
	return FfiConverterProgrammableTransactionINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_programmabletransaction_new(FfiConverterSequenceInputINSTANCE.Lower(inputs), FfiConverterSequenceCommandINSTANCE.Lower(commands),_uniffiStatus)
	}))
}




// The commands to be executed sequentially. A failure in any command will
// result in the failure of the entire transaction.
func (_self *ProgrammableTransaction) Commands() []*Command {
	_pointer := _self.ffiObject.incrementPointer("*ProgrammableTransaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceCommandINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_programmabletransaction_commands(
		_pointer,_uniffiStatus),
	}
	}))
}

// Input objects or primitive values
func (_self *ProgrammableTransaction) Inputs() []*Input {
	_pointer := _self.ffiObject.incrementPointer("*ProgrammableTransaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceInputINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_programmabletransaction_inputs(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *ProgrammableTransaction) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterProgrammableTransaction struct {}

var FfiConverterProgrammableTransactionINSTANCE = FfiConverterProgrammableTransaction{}


func (c FfiConverterProgrammableTransaction) Lift(pointer unsafe.Pointer) *ProgrammableTransaction {
	result := &ProgrammableTransaction {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_programmabletransaction(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_programmabletransaction(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ProgrammableTransaction).Destroy)
	return result
}

func (c FfiConverterProgrammableTransaction) Read(reader io.Reader) *ProgrammableTransaction {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterProgrammableTransaction) Lower(value *ProgrammableTransaction) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ProgrammableTransaction")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterProgrammableTransaction) Write(writer io.Writer, value *ProgrammableTransaction) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerProgrammableTransaction struct {}

func (_ FfiDestroyerProgrammableTransaction) Destroy(value *ProgrammableTransaction) {
		value.Destroy()
}



// Command to publish a new move package
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// publish = (vector bytes)        ; the serialized move modules
// (vector object-id)    ; the set of package dependencies
// ```
type PublishInterface interface {
	// Set of packages that the to-be published package depends on
	Dependencies() []*ObjectId
	// The serialized move modules
	Modules() [][]byte
}
// Command to publish a new move package
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// publish = (vector bytes)        ; the serialized move modules
// (vector object-id)    ; the set of package dependencies
// ```
type Publish struct {
	ffiObject FfiObject
}
func NewPublish(modules [][]byte, dependencies []*ObjectId) *Publish {
	return FfiConverterPublishINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_publish_new(FfiConverterSequenceBytesINSTANCE.Lower(modules), FfiConverterSequenceObjectIdINSTANCE.Lower(dependencies),_uniffiStatus)
	}))
}




// Set of packages that the to-be published package depends on
func (_self *Publish) Dependencies() []*ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*Publish")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_publish_dependencies(
		_pointer,_uniffiStatus),
	}
	}))
}

// The serialized move modules
func (_self *Publish) Modules() [][]byte {
	_pointer := _self.ffiObject.incrementPointer("*Publish")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_publish_modules(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Publish) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterPublish struct {}

var FfiConverterPublishINSTANCE = FfiConverterPublish{}


func (c FfiConverterPublish) Lift(pointer unsafe.Pointer) *Publish {
	result := &Publish {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_publish(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_publish(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Publish).Destroy)
	return result
}

func (c FfiConverterPublish) Read(reader io.Reader) *Publish {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterPublish) Lower(value *Publish) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Publish")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterPublish) Write(writer io.Writer, value *Publish) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerPublish struct {}

func (_ FfiDestroyerPublish) Destroy(value *Publish) {
		value.Destroy()
}



type Secp256k1PrivateKeyInterface interface {
	PublicKey() *Secp256k1PublicKey
	Scheme() SignatureScheme
	// Sign a personal message and return a UserSignature.
	SignPersonalMessage(message *PersonalMessage) (*UserSignature, error)
	// Sign a transaction and return a UserSignature.
	SignTransaction(transaction *Transaction) (*UserSignature, error)
	// Encode this private key as `flag || privkey` in Bech32 starting with
	// "iotaprivkey" to a string.
	ToBech32() (string, error)
	// Serialize this private key to bytes.
	ToBytes() []byte
	// Serialize this private key as DER-encoded PKCS#8
	ToDer() ([]byte, error)
	// Serialize this private key as PEM-encoded PKCS#8
	ToPem() (string, error)
	TrySign(message []byte) (*Secp256k1Signature, error)
	TrySignSimple(message []byte) (*SimpleSignature, error)
	TrySignUser(message []byte) (*UserSignature, error)
	VerifyingKey() *Secp256k1VerifyingKey
}
type Secp256k1PrivateKey struct {
	ffiObject FfiObject
}
func NewSecp256k1PrivateKey(bytes []byte) (*Secp256k1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_new(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}


// Decode a private key from `flag || privkey` in Bech32 starting with
// "iotaprivkey".
func Secp256k1PrivateKeyFromBech32(value string) (*Secp256k1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_bech32(FfiConverterStringINSTANCE.Lower(value),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
// format).
func Secp256k1PrivateKeyFromDer(bytes []byte) (*Secp256k1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_der(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Construct the private key from a mnemonic phrase
func Secp256k1PrivateKeyFromMnemonic(phrase string, accountIndex uint64, password string) (*Secp256k1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_mnemonic(FfiConverterStringINSTANCE.Lower(phrase), FfiConverterUint64INSTANCE.Lower(accountIndex), FfiConverterStringINSTANCE.Lower(password),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create an instance from a mnemonic phrase and a derivation path like
// `"m/54'/4218'/0'/0/0"`
func Secp256k1PrivateKeyFromMnemonicWithPath(phrase string, path string, password string) (*Secp256k1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_mnemonic_with_path(FfiConverterStringINSTANCE.Lower(phrase), FfiConverterStringINSTANCE.Lower(path), FfiConverterStringINSTANCE.Lower(password),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize PKCS#8-encoded private key from PEM.
func Secp256k1PrivateKeyFromPem(s string) (*Secp256k1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_pem(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Secp256k1PrivateKeyGenerate() *Secp256k1PrivateKey {
	return FfiConverterSecp256k1PrivateKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_generate(_uniffiStatus)
	}))
}



func (_self *Secp256k1PrivateKey) PublicKey() *Secp256k1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256k1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_public_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Secp256k1PrivateKey) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

// Sign a personal message and return a UserSignature.
func (_self *Secp256k1PrivateKey) SignPersonalMessage(message *PersonalMessage) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_sign_personal_message(
		_pointer,FfiConverterPersonalMessageINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Sign a transaction and return a UserSignature.
func (_self *Secp256k1PrivateKey) SignTransaction(transaction *Transaction) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_sign_transaction(
		_pointer,FfiConverterTransactionINSTANCE.Lower(transaction),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Encode this private key as `flag || privkey` in Bech32 starting with
// "iotaprivkey" to a string.
func (_self *Secp256k1PrivateKey) ToBech32() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_bech32(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this private key to bytes.
func (_self *Secp256k1PrivateKey) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

// Serialize this private key as DER-encoded PKCS#8
func (_self *Secp256k1PrivateKey) ToDer() ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_der(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this private key as PEM-encoded PKCS#8
func (_self *Secp256k1PrivateKey) ToPem() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_pem(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Secp256k1PrivateKey) TrySign(message []byte) (*Secp256k1Signature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Secp256k1PrivateKey) TrySignSimple(message []byte) (*SimpleSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign_simple(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Secp256k1PrivateKey) TrySignUser(message []byte) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign_user(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Secp256k1PrivateKey) VerifyingKey() *Secp256k1VerifyingKey {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256k1VerifyingKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_verifying_key(
		_pointer,_uniffiStatus)
	}))
}
func (object *Secp256k1PrivateKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256k1PrivateKey struct {}

var FfiConverterSecp256k1PrivateKeyINSTANCE = FfiConverterSecp256k1PrivateKey{}


func (c FfiConverterSecp256k1PrivateKey) Lift(pointer unsafe.Pointer) *Secp256k1PrivateKey {
	result := &Secp256k1PrivateKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256k1privatekey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256k1privatekey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256k1PrivateKey).Destroy)
	return result
}

func (c FfiConverterSecp256k1PrivateKey) Read(reader io.Reader) *Secp256k1PrivateKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256k1PrivateKey) Lower(value *Secp256k1PrivateKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256k1PrivateKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256k1PrivateKey) Write(writer io.Writer, value *Secp256k1PrivateKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256k1PrivateKey struct {}

func (_ FfiDestroyerSecp256k1PrivateKey) Destroy(value *Secp256k1PrivateKey) {
		value.Destroy()
}



// A secp256k1 signature.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// secp256k1-signature = 64OCTECT
// ```
type Secp256k1PublicKeyInterface interface {
	// Derive an `Address` from this Public Key
	//
	// An `Address` can be derived from a `Secp256k1PublicKey` by hashing the
	// bytes of the public key prefixed with the Secp256k1
	// `SignatureScheme` flag (`0x01`).
	//
	// `hash( 0x01 || 33-byte secp256k1 public key)`
	DeriveAddress() *Address
	// Returns the signature scheme for this public key.
	Scheme() SignatureScheme
	ToBytes() []byte
	// Returns the bytes with signature scheme flag prepended.
	ToFlaggedBytes() []byte
}
// A secp256k1 signature.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// secp256k1-signature = 64OCTECT
// ```
type Secp256k1PublicKey struct {
	ffiObject FfiObject
}


func Secp256k1PublicKeyFromBytes(bytes []byte) (*Secp256k1PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Secp256k1PublicKeyFromStr(s string) (*Secp256k1PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Secp256k1PublicKeyGenerate() *Secp256k1PublicKey {
	return FfiConverterSecp256k1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_generate(_uniffiStatus)
	}))
}



// Derive an `Address` from this Public Key
//
// An `Address` can be derived from a `Secp256k1PublicKey` by hashing the
// bytes of the public key prefixed with the Secp256k1
// `SignatureScheme` flag (`0x01`).
//
// `hash( 0x01 || 33-byte secp256k1 public key)`
func (_self *Secp256k1PublicKey) DeriveAddress() *Address {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_derive_address(
		_pointer,_uniffiStatus)
	}))
}

// Returns the signature scheme for this public key.
func (_self *Secp256k1PublicKey) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Secp256k1PublicKey) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

// Returns the bytes with signature scheme flag prepended.
func (_self *Secp256k1PublicKey) ToFlaggedBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_to_flagged_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Secp256k1PublicKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256k1PublicKey struct {}

var FfiConverterSecp256k1PublicKeyINSTANCE = FfiConverterSecp256k1PublicKey{}


func (c FfiConverterSecp256k1PublicKey) Lift(pointer unsafe.Pointer) *Secp256k1PublicKey {
	result := &Secp256k1PublicKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256k1publickey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256k1publickey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256k1PublicKey).Destroy)
	return result
}

func (c FfiConverterSecp256k1PublicKey) Read(reader io.Reader) *Secp256k1PublicKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256k1PublicKey) Lower(value *Secp256k1PublicKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256k1PublicKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256k1PublicKey) Write(writer io.Writer, value *Secp256k1PublicKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256k1PublicKey struct {}

func (_ FfiDestroyerSecp256k1PublicKey) Destroy(value *Secp256k1PublicKey) {
		value.Destroy()
}



// A secp256k1 public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// secp256k1-public-key = 33OCTECT
// ```
type Secp256k1SignatureInterface interface {
	ToBytes() []byte
}
// A secp256k1 public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// secp256k1-public-key = 33OCTECT
// ```
type Secp256k1Signature struct {
	ffiObject FfiObject
}


func Secp256k1SignatureFromBytes(bytes []byte) (*Secp256k1Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func Secp256k1SignatureFromStr(s string) (*Secp256k1Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func Secp256k1SignatureGenerate() *Secp256k1Signature {
	return FfiConverterSecp256k1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_generate(_uniffiStatus)
	}))
}



func (_self *Secp256k1Signature) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1Signature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1signature_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Secp256k1Signature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256k1Signature struct {}

var FfiConverterSecp256k1SignatureINSTANCE = FfiConverterSecp256k1Signature{}


func (c FfiConverterSecp256k1Signature) Lift(pointer unsafe.Pointer) *Secp256k1Signature {
	result := &Secp256k1Signature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256k1signature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256k1signature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256k1Signature).Destroy)
	return result
}

func (c FfiConverterSecp256k1Signature) Read(reader io.Reader) *Secp256k1Signature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256k1Signature) Lower(value *Secp256k1Signature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256k1Signature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256k1Signature) Write(writer io.Writer, value *Secp256k1Signature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256k1Signature struct {}

func (_ FfiDestroyerSecp256k1Signature) Destroy(value *Secp256k1Signature) {
		value.Destroy()
}



type Secp256k1VerifierInterface interface {
	VerifySimple(message []byte, signature *SimpleSignature) error
	VerifyUser(message []byte, signature *UserSignature) error
}
type Secp256k1Verifier struct {
	ffiObject FfiObject
}
func NewSecp256k1Verifier() *Secp256k1Verifier {
	return FfiConverterSecp256k1VerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifier_new(_uniffiStatus)
	}))
}




func (_self *Secp256k1Verifier) VerifySimple(message []byte, signature *SimpleSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1Verifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256k1verifier_verify_simple(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterSimpleSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *Secp256k1Verifier) VerifyUser(message []byte, signature *UserSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1Verifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256k1verifier_verify_user(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterUserSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *Secp256k1Verifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256k1Verifier struct {}

var FfiConverterSecp256k1VerifierINSTANCE = FfiConverterSecp256k1Verifier{}


func (c FfiConverterSecp256k1Verifier) Lift(pointer unsafe.Pointer) *Secp256k1Verifier {
	result := &Secp256k1Verifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256k1verifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256k1verifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256k1Verifier).Destroy)
	return result
}

func (c FfiConverterSecp256k1Verifier) Read(reader io.Reader) *Secp256k1Verifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256k1Verifier) Lower(value *Secp256k1Verifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256k1Verifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256k1Verifier) Write(writer io.Writer, value *Secp256k1Verifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256k1Verifier struct {}

func (_ FfiDestroyerSecp256k1Verifier) Destroy(value *Secp256k1Verifier) {
		value.Destroy()
}



type Secp256k1VerifyingKeyInterface interface {
	PublicKey() *Secp256k1PublicKey
	// Serialize this public key as DER-encoded data
	ToDer() ([]byte, error)
	// Serialize this public key into PEM
	ToPem() (string, error)
	Verify(message []byte, signature *Secp256k1Signature) error
	VerifySimple(message []byte, signature *SimpleSignature) error
	VerifyUser(message []byte, signature *UserSignature) error
}
type Secp256k1VerifyingKey struct {
	ffiObject FfiObject
}
func NewSecp256k1VerifyingKey(publicKey *Secp256k1PublicKey) (*Secp256k1VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_new(FfiConverterSecp256k1PublicKeyINSTANCE.Lower(publicKey),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}


// Deserialize public key from ASN.1 DER-encoded data (binary format).
func Secp256k1VerifyingKeyFromDer(bytes []byte) (*Secp256k1VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_from_der(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize public key from PEM.
func Secp256k1VerifyingKeyFromPem(s string) (*Secp256k1VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_from_pem(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}



func (_self *Secp256k1VerifyingKey) PublicKey() *Secp256k1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256k1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_public_key(
		_pointer,_uniffiStatus)
	}))
}

// Serialize this public key as DER-encoded data
func (_self *Secp256k1VerifyingKey) ToDer() ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_to_der(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this public key into PEM
func (_self *Secp256k1VerifyingKey) ToPem() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_to_pem(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Secp256k1VerifyingKey) Verify(message []byte, signature *Secp256k1Signature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterSecp256k1SignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *Secp256k1VerifyingKey) VerifySimple(message []byte, signature *SimpleSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify_simple(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterSimpleSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *Secp256k1VerifyingKey) VerifyUser(message []byte, signature *UserSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256k1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify_user(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterUserSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *Secp256k1VerifyingKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256k1VerifyingKey struct {}

var FfiConverterSecp256k1VerifyingKeyINSTANCE = FfiConverterSecp256k1VerifyingKey{}


func (c FfiConverterSecp256k1VerifyingKey) Lift(pointer unsafe.Pointer) *Secp256k1VerifyingKey {
	result := &Secp256k1VerifyingKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256k1verifyingkey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256k1verifyingkey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256k1VerifyingKey).Destroy)
	return result
}

func (c FfiConverterSecp256k1VerifyingKey) Read(reader io.Reader) *Secp256k1VerifyingKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256k1VerifyingKey) Lower(value *Secp256k1VerifyingKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256k1VerifyingKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256k1VerifyingKey) Write(writer io.Writer, value *Secp256k1VerifyingKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256k1VerifyingKey struct {}

func (_ FfiDestroyerSecp256k1VerifyingKey) Destroy(value *Secp256k1VerifyingKey) {
		value.Destroy()
}



type Secp256r1PrivateKeyInterface interface {
	// Get the public key corresponding to this private key.
	PublicKey() *Secp256r1PublicKey
	Scheme() SignatureScheme
	// Sign a personal message and return a UserSignature.
	SignPersonalMessage(message *PersonalMessage) (*UserSignature, error)
	// Sign a transaction and return a UserSignature.
	SignTransaction(transaction *Transaction) (*UserSignature, error)
	// Encode this private key as `flag || privkey` in Bech32 starting with
	// "iotaprivkey" to a string.
	ToBech32() (string, error)
	// Serialize this private key to bytes.
	ToBytes() []byte
	// Serialize this private key as DER-encoded PKCS#8
	ToDer() ([]byte, error)
	// Serialize this private key as PEM-encoded PKCS#8
	ToPem() (string, error)
	// Sign a message and return a Secp256r1Signature.
	TrySign(message []byte) (*Secp256r1Signature, error)
	// Sign a message and return a SimpleSignature.
	TrySignSimple(message []byte) (*SimpleSignature, error)
	// Sign a message and return a UserSignature.
	TrySignUser(message []byte) (*UserSignature, error)
	VerifyingKey() *Secp256r1VerifyingKey
}
type Secp256r1PrivateKey struct {
	ffiObject FfiObject
}
func NewSecp256r1PrivateKey(bytes []byte) (*Secp256r1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_new(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}


// Decode a private key from `flag || privkey` in Bech32 starting with
// "iotaprivkey".
func Secp256r1PrivateKeyFromBech32(value string) (*Secp256r1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_bech32(FfiConverterStringINSTANCE.Lower(value),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
// format).
func Secp256r1PrivateKeyFromDer(bytes []byte) (*Secp256r1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_der(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Construct the private key from a mnemonic phrase
func Secp256r1PrivateKeyFromMnemonic(phrase string, accountIndex uint64, password string) (*Secp256r1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_mnemonic(FfiConverterStringINSTANCE.Lower(phrase), FfiConverterUint64INSTANCE.Lower(accountIndex), FfiConverterStringINSTANCE.Lower(password),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create an instance from a mnemonic phrase and a derivation path like
// `"m/74'/4218'/0'/0/0"`
func Secp256r1PrivateKeyFromMnemonicWithPath(phrase string, path string, password string) (*Secp256r1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_mnemonic_with_path(FfiConverterStringINSTANCE.Lower(phrase), FfiConverterStringINSTANCE.Lower(path), FfiConverterStringINSTANCE.Lower(password),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize PKCS#8-encoded private key from PEM.
func Secp256r1PrivateKeyFromPem(s string) (*Secp256r1PrivateKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_pem(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1PrivateKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1PrivateKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Generate a new random Secp256r1PrivateKey
func Secp256r1PrivateKeyGenerate() *Secp256r1PrivateKey {
	return FfiConverterSecp256r1PrivateKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_generate(_uniffiStatus)
	}))
}



// Get the public key corresponding to this private key.
func (_self *Secp256r1PrivateKey) PublicKey() *Secp256r1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256r1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_public_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Secp256r1PrivateKey) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

// Sign a personal message and return a UserSignature.
func (_self *Secp256r1PrivateKey) SignPersonalMessage(message *PersonalMessage) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_sign_personal_message(
		_pointer,FfiConverterPersonalMessageINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Sign a transaction and return a UserSignature.
func (_self *Secp256r1PrivateKey) SignTransaction(transaction *Transaction) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_sign_transaction(
		_pointer,FfiConverterTransactionINSTANCE.Lower(transaction),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Encode this private key as `flag || privkey` in Bech32 starting with
// "iotaprivkey" to a string.
func (_self *Secp256r1PrivateKey) ToBech32() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_bech32(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this private key to bytes.
func (_self *Secp256r1PrivateKey) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

// Serialize this private key as DER-encoded PKCS#8
func (_self *Secp256r1PrivateKey) ToDer() ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_der(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this private key as PEM-encoded PKCS#8
func (_self *Secp256r1PrivateKey) ToPem() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_pem(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

// Sign a message and return a Secp256r1Signature.
func (_self *Secp256r1PrivateKey) TrySign(message []byte) (*Secp256r1Signature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Sign a message and return a SimpleSignature.
func (_self *Secp256r1PrivateKey) TrySignSimple(message []byte) (*SimpleSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign_simple(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Sign a message and return a UserSignature.
func (_self *Secp256r1PrivateKey) TrySignUser(message []byte) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign_user(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Secp256r1PrivateKey) VerifyingKey() *Secp256r1VerifyingKey {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256r1VerifyingKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_verifying_key(
		_pointer,_uniffiStatus)
	}))
}
func (object *Secp256r1PrivateKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256r1PrivateKey struct {}

var FfiConverterSecp256r1PrivateKeyINSTANCE = FfiConverterSecp256r1PrivateKey{}


func (c FfiConverterSecp256r1PrivateKey) Lift(pointer unsafe.Pointer) *Secp256r1PrivateKey {
	result := &Secp256r1PrivateKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256r1privatekey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256r1privatekey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256r1PrivateKey).Destroy)
	return result
}

func (c FfiConverterSecp256r1PrivateKey) Read(reader io.Reader) *Secp256r1PrivateKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256r1PrivateKey) Lower(value *Secp256r1PrivateKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256r1PrivateKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256r1PrivateKey) Write(writer io.Writer, value *Secp256r1PrivateKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256r1PrivateKey struct {}

func (_ FfiDestroyerSecp256r1PrivateKey) Destroy(value *Secp256r1PrivateKey) {
		value.Destroy()
}



// A secp256r1 signature.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// secp256r1-signature = 64OCTECT
// ```
type Secp256r1PublicKeyInterface interface {
	// Derive an `Address` from this Public Key
	//
	// An `Address` can be derived from a `Secp256r1PublicKey` by hashing the
	// bytes of the public key prefixed with the Secp256r1
	// `SignatureScheme` flag (`0x02`).
	//
	// `hash( 0x02 || 33-byte secp256r1 public key)`
	DeriveAddress() *Address
	// Returns the signature scheme for this public key.
	Scheme() SignatureScheme
	ToBytes() []byte
	// Returns the bytes with signature scheme flag prepended
	ToFlaggedBytes() []byte
}
// A secp256r1 signature.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// secp256r1-signature = 64OCTECT
// ```
type Secp256r1PublicKey struct {
	ffiObject FfiObject
}


func Secp256r1PublicKeyFromBytes(bytes []byte) (*Secp256r1PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Secp256r1PublicKeyFromStr(s string) (*Secp256r1PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

func Secp256r1PublicKeyGenerate() *Secp256r1PublicKey {
	return FfiConverterSecp256r1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_generate(_uniffiStatus)
	}))
}



// Derive an `Address` from this Public Key
//
// An `Address` can be derived from a `Secp256r1PublicKey` by hashing the
// bytes of the public key prefixed with the Secp256r1
// `SignatureScheme` flag (`0x02`).
//
// `hash( 0x02 || 33-byte secp256r1 public key)`
func (_self *Secp256r1PublicKey) DeriveAddress() *Address {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_derive_address(
		_pointer,_uniffiStatus)
	}))
}

// Returns the signature scheme for this public key.
func (_self *Secp256r1PublicKey) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Secp256r1PublicKey) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

// Returns the bytes with signature scheme flag prepended
func (_self *Secp256r1PublicKey) ToFlaggedBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1PublicKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_to_flagged_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Secp256r1PublicKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256r1PublicKey struct {}

var FfiConverterSecp256r1PublicKeyINSTANCE = FfiConverterSecp256r1PublicKey{}


func (c FfiConverterSecp256r1PublicKey) Lift(pointer unsafe.Pointer) *Secp256r1PublicKey {
	result := &Secp256r1PublicKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256r1publickey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256r1publickey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256r1PublicKey).Destroy)
	return result
}

func (c FfiConverterSecp256r1PublicKey) Read(reader io.Reader) *Secp256r1PublicKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256r1PublicKey) Lower(value *Secp256r1PublicKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256r1PublicKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256r1PublicKey) Write(writer io.Writer, value *Secp256r1PublicKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256r1PublicKey struct {}

func (_ FfiDestroyerSecp256r1PublicKey) Destroy(value *Secp256r1PublicKey) {
		value.Destroy()
}



// A secp256r1 public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// secp256r1-public-key = 33OCTECT
// ```
type Secp256r1SignatureInterface interface {
	ToBytes() []byte
}
// A secp256r1 public key.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// secp256r1-public-key = 33OCTECT
// ```
type Secp256r1Signature struct {
	ffiObject FfiObject
}


func Secp256r1SignatureFromBytes(bytes []byte) (*Secp256r1Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func Secp256r1SignatureFromStr(s string) (*Secp256r1Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_from_str(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func Secp256r1SignatureGenerate() *Secp256r1Signature {
	return FfiConverterSecp256r1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_generate(_uniffiStatus)
	}))
}



func (_self *Secp256r1Signature) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1Signature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1signature_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Secp256r1Signature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256r1Signature struct {}

var FfiConverterSecp256r1SignatureINSTANCE = FfiConverterSecp256r1Signature{}


func (c FfiConverterSecp256r1Signature) Lift(pointer unsafe.Pointer) *Secp256r1Signature {
	result := &Secp256r1Signature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256r1signature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256r1signature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256r1Signature).Destroy)
	return result
}

func (c FfiConverterSecp256r1Signature) Read(reader io.Reader) *Secp256r1Signature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256r1Signature) Lower(value *Secp256r1Signature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256r1Signature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256r1Signature) Write(writer io.Writer, value *Secp256r1Signature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256r1Signature struct {}

func (_ FfiDestroyerSecp256r1Signature) Destroy(value *Secp256r1Signature) {
		value.Destroy()
}



type Secp256r1VerifierInterface interface {
	VerifySimple(message []byte, signature *SimpleSignature) error
	VerifyUser(message []byte, signature *UserSignature) error
}
type Secp256r1Verifier struct {
	ffiObject FfiObject
}
func NewSecp256r1Verifier() *Secp256r1Verifier {
	return FfiConverterSecp256r1VerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifier_new(_uniffiStatus)
	}))
}




func (_self *Secp256r1Verifier) VerifySimple(message []byte, signature *SimpleSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1Verifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256r1verifier_verify_simple(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterSimpleSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *Secp256r1Verifier) VerifyUser(message []byte, signature *UserSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1Verifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256r1verifier_verify_user(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterUserSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *Secp256r1Verifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256r1Verifier struct {}

var FfiConverterSecp256r1VerifierINSTANCE = FfiConverterSecp256r1Verifier{}


func (c FfiConverterSecp256r1Verifier) Lift(pointer unsafe.Pointer) *Secp256r1Verifier {
	result := &Secp256r1Verifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256r1verifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256r1verifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256r1Verifier).Destroy)
	return result
}

func (c FfiConverterSecp256r1Verifier) Read(reader io.Reader) *Secp256r1Verifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256r1Verifier) Lower(value *Secp256r1Verifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256r1Verifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256r1Verifier) Write(writer io.Writer, value *Secp256r1Verifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256r1Verifier struct {}

func (_ FfiDestroyerSecp256r1Verifier) Destroy(value *Secp256r1Verifier) {
		value.Destroy()
}



type Secp256r1VerifyingKeyInterface interface {
	PublicKey() *Secp256r1PublicKey
	// Serialize this public key as DER-encoded data.
	ToDer() ([]byte, error)
	// Serialize this public key into PEM.
	ToPem() (string, error)
	Verify(message []byte, signature *Secp256r1Signature) error
	VerifySimple(message []byte, signature *SimpleSignature) error
	VerifyUser(message []byte, signature *UserSignature) error
}
type Secp256r1VerifyingKey struct {
	ffiObject FfiObject
}
func NewSecp256r1VerifyingKey(publicKey *Secp256r1PublicKey) (*Secp256r1VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_new(FfiConverterSecp256r1PublicKeyINSTANCE.Lower(publicKey),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}


// Deserialize public key from ASN.1 DER-encoded data (binary format).
func Secp256r1VerifyingKeyFromDer(bytes []byte) (*Secp256r1VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_from_der(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize public key from PEM.
func Secp256r1VerifyingKeyFromPem(s string) (*Secp256r1VerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_from_pem(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1VerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1VerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}



func (_self *Secp256r1VerifyingKey) PublicKey() *Secp256r1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256r1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_public_key(
		_pointer,_uniffiStatus)
	}))
}

// Serialize this public key as DER-encoded data.
func (_self *Secp256r1VerifyingKey) ToDer() ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_to_der(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this public key into PEM.
func (_self *Secp256r1VerifyingKey) ToPem() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_to_pem(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *Secp256r1VerifyingKey) Verify(message []byte, signature *Secp256r1Signature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterSecp256r1SignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *Secp256r1VerifyingKey) VerifySimple(message []byte, signature *SimpleSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify_simple(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterSimpleSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *Secp256r1VerifyingKey) VerifyUser(message []byte, signature *UserSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*Secp256r1VerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify_user(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterUserSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *Secp256r1VerifyingKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSecp256r1VerifyingKey struct {}

var FfiConverterSecp256r1VerifyingKeyINSTANCE = FfiConverterSecp256r1VerifyingKey{}


func (c FfiConverterSecp256r1VerifyingKey) Lift(pointer unsafe.Pointer) *Secp256r1VerifyingKey {
	result := &Secp256r1VerifyingKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_secp256r1verifyingkey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_secp256r1verifyingkey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Secp256r1VerifyingKey).Destroy)
	return result
}

func (c FfiConverterSecp256r1VerifyingKey) Read(reader io.Reader) *Secp256r1VerifyingKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSecp256r1VerifyingKey) Lower(value *Secp256r1VerifyingKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Secp256r1VerifyingKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSecp256r1VerifyingKey) Write(writer io.Writer, value *Secp256r1VerifyingKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSecp256r1VerifyingKey struct {}

func (_ FfiDestroyerSecp256r1VerifyingKey) Destroy(value *Secp256r1VerifyingKey) {
		value.Destroy()
}



type SimpleKeypairInterface interface {
	PublicKey() *MultisigMemberPublicKey
	Scheme() SignatureScheme
	// Sign a personal message and return a UserSignature.
	SignPersonalMessage(message *PersonalMessage) (*UserSignature, error)
	// Sign a transaction and return a UserSignature.
	SignTransaction(transaction *Transaction) (*UserSignature, error)
	// Encode a SimpleKeypair as `flag || privkey` in Bech32 starting with
	// "iotaprivkey" to a string. Note that the pubkey is not encoded.
	ToBech32() (string, error)
	// Encode a SimpleKeypair as `flag || privkey` in bytes
	ToBytes() []byte
	// Serialize this private key as DER-encoded PKCS#8
	ToDer() ([]byte, error)
	// Serialize this private key as DER-encoded PKCS#8
	ToPem() (string, error)
	TrySign(message []byte) (*SimpleSignature, error)
	TrySignUser(message []byte) (*UserSignature, error)
	VerifyingKey() *SimpleVerifyingKey
}
type SimpleKeypair struct {
	ffiObject FfiObject
}


// Decode a SimpleKeypair from `flag || privkey` in Bech32 starting with
// "iotaprivkey" to SimpleKeypair. The public key is computed directly from
// the private key bytes.
func SimpleKeypairFromBech32(value string) (*SimpleKeypair, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_bech32(FfiConverterStringINSTANCE.Lower(value),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleKeypair
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleKeypairINSTANCE.Lift(_uniffiRV), nil
		}
}

// Decode a SimpleKeypair from `flag || privkey` bytes
func SimpleKeypairFromBytes(bytes []byte) (*SimpleKeypair, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleKeypair
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleKeypairINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
// format).
func SimpleKeypairFromDer(bytes []byte) (*SimpleKeypair, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_der(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleKeypair
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleKeypairINSTANCE.Lift(_uniffiRV), nil
		}
}

func SimpleKeypairFromEd25519(keypair *Ed25519PrivateKey) *SimpleKeypair {
	return FfiConverterSimpleKeypairINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_ed25519(FfiConverterEd25519PrivateKeyINSTANCE.Lower(keypair),_uniffiStatus)
	}))
}

// Deserialize PKCS#8-encoded private key from PEM.
func SimpleKeypairFromPem(s string) (*SimpleKeypair, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_pem(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleKeypair
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleKeypairINSTANCE.Lift(_uniffiRV), nil
		}
}

func SimpleKeypairFromSecp256k1(keypair *Secp256k1PrivateKey) *SimpleKeypair {
	return FfiConverterSimpleKeypairINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_secp256k1(FfiConverterSecp256k1PrivateKeyINSTANCE.Lower(keypair),_uniffiStatus)
	}))
}

func SimpleKeypairFromSecp256r1(keypair *Secp256r1PrivateKey) *SimpleKeypair {
	return FfiConverterSimpleKeypairINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_secp256r1(FfiConverterSecp256r1PrivateKeyINSTANCE.Lower(keypair),_uniffiStatus)
	}))
}



func (_self *SimpleKeypair) PublicKey() *MultisigMemberPublicKey {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMultisigMemberPublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_public_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleKeypair) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

// Sign a personal message and return a UserSignature.
func (_self *SimpleKeypair) SignPersonalMessage(message *PersonalMessage) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_sign_personal_message(
		_pointer,FfiConverterPersonalMessageINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Sign a transaction and return a UserSignature.
func (_self *SimpleKeypair) SignTransaction(transaction *Transaction) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_sign_transaction(
		_pointer,FfiConverterTransactionINSTANCE.Lower(transaction),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Encode a SimpleKeypair as `flag || privkey` in Bech32 starting with
// "iotaprivkey" to a string. Note that the pubkey is not encoded.
func (_self *SimpleKeypair) ToBech32() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_bech32(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

// Encode a SimpleKeypair as `flag || privkey` in bytes
func (_self *SimpleKeypair) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}

// Serialize this private key as DER-encoded PKCS#8
func (_self *SimpleKeypair) ToDer() ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_der(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this private key as DER-encoded PKCS#8
func (_self *SimpleKeypair) ToPem() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_pem(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *SimpleKeypair) TrySign(message []byte) (*SimpleSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_try_sign(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *SimpleKeypair) TrySignUser(message []byte) (*UserSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_try_sign_user(
		_pointer,FfiConverterBytesINSTANCE.Lower(message),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *SimpleKeypair) VerifyingKey() *SimpleVerifyingKey {
	_pointer := _self.ffiObject.incrementPointer("*SimpleKeypair")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSimpleVerifyingKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplekeypair_verifying_key(
		_pointer,_uniffiStatus)
	}))
}
func (object *SimpleKeypair) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSimpleKeypair struct {}

var FfiConverterSimpleKeypairINSTANCE = FfiConverterSimpleKeypair{}


func (c FfiConverterSimpleKeypair) Lift(pointer unsafe.Pointer) *SimpleKeypair {
	result := &SimpleKeypair {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_simplekeypair(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_simplekeypair(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SimpleKeypair).Destroy)
	return result
}

func (c FfiConverterSimpleKeypair) Read(reader io.Reader) *SimpleKeypair {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSimpleKeypair) Lower(value *SimpleKeypair) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SimpleKeypair")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSimpleKeypair) Write(writer io.Writer, value *SimpleKeypair) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSimpleKeypair struct {}

func (_ FfiDestroyerSimpleKeypair) Destroy(value *SimpleKeypair) {
		value.Destroy()
}



// A basic signature
//
// This enumeration defines the set of simple or basic signature schemes
// supported by IOTA. Most signature schemes supported by IOTA end up
// comprising of a at least one simple signature scheme.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// simple-signature-bcs = bytes ; where the contents of the bytes are defined by <simple-signature>
// simple-signature = (ed25519-flag ed25519-signature ed25519-public-key) /
// (secp256k1-flag secp256k1-signature secp256k1-public-key) /
// (secp256r1-flag secp256r1-signature secp256r1-public-key)
// ```
//
// Note: Due to historical reasons, signatures are serialized slightly
// different from the majority of the types in IOTA. In particular if a
// signature is ever embedded in another structure it generally is serialized
// as `bytes` meaning it has a length prefix that defines the length of
// the completely serialized signature.
type SimpleSignatureInterface interface {
	Ed25519PubKey() *Ed25519PublicKey
	Ed25519PubKeyOpt() **Ed25519PublicKey
	Ed25519Sig() *Ed25519Signature
	Ed25519SigOpt() **Ed25519Signature
	IsEd25519() bool
	IsSecp256k1() bool
	IsSecp256r1() bool
	Scheme() SignatureScheme
	Secp256k1PubKey() *Secp256k1PublicKey
	Secp256k1PubKeyOpt() **Secp256k1PublicKey
	Secp256k1Sig() *Secp256k1Signature
	Secp256k1SigOpt() **Secp256k1Signature
	Secp256r1PubKey() *Secp256r1PublicKey
	Secp256r1PubKeyOpt() **Secp256r1PublicKey
	Secp256r1Sig() *Secp256r1Signature
	Secp256r1SigOpt() **Secp256r1Signature
	ToBytes() []byte
}
// A basic signature
//
// This enumeration defines the set of simple or basic signature schemes
// supported by IOTA. Most signature schemes supported by IOTA end up
// comprising of a at least one simple signature scheme.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// simple-signature-bcs = bytes ; where the contents of the bytes are defined by <simple-signature>
// simple-signature = (ed25519-flag ed25519-signature ed25519-public-key) /
// (secp256k1-flag secp256k1-signature secp256k1-public-key) /
// (secp256r1-flag secp256r1-signature secp256r1-public-key)
// ```
//
// Note: Due to historical reasons, signatures are serialized slightly
// different from the majority of the types in IOTA. In particular if a
// signature is ever embedded in another structure it generally is serialized
// as `bytes` meaning it has a length prefix that defines the length of
// the completely serialized signature.
type SimpleSignature struct {
	ffiObject FfiObject
}


func SimpleSignatureNewEd25519(signature *Ed25519Signature, publicKey *Ed25519PublicKey) *SimpleSignature {
	return FfiConverterSimpleSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_ed25519(FfiConverterEd25519SignatureINSTANCE.Lower(signature), FfiConverterEd25519PublicKeyINSTANCE.Lower(publicKey),_uniffiStatus)
	}))
}

func SimpleSignatureNewSecp256k1(signature *Secp256k1Signature, publicKey *Secp256k1PublicKey) *SimpleSignature {
	return FfiConverterSimpleSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_secp256k1(FfiConverterSecp256k1SignatureINSTANCE.Lower(signature), FfiConverterSecp256k1PublicKeyINSTANCE.Lower(publicKey),_uniffiStatus)
	}))
}

func SimpleSignatureNewSecp256r1(signature *Secp256r1Signature, publicKey *Secp256r1PublicKey) *SimpleSignature {
	return FfiConverterSimpleSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_secp256r1(FfiConverterSecp256r1SignatureINSTANCE.Lower(signature), FfiConverterSecp256r1PublicKeyINSTANCE.Lower(publicKey),_uniffiStatus)
	}))
}



func (_self *SimpleSignature) Ed25519PubKey() *Ed25519PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterEd25519PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_pub_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleSignature) Ed25519PubKeyOpt() **Ed25519PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalEd25519PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_pub_key_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *SimpleSignature) Ed25519Sig() *Ed25519Signature {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterEd25519SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_sig(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleSignature) Ed25519SigOpt() **Ed25519Signature {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalEd25519SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_sig_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *SimpleSignature) IsEd25519() bool {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_ed25519(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleSignature) IsSecp256k1() bool {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_secp256k1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleSignature) IsSecp256r1() bool {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_secp256r1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleSignature) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplesignature_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *SimpleSignature) Secp256k1PubKey() *Secp256k1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256k1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_pub_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleSignature) Secp256k1PubKeyOpt() **Secp256k1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSecp256k1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_pub_key_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *SimpleSignature) Secp256k1Sig() *Secp256k1Signature {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256k1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_sig(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleSignature) Secp256k1SigOpt() **Secp256k1Signature {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSecp256k1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_sig_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *SimpleSignature) Secp256r1PubKey() *Secp256r1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256r1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_pub_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleSignature) Secp256r1PubKeyOpt() **Secp256r1PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSecp256r1PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_pub_key_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *SimpleSignature) Secp256r1Sig() *Secp256r1Signature {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSecp256r1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_sig(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleSignature) Secp256r1SigOpt() **Secp256r1Signature {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSecp256r1SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_sig_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *SimpleSignature) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*SimpleSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simplesignature_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *SimpleSignature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSimpleSignature struct {}

var FfiConverterSimpleSignatureINSTANCE = FfiConverterSimpleSignature{}


func (c FfiConverterSimpleSignature) Lift(pointer unsafe.Pointer) *SimpleSignature {
	result := &SimpleSignature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_simplesignature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_simplesignature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SimpleSignature).Destroy)
	return result
}

func (c FfiConverterSimpleSignature) Read(reader io.Reader) *SimpleSignature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSimpleSignature) Lower(value *SimpleSignature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SimpleSignature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSimpleSignature) Write(writer io.Writer, value *SimpleSignature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSimpleSignature struct {}

func (_ FfiDestroyerSimpleSignature) Destroy(value *SimpleSignature) {
		value.Destroy()
}



type SimpleVerifierInterface interface {
	Verify(message []byte, signature *SimpleSignature) error
}
type SimpleVerifier struct {
	ffiObject FfiObject
}
func NewSimpleVerifier() *SimpleVerifier {
	return FfiConverterSimpleVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simpleverifier_new(_uniffiStatus)
	}))
}




func (_self *SimpleVerifier) Verify(message []byte, signature *SimpleSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*SimpleVerifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_simpleverifier_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterSimpleSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *SimpleVerifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSimpleVerifier struct {}

var FfiConverterSimpleVerifierINSTANCE = FfiConverterSimpleVerifier{}


func (c FfiConverterSimpleVerifier) Lift(pointer unsafe.Pointer) *SimpleVerifier {
	result := &SimpleVerifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_simpleverifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_simpleverifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SimpleVerifier).Destroy)
	return result
}

func (c FfiConverterSimpleVerifier) Read(reader io.Reader) *SimpleVerifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSimpleVerifier) Lower(value *SimpleVerifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SimpleVerifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSimpleVerifier) Write(writer io.Writer, value *SimpleVerifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSimpleVerifier struct {}

func (_ FfiDestroyerSimpleVerifier) Destroy(value *SimpleVerifier) {
		value.Destroy()
}



type SimpleVerifyingKeyInterface interface {
	PublicKey() *MultisigMemberPublicKey
	Scheme() SignatureScheme
	// Serialize this private key as DER-encoded PKCS#8
	ToDer() ([]byte, error)
	// Serialize this private key as DER-encoded PKCS#8
	ToPem() (string, error)
	Verify(message []byte, signature *SimpleSignature) error
}
type SimpleVerifyingKey struct {
	ffiObject FfiObject
}


// Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
// format).
func SimpleVerifyingKeyFromDer(bytes []byte) (*SimpleVerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simpleverifyingkey_from_der(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleVerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleVerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Deserialize PKCS#8-encoded private key from PEM.
func SimpleVerifyingKeyFromPem(s string) (*SimpleVerifyingKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_simpleverifyingkey_from_pem(FfiConverterStringINSTANCE.Lower(s),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleVerifyingKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleVerifyingKeyINSTANCE.Lift(_uniffiRV), nil
		}
}



func (_self *SimpleVerifyingKey) PublicKey() *MultisigMemberPublicKey {
	_pointer := _self.ffiObject.incrementPointer("*SimpleVerifyingKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMultisigMemberPublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_public_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *SimpleVerifyingKey) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*SimpleVerifyingKey")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

// Serialize this private key as DER-encoded PKCS#8
func (_self *SimpleVerifyingKey) ToDer() ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*SimpleVerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_to_der(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Serialize this private key as DER-encoded PKCS#8
func (_self *SimpleVerifyingKey) ToPem() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*SimpleVerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_to_pem(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *SimpleVerifyingKey) Verify(message []byte, signature *SimpleSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*SimpleVerifyingKey")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterSimpleSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *SimpleVerifyingKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSimpleVerifyingKey struct {}

var FfiConverterSimpleVerifyingKeyINSTANCE = FfiConverterSimpleVerifyingKey{}


func (c FfiConverterSimpleVerifyingKey) Lift(pointer unsafe.Pointer) *SimpleVerifyingKey {
	result := &SimpleVerifyingKey {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_simpleverifyingkey(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_simpleverifyingkey(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SimpleVerifyingKey).Destroy)
	return result
}

func (c FfiConverterSimpleVerifyingKey) Read(reader io.Reader) *SimpleVerifyingKey {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSimpleVerifyingKey) Lower(value *SimpleVerifyingKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SimpleVerifyingKey")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSimpleVerifyingKey) Write(writer io.Writer, value *SimpleVerifyingKey) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSimpleVerifyingKey struct {}

func (_ FfiDestroyerSimpleVerifyingKey) Destroy(value *SimpleVerifyingKey) {
		value.Destroy()
}



// Command to split a single coin object into multiple coins
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// split-coins = argument (vector argument)
// ```
type SplitCoinsInterface interface {
	// The amounts to split off
	Amounts() []*Argument
	// The coin to split
	Coin() *Argument
}
// Command to split a single coin object into multiple coins
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// split-coins = argument (vector argument)
// ```
type SplitCoins struct {
	ffiObject FfiObject
}
func NewSplitCoins(coin *Argument, amounts []*Argument) *SplitCoins {
	return FfiConverterSplitCoinsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_splitcoins_new(FfiConverterArgumentINSTANCE.Lower(coin), FfiConverterSequenceArgumentINSTANCE.Lower(amounts),_uniffiStatus)
	}))
}




// The amounts to split off
func (_self *SplitCoins) Amounts() []*Argument {
	_pointer := _self.ffiObject.incrementPointer("*SplitCoins")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_splitcoins_amounts(
		_pointer,_uniffiStatus),
	}
	}))
}

// The coin to split
func (_self *SplitCoins) Coin() *Argument {
	_pointer := _self.ffiObject.incrementPointer("*SplitCoins")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_splitcoins_coin(
		_pointer,_uniffiStatus)
	}))
}
func (object *SplitCoins) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSplitCoins struct {}

var FfiConverterSplitCoinsINSTANCE = FfiConverterSplitCoins{}


func (c FfiConverterSplitCoins) Lift(pointer unsafe.Pointer) *SplitCoins {
	result := &SplitCoins {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_splitcoins(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_splitcoins(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SplitCoins).Destroy)
	return result
}

func (c FfiConverterSplitCoins) Read(reader io.Reader) *SplitCoins {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSplitCoins) Lower(value *SplitCoins) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SplitCoins")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSplitCoins) Write(writer io.Writer, value *SplitCoins) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSplitCoins struct {}

func (_ FfiDestroyerSplitCoins) Destroy(value *SplitCoins) {
		value.Destroy()
}



// Type information for a move struct
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// struct-tag = address            ; address of the package
// identifier         ; name of the module
// identifier         ; name of the type
// (vector type-tag)  ; type parameters
// ```
type StructTagInterface interface {
	// Returns the address part of a `StructTag`
	Address() *Address
	// Checks if this is a Coin type
	CoinType() *TypeTag
	// Checks if this is a Coin type
	CoinTypeOpt() **TypeTag
	// Returns the module part of a `StructTag`
	Module() *Identifier
	// Returns the name part of a `StructTag`
	Name() *Identifier
	// Returns the type params part of a `StructTag`
	TypeArgs() []*TypeTag
}
// Type information for a move struct
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// struct-tag = address            ; address of the package
// identifier         ; name of the module
// identifier         ; name of the type
// (vector type-tag)  ; type parameters
// ```
type StructTag struct {
	ffiObject FfiObject
}
func NewStructTag(address *Address, module *Identifier, name *Identifier, typeParams []*TypeTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new(FfiConverterAddressINSTANCE.Lower(address), FfiConverterIdentifierINSTANCE.Lower(module), FfiConverterIdentifierINSTANCE.Lower(name), FfiConverterSequenceTypeTagINSTANCE.Lower(typeParams),_uniffiStatus)
	}))
}


func StructTagNewAsciiString() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_ascii_string(_uniffiStatus)
	}))
}

func StructTagNewBalance(typeTag *TypeTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_balance(FfiConverterTypeTagINSTANCE.Lower(typeTag),_uniffiStatus)
	}))
}

func StructTagNewClock() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_clock(_uniffiStatus)
	}))
}

func StructTagNewCoin(typeTag *TypeTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin(FfiConverterTypeTagINSTANCE.Lower(typeTag),_uniffiStatus)
	}))
}

func StructTagNewCoinManager(structTag *StructTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin_manager(FfiConverterStructTagINSTANCE.Lower(structTag),_uniffiStatus)
	}))
}

func StructTagNewCoinMetadata(structTag *StructTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin_metadata(FfiConverterStructTagINSTANCE.Lower(structTag),_uniffiStatus)
	}))
}

func StructTagNewConfig() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_config(_uniffiStatus)
	}))
}

func StructTagNewConfigSetting(typeTag *TypeTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_config_setting(FfiConverterTypeTagINSTANCE.Lower(typeTag),_uniffiStatus)
	}))
}

func StructTagNewDenyListAddressKey() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_address_key(_uniffiStatus)
	}))
}

func StructTagNewDenyListConfigKey() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_config_key(_uniffiStatus)
	}))
}

func StructTagNewDenyListGlobalPauseKey() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_global_pause_key(_uniffiStatus)
	}))
}

func StructTagNewDisplayCreated(structTag *StructTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_display_created(FfiConverterStructTagINSTANCE.Lower(structTag),_uniffiStatus)
	}))
}

func StructTagNewDynamicObjectFieldWrapper(typeTag *TypeTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_dynamic_object_field_wrapper(FfiConverterTypeTagINSTANCE.Lower(typeTag),_uniffiStatus)
	}))
}

func StructTagNewField(key *TypeTag, value *TypeTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_field(FfiConverterTypeTagINSTANCE.Lower(key), FfiConverterTypeTagINSTANCE.Lower(value),_uniffiStatus)
	}))
}

func StructTagNewGasCoin() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_gas_coin(_uniffiStatus)
	}))
}

func StructTagNewId() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_id(_uniffiStatus)
	}))
}

func StructTagNewIotaCoinType() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_coin_type(_uniffiStatus)
	}))
}

func StructTagNewIotaSystemAdminCap() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_system_admin_cap(_uniffiStatus)
	}))
}

func StructTagNewIotaSystemState() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_system_state(_uniffiStatus)
	}))
}

func StructTagNewIotaTreasuryCap() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_treasury_cap(_uniffiStatus)
	}))
}

func StructTagNewName(address *Address) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_name(FfiConverterAddressINSTANCE.Lower(address),_uniffiStatus)
	}))
}

func StructTagNewStakedIota() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_staked_iota(_uniffiStatus)
	}))
}

func StructTagNewString() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_string(_uniffiStatus)
	}))
}

func StructTagNewSystemEpochInfoEvent() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_system_epoch_info_event(_uniffiStatus)
	}))
}

func StructTagNewTimeLock(typeTag *TypeTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_time_lock(FfiConverterTypeTagINSTANCE.Lower(typeTag),_uniffiStatus)
	}))
}

func StructTagNewTimelockedStakedIota() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_timelocked_staked_iota(_uniffiStatus)
	}))
}

func StructTagNewTransferReceiving() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_transfer_receiving(_uniffiStatus)
	}))
}

func StructTagNewTreasuryCap(structTag *StructTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_treasury_cap(FfiConverterStructTagINSTANCE.Lower(structTag),_uniffiStatus)
	}))
}

func StructTagNewUid() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_uid(_uniffiStatus)
	}))
}

func StructTagNewUpgradeCap() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_cap(_uniffiStatus)
	}))
}

func StructTagNewUpgradeReceipt() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_receipt(_uniffiStatus)
	}))
}

func StructTagNewUpgradeTicket() *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_ticket(_uniffiStatus)
	}))
}

func StructTagNewVersionUpdated(structTag *StructTag) *StructTag {
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_version_updated(FfiConverterStructTagINSTANCE.Lower(structTag),_uniffiStatus)
	}))
}



// Returns the address part of a `StructTag`
func (_self *StructTag) Address() *Address {
	_pointer := _self.ffiObject.incrementPointer("*StructTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_structtag_address(
		_pointer,_uniffiStatus)
	}))
}

// Checks if this is a Coin type
func (_self *StructTag) CoinType() *TypeTag {
	_pointer := _self.ffiObject.incrementPointer("*StructTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_structtag_coin_type(
		_pointer,_uniffiStatus)
	}))
}

// Checks if this is a Coin type
func (_self *StructTag) CoinTypeOpt() **TypeTag {
	_pointer := _self.ffiObject.incrementPointer("*StructTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_structtag_coin_type_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

// Returns the module part of a `StructTag`
func (_self *StructTag) Module() *Identifier {
	_pointer := _self.ffiObject.incrementPointer("*StructTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterIdentifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_structtag_module(
		_pointer,_uniffiStatus)
	}))
}

// Returns the name part of a `StructTag`
func (_self *StructTag) Name() *Identifier {
	_pointer := _self.ffiObject.incrementPointer("*StructTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterIdentifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_structtag_name(
		_pointer,_uniffiStatus)
	}))
}

// Returns the type params part of a `StructTag`
func (_self *StructTag) TypeArgs() []*TypeTag {
	_pointer := _self.ffiObject.incrementPointer("*StructTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_structtag_type_args(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *StructTag) String() string {
	_pointer := _self.ffiObject.incrementPointer("*StructTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_display(
		_pointer,_uniffiStatus),
	}
	}))
}



func (_self *StructTag) Eq(other *StructTag) bool {
	_pointer := _self.ffiObject.incrementPointer("*StructTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_eq_eq(
		_pointer,FfiConverterStructTagINSTANCE.Lower(other),_uniffiStatus)
	}))
}

func (_self *StructTag) Ne(other *StructTag) bool {
	_pointer := _self.ffiObject.incrementPointer("*StructTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_eq_ne(
		_pointer,FfiConverterStructTagINSTANCE.Lower(other),_uniffiStatus)
	}))
}


func (object *StructTag) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterStructTag struct {}

var FfiConverterStructTagINSTANCE = FfiConverterStructTag{}


func (c FfiConverterStructTag) Lift(pointer unsafe.Pointer) *StructTag {
	result := &StructTag {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_structtag(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_structtag(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*StructTag).Destroy)
	return result
}

func (c FfiConverterStructTag) Read(reader io.Reader) *StructTag {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterStructTag) Lower(value *StructTag) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*StructTag")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterStructTag) Write(writer io.Writer, value *StructTag) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerStructTag struct {}

func (_ FfiDestroyerStructTag) Destroy(value *StructTag) {
		value.Destroy()
}



// System package
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// system-package = u64                ; version
// (vector bytes)     ; modules
// (vector object-id) ; dependencies
// ```
type SystemPackageInterface interface {
	Dependencies() []*ObjectId
	Modules() [][]byte
	Version() uint64
}
// System package
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// system-package = u64                ; version
// (vector bytes)     ; modules
// (vector object-id) ; dependencies
// ```
type SystemPackage struct {
	ffiObject FfiObject
}
func NewSystemPackage(version uint64, modules [][]byte, dependencies []*ObjectId) *SystemPackage {
	return FfiConverterSystemPackageINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_systempackage_new(FfiConverterUint64INSTANCE.Lower(version), FfiConverterSequenceBytesINSTANCE.Lower(modules), FfiConverterSequenceObjectIdINSTANCE.Lower(dependencies),_uniffiStatus)
	}))
}




func (_self *SystemPackage) Dependencies() []*ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*SystemPackage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_systempackage_dependencies(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *SystemPackage) Modules() [][]byte {
	_pointer := _self.ffiObject.incrementPointer("*SystemPackage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_systempackage_modules(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *SystemPackage) Version() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*SystemPackage")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_systempackage_version(
		_pointer,_uniffiStatus)
	}))
}
func (object *SystemPackage) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSystemPackage struct {}

var FfiConverterSystemPackageINSTANCE = FfiConverterSystemPackage{}


func (c FfiConverterSystemPackage) Lift(pointer unsafe.Pointer) *SystemPackage {
	result := &SystemPackage {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_systempackage(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_systempackage(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SystemPackage).Destroy)
	return result
}

func (c FfiConverterSystemPackage) Read(reader io.Reader) *SystemPackage {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSystemPackage) Lower(value *SystemPackage) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SystemPackage")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSystemPackage) Write(writer io.Writer, value *SystemPackage) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSystemPackage struct {}

func (_ FfiDestroyerSystemPackage) Destroy(value *SystemPackage) {
		value.Destroy()
}



// Transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction = %x00 transaction-v1
//
// transaction-v1 = transaction-kind address gas-payment transaction-expiration
// ```
type TransactionInterface interface {
	AsV1() *TransactionV1
	Digest() *Digest
	Expiration() TransactionExpiration
	GasPayment() GasPayment
	Kind() *TransactionKind
	Sender() *Address
	// Get the signing digest.
	SigningDigest() []byte
	// Get the signing digest as a hex string.
	SigningDigestHex() string
	// Serialize the transaction as a base64-encoded string.
	ToBase64() string
}
// Transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction = %x00 transaction-v1
//
// transaction-v1 = transaction-kind address gas-payment transaction-expiration
// ```
type Transaction struct {
	ffiObject FfiObject
}


// Deserialize a transaction from a base64-encoded string.
func TransactionFromBase64(base64 string) (*Transaction, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transaction_from_base64(FfiConverterStringINSTANCE.Lower(base64),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Transaction
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionINSTANCE.Lift(_uniffiRV), nil
		}
}

func TransactionNewV1(transactionV1 *TransactionV1) *Transaction {
	return FfiConverterTransactionINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transaction_new_v1(FfiConverterTransactionV1INSTANCE.Lower(transactionV1),_uniffiStatus)
	}))
}



func (_self *Transaction) AsV1() *TransactionV1 {
	_pointer := _self.ffiObject.incrementPointer("*Transaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionV1INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transaction_as_v1(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Transaction) Digest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*Transaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transaction_digest(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Transaction) Expiration() TransactionExpiration {
	_pointer := _self.ffiObject.incrementPointer("*Transaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionExpirationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transaction_expiration(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Transaction) GasPayment() GasPayment {
	_pointer := _self.ffiObject.incrementPointer("*Transaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterGasPaymentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transaction_gas_payment(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *Transaction) Kind() *TransactionKind {
	_pointer := _self.ffiObject.incrementPointer("*Transaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transaction_kind(
		_pointer,_uniffiStatus)
	}))
}

func (_self *Transaction) Sender() *Address {
	_pointer := _self.ffiObject.incrementPointer("*Transaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transaction_sender(
		_pointer,_uniffiStatus)
	}))
}

// Get the signing digest.
func (_self *Transaction) SigningDigest() []byte {
	_pointer := _self.ffiObject.incrementPointer("*Transaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transaction_signing_digest(
		_pointer,_uniffiStatus),
	}
	}))
}

// Get the signing digest as a hex string.
func (_self *Transaction) SigningDigestHex() string {
	_pointer := _self.ffiObject.incrementPointer("*Transaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transaction_signing_digest_hex(
		_pointer,_uniffiStatus),
	}
	}))
}

// Serialize the transaction as a base64-encoded string.
func (_self *Transaction) ToBase64() string {
	_pointer := _self.ffiObject.incrementPointer("*Transaction")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transaction_to_base64(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *Transaction) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTransaction struct {}

var FfiConverterTransactionINSTANCE = FfiConverterTransaction{}


func (c FfiConverterTransaction) Lift(pointer unsafe.Pointer) *Transaction {
	result := &Transaction {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_transaction(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_transaction(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Transaction).Destroy)
	return result
}

func (c FfiConverterTransaction) Read(reader io.Reader) *Transaction {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTransaction) Lower(value *Transaction) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Transaction")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTransaction) Write(writer io.Writer, value *Transaction) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTransaction struct {}

func (_ FfiDestroyerTransaction) Destroy(value *Transaction) {
		value.Destroy()
}



// A builder for creating transactions. Use `finish` to finalize the
// transaction data.
type TransactionBuilderInterface interface {
	// Execute the transaction using the gas station and return the JSON
	// transaction effects. This will fail unless data is set with the
	// `gas_station_sponsor` function.
	//
	// NOTE: These effects are not necessarily compatible with
	// `TransactionEffects`
	ExecuteWithGasStation(keypair *SimpleKeypair) (Value, error)
	// Set the expiration of the transaction to be a specific epoch.
	Expiration(epoch uint64) *TransactionBuilder
	// Convert this builder into a transaction.
	Finish() (*Transaction, error)
	// Add gas coins that will be consumed. Optional.
	Gas(objectRefs []ObjectReference) *TransactionBuilder
	// Set the gas budget for the transaction.
	GasBudget(budget uint64) *TransactionBuilder
	// Set the gas price for the transaction.
	GasPrice(price uint64) *TransactionBuilder
	// Set the gas station sponsor.
	GasStationSponsor(url string, duration *time.Duration, headers *map[string][]string) *TransactionBuilder
	// Make a move vector from a list of elements. The elements must all be of
	// the type indicated by `type_tag`.
	MakeMoveVec(elements []*MoveArg, typeTag *TypeTag, name string) *TransactionBuilder
	// Merge multiple coins into one.
	//
	// This method combines the balances of multiple coins of the same coin
	// type into a single coin. The `primary_coin` will receive the balances
	// from all `consumed_coins`. After merging, the `consumed_coins` will
	// be consumed and no longer exist.
	MergeCoins(primaryCoin *PtbArgument, consumedCoins []*PtbArgument) *TransactionBuilder
	// Call a Move function with the given arguments.
	MoveCall(varPackage *Address, module *Identifier, function *Identifier, arguments []*PtbArgument, typeArgs []*TypeTag, names []string) *TransactionBuilder
	// Publish a list of modules with the given dependencies. The result
	// assigned to `upgrade_cap_name` is the `0x2::package::UpgradeCap`
	// Move type. Note that the upgrade capability needs to be handled
	// after this call:
	// - transfer it to the transaction sender or another address
	// - burn it
	// - wrap it for access control
	// - discard the it to make a package immutable
	//
	// The arguments required for this command are:
	// - `modules`: is the modules' bytecode to be published
	// - `dependencies`: is the list of IDs of the transitive dependencies of
	// the package
	Publish(packageData *MovePackageData, upgradeCapName string) *TransactionBuilder
	// Transfer some coins to a recipient address. If multiple coins are
	// provided then they will be merged.
	//
	// The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
	// equals 1_000_000_000 NANOS.
	// If `amount` is provided, that amount is split from the provided coins
	// and sent.
	// If `amount` is `None`, the entire coins are transferred.
	//
	// All provided coins must have the same coin type. Mixing coins of
	// different types will result in an error.
	//
	// If you intend to transfer all provided coins to another address in a
	// single transaction, consider using
	// `TransactionBuilder::transfer_objects()` instead.
	SendCoins(coins []*PtbArgument, recipient *Address, amount **PtbArgument) *TransactionBuilder
	// Send IOTA to a recipient address.
	//
	// The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
	// equals 1_000_000_000 NANOS. That amount is split from the gas coin and
	// sent.
	SendIota(recipient *Address, amount *PtbArgument) *TransactionBuilder
	// Split a coin by the provided amounts.
	SplitCoins(coin *PtbArgument, amounts []*PtbArgument, names []string) *TransactionBuilder
	// Set the sponsor of the transaction.
	Sponsor(sponsor *Address) *TransactionBuilder
	// Add stake to a validator's staking pool.
	//
	// This is a high-level function which will split the provided stake amount
	// from the gas coin and then stake using the resulting coin.
	Stake(stake *PtbArgument, validatorAddress *Address) *TransactionBuilder
	// Transfer a list of objects to the given address, without producing any
	// result.
	TransferObjects(recipient *Address, objects []*PtbArgument) *TransactionBuilder
	// Withdraw stake from a validator's staking pool.
	Unstake(stakedIota *PtbArgument) *TransactionBuilder
	// Upgrade a Move package.
	//
	// - `modules`: is the modules' bytecode for the modules to be published
	// - `dependencies`: is the list of IDs of the transitive dependencies of
	// the package to be upgraded
	// - `package`: is the ID of the current package being upgraded
	// - `ticket`: is the upgrade ticket
	//
	// To get the ticket, you have to call the
	// `0x2::package::authorize_upgrade` function, and pass the package
	// ID, the upgrade policy, and package digest.
	Upgrade(packageId *ObjectId, packageData *MovePackageData, upgradeTicket *PtbArgument, name *string) *TransactionBuilder
	WithClient(client *GraphQlClient) *ClientTransactionBuilder
}
// A builder for creating transactions. Use `finish` to finalize the
// transaction data.
type TransactionBuilder struct {
	ffiObject FfiObject
}
// Create a new transaction builder and initialize its elements to default.
func NewTransactionBuilder(sender *Address) *TransactionBuilder {
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionbuilder_new(FfiConverterAddressINSTANCE.Lower(sender),_uniffiStatus)
	}))
}




// Execute the transaction using the gas station and return the JSON
// transaction effects. This will fail unless data is set with the
// `gas_station_sponsor` function.
//
// NOTE: These effects are not necessarily compatible with
// `TransactionEffects`
func (_self *TransactionBuilder) ExecuteWithGasStation(keypair *SimpleKeypair) (Value, error) {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	 res, err :=uniffiRustCallAsync[SdkFfiError](
        FfiConverterSdkFfiErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer {
		inner: res,
	}
		},
		// liftFn
		func(ffi RustBufferI) Value {
			return FfiConverterTypeValueINSTANCE.Lift(ffi)
		},
		C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_execute_with_gas_station(
		_pointer,FfiConverterSimpleKeypairINSTANCE.Lower(keypair)),
		// pollFn
		func (handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func (handle C.uint64_t) {
			C.ffi_iota_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err 
}

// Set the expiration of the transaction to be a specific epoch.
func (_self *TransactionBuilder) Expiration(epoch uint64) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_expiration(
		_pointer,FfiConverterUint64INSTANCE.Lower(epoch),_uniffiStatus)
	}))
}

// Convert this builder into a transaction.
func (_self *TransactionBuilder) Finish() (*Transaction, error) {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_finish(
		_pointer,_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Transaction
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionINSTANCE.Lift(_uniffiRV), nil
		}
}

// Add gas coins that will be consumed. Optional.
func (_self *TransactionBuilder) Gas(objectRefs []ObjectReference) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas(
		_pointer,FfiConverterSequenceObjectReferenceINSTANCE.Lower(objectRefs),_uniffiStatus)
	}))
}

// Set the gas budget for the transaction.
func (_self *TransactionBuilder) GasBudget(budget uint64) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_budget(
		_pointer,FfiConverterUint64INSTANCE.Lower(budget),_uniffiStatus)
	}))
}

// Set the gas price for the transaction.
func (_self *TransactionBuilder) GasPrice(price uint64) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_price(
		_pointer,FfiConverterUint64INSTANCE.Lower(price),_uniffiStatus)
	}))
}

// Set the gas station sponsor.
func (_self *TransactionBuilder) GasStationSponsor(url string, duration *time.Duration, headers *map[string][]string) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_station_sponsor(
		_pointer,FfiConverterStringINSTANCE.Lower(url), FfiConverterOptionalDurationINSTANCE.Lower(duration), FfiConverterOptionalMapStringSequenceStringINSTANCE.Lower(headers),_uniffiStatus)
	}))
}

// Make a move vector from a list of elements. The elements must all be of
// the type indicated by `type_tag`.
func (_self *TransactionBuilder) MakeMoveVec(elements []*MoveArg, typeTag *TypeTag, name string) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_make_move_vec(
		_pointer,FfiConverterSequenceMoveArgINSTANCE.Lower(elements), FfiConverterTypeTagINSTANCE.Lower(typeTag), FfiConverterStringINSTANCE.Lower(name),_uniffiStatus)
	}))
}

// Merge multiple coins into one.
//
// This method combines the balances of multiple coins of the same coin
// type into a single coin. The `primary_coin` will receive the balances
// from all `consumed_coins`. After merging, the `consumed_coins` will
// be consumed and no longer exist.
func (_self *TransactionBuilder) MergeCoins(primaryCoin *PtbArgument, consumedCoins []*PtbArgument) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_merge_coins(
		_pointer,FfiConverterPtbArgumentINSTANCE.Lower(primaryCoin), FfiConverterSequencePtbArgumentINSTANCE.Lower(consumedCoins),_uniffiStatus)
	}))
}

// Call a Move function with the given arguments.
func (_self *TransactionBuilder) MoveCall(varPackage *Address, module *Identifier, function *Identifier, arguments []*PtbArgument, typeArgs []*TypeTag, names []string) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_move_call(
		_pointer,FfiConverterAddressINSTANCE.Lower(varPackage), FfiConverterIdentifierINSTANCE.Lower(module), FfiConverterIdentifierINSTANCE.Lower(function), FfiConverterSequencePtbArgumentINSTANCE.Lower(arguments), FfiConverterSequenceTypeTagINSTANCE.Lower(typeArgs), FfiConverterSequenceStringINSTANCE.Lower(names),_uniffiStatus)
	}))
}

// Publish a list of modules with the given dependencies. The result
// assigned to `upgrade_cap_name` is the `0x2::package::UpgradeCap`
// Move type. Note that the upgrade capability needs to be handled
// after this call:
// - transfer it to the transaction sender or another address
// - burn it
// - wrap it for access control
// - discard the it to make a package immutable
//
// The arguments required for this command are:
// - `modules`: is the modules' bytecode to be published
// - `dependencies`: is the list of IDs of the transitive dependencies of
// the package
func (_self *TransactionBuilder) Publish(packageData *MovePackageData, upgradeCapName string) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_publish(
		_pointer,FfiConverterMovePackageDataINSTANCE.Lower(packageData), FfiConverterStringINSTANCE.Lower(upgradeCapName),_uniffiStatus)
	}))
}

// Transfer some coins to a recipient address. If multiple coins are
// provided then they will be merged.
//
// The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
// equals 1_000_000_000 NANOS.
// If `amount` is provided, that amount is split from the provided coins
// and sent.
// If `amount` is `None`, the entire coins are transferred.
//
// All provided coins must have the same coin type. Mixing coins of
// different types will result in an error.
//
// If you intend to transfer all provided coins to another address in a
// single transaction, consider using
// `TransactionBuilder::transfer_objects()` instead.
func (_self *TransactionBuilder) SendCoins(coins []*PtbArgument, recipient *Address, amount **PtbArgument) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_send_coins(
		_pointer,FfiConverterSequencePtbArgumentINSTANCE.Lower(coins), FfiConverterAddressINSTANCE.Lower(recipient), FfiConverterOptionalPtbArgumentINSTANCE.Lower(amount),_uniffiStatus)
	}))
}

// Send IOTA to a recipient address.
//
// The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
// equals 1_000_000_000 NANOS. That amount is split from the gas coin and
// sent.
func (_self *TransactionBuilder) SendIota(recipient *Address, amount *PtbArgument) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_send_iota(
		_pointer,FfiConverterAddressINSTANCE.Lower(recipient), FfiConverterPtbArgumentINSTANCE.Lower(amount),_uniffiStatus)
	}))
}

// Split a coin by the provided amounts.
func (_self *TransactionBuilder) SplitCoins(coin *PtbArgument, amounts []*PtbArgument, names []string) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_split_coins(
		_pointer,FfiConverterPtbArgumentINSTANCE.Lower(coin), FfiConverterSequencePtbArgumentINSTANCE.Lower(amounts), FfiConverterSequenceStringINSTANCE.Lower(names),_uniffiStatus)
	}))
}

// Set the sponsor of the transaction.
func (_self *TransactionBuilder) Sponsor(sponsor *Address) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_sponsor(
		_pointer,FfiConverterAddressINSTANCE.Lower(sponsor),_uniffiStatus)
	}))
}

// Add stake to a validator's staking pool.
//
// This is a high-level function which will split the provided stake amount
// from the gas coin and then stake using the resulting coin.
func (_self *TransactionBuilder) Stake(stake *PtbArgument, validatorAddress *Address) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_stake(
		_pointer,FfiConverterPtbArgumentINSTANCE.Lower(stake), FfiConverterAddressINSTANCE.Lower(validatorAddress),_uniffiStatus)
	}))
}

// Transfer a list of objects to the given address, without producing any
// result.
func (_self *TransactionBuilder) TransferObjects(recipient *Address, objects []*PtbArgument) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_transfer_objects(
		_pointer,FfiConverterAddressINSTANCE.Lower(recipient), FfiConverterSequencePtbArgumentINSTANCE.Lower(objects),_uniffiStatus)
	}))
}

// Withdraw stake from a validator's staking pool.
func (_self *TransactionBuilder) Unstake(stakedIota *PtbArgument) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_unstake(
		_pointer,FfiConverterPtbArgumentINSTANCE.Lower(stakedIota),_uniffiStatus)
	}))
}

// Upgrade a Move package.
//
// - `modules`: is the modules' bytecode for the modules to be published
// - `dependencies`: is the list of IDs of the transitive dependencies of
// the package to be upgraded
// - `package`: is the ID of the current package being upgraded
// - `ticket`: is the upgrade ticket
//
// To get the ticket, you have to call the
// `0x2::package::authorize_upgrade` function, and pass the package
// ID, the upgrade policy, and package digest.
func (_self *TransactionBuilder) Upgrade(packageId *ObjectId, packageData *MovePackageData, upgradeTicket *PtbArgument, name *string) *TransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_upgrade(
		_pointer,FfiConverterObjectIdINSTANCE.Lower(packageId), FfiConverterMovePackageDataINSTANCE.Lower(packageData), FfiConverterPtbArgumentINSTANCE.Lower(upgradeTicket), FfiConverterOptionalStringINSTANCE.Lower(name),_uniffiStatus)
	}))
}

func (_self *TransactionBuilder) WithClient(client *GraphQlClient) *ClientTransactionBuilder {
	_pointer := _self.ffiObject.incrementPointer("*TransactionBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientTransactionBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_with_client(
		_pointer,FfiConverterGraphQlClientINSTANCE.Lower(client),_uniffiStatus)
	}))
}
func (object *TransactionBuilder) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTransactionBuilder struct {}

var FfiConverterTransactionBuilderINSTANCE = FfiConverterTransactionBuilder{}


func (c FfiConverterTransactionBuilder) Lift(pointer unsafe.Pointer) *TransactionBuilder {
	result := &TransactionBuilder {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_transactionbuilder(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_transactionbuilder(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TransactionBuilder).Destroy)
	return result
}

func (c FfiConverterTransactionBuilder) Read(reader io.Reader) *TransactionBuilder {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTransactionBuilder) Lower(value *TransactionBuilder) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TransactionBuilder")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTransactionBuilder) Write(writer io.Writer, value *TransactionBuilder) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTransactionBuilder struct {}

func (_ FfiDestroyerTransactionBuilder) Destroy(value *TransactionBuilder) {
		value.Destroy()
}



// The output or effects of executing a transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction-effects =  %x00 effects-v1
// =/ %x01 effects-v2
// ```
type TransactionEffectsInterface interface {
	AsV1() TransactionEffectsV1
	Digest() *Digest
	IsV1() bool
}
// The output or effects of executing a transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction-effects =  %x00 effects-v1
// =/ %x01 effects-v2
// ```
type TransactionEffects struct {
	ffiObject FfiObject
}


func TransactionEffectsNewV1(effects TransactionEffectsV1) *TransactionEffects {
	return FfiConverterTransactionEffectsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactioneffects_new_v1(FfiConverterTransactionEffectsV1INSTANCE.Lower(effects),_uniffiStatus)
	}))
}



func (_self *TransactionEffects) AsV1() TransactionEffectsV1 {
	_pointer := _self.ffiObject.incrementPointer("*TransactionEffects")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionEffectsV1INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transactioneffects_as_v1(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *TransactionEffects) Digest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*TransactionEffects")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactioneffects_digest(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TransactionEffects) IsV1() bool {
	_pointer := _self.ffiObject.incrementPointer("*TransactionEffects")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_transactioneffects_is_v1(
		_pointer,_uniffiStatus)
	}))
}
func (object *TransactionEffects) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTransactionEffects struct {}

var FfiConverterTransactionEffectsINSTANCE = FfiConverterTransactionEffects{}


func (c FfiConverterTransactionEffects) Lift(pointer unsafe.Pointer) *TransactionEffects {
	result := &TransactionEffects {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_transactioneffects(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_transactioneffects(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TransactionEffects).Destroy)
	return result
}

func (c FfiConverterTransactionEffects) Read(reader io.Reader) *TransactionEffects {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTransactionEffects) Lower(value *TransactionEffects) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TransactionEffects")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTransactionEffects) Write(writer io.Writer, value *TransactionEffects) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTransactionEffects struct {}

func (_ FfiDestroyerTransactionEffects) Destroy(value *TransactionEffects) {
		value.Destroy()
}



// Events emitted during the successful execution of a transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction-events = vector event
// ```
type TransactionEventsInterface interface {
	Digest() *Digest
	Events() []Event
}
// Events emitted during the successful execution of a transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction-events = vector event
// ```
type TransactionEvents struct {
	ffiObject FfiObject
}
func NewTransactionEvents(events []Event) *TransactionEvents {
	return FfiConverterTransactionEventsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionevents_new(FfiConverterSequenceEventINSTANCE.Lower(events),_uniffiStatus)
	}))
}




func (_self *TransactionEvents) Digest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*TransactionEvents")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionevents_digest(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TransactionEvents) Events() []Event {
	_pointer := _self.ffiObject.incrementPointer("*TransactionEvents")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceEventINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transactionevents_events(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *TransactionEvents) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTransactionEvents struct {}

var FfiConverterTransactionEventsINSTANCE = FfiConverterTransactionEvents{}


func (c FfiConverterTransactionEvents) Lift(pointer unsafe.Pointer) *TransactionEvents {
	result := &TransactionEvents {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_transactionevents(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_transactionevents(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TransactionEvents).Destroy)
	return result
}

func (c FfiConverterTransactionEvents) Read(reader io.Reader) *TransactionEvents {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTransactionEvents) Lower(value *TransactionEvents) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TransactionEvents")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTransactionEvents) Write(writer io.Writer, value *TransactionEvents) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTransactionEvents struct {}

func (_ FfiDestroyerTransactionEvents) Destroy(value *TransactionEvents) {
		value.Destroy()
}



// Transaction type
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction-kind    =  %x00 ptb
// =/ %x01 change-epoch
// =/ %x02 genesis-transaction
// =/ %x03 consensus-commit-prologue
// =/ %x04 authenticator-state-update
// =/ %x05 (vector end-of-epoch-transaction-kind)
// =/ %x06 randomness-state-update
// =/ %x07 consensus-commit-prologue-v2
// =/ %x08 consensus-commit-prologue-v3
// ```
type TransactionKindInterface interface {
}
// Transaction type
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction-kind    =  %x00 ptb
// =/ %x01 change-epoch
// =/ %x02 genesis-transaction
// =/ %x03 consensus-commit-prologue
// =/ %x04 authenticator-state-update
// =/ %x05 (vector end-of-epoch-transaction-kind)
// =/ %x06 randomness-state-update
// =/ %x07 consensus-commit-prologue-v2
// =/ %x08 consensus-commit-prologue-v3
// ```
type TransactionKind struct {
	ffiObject FfiObject
}


func TransactionKindNewAuthenticatorStateUpdateV1(tx AuthenticatorStateUpdateV1) *TransactionKind {
	return FfiConverterTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_authenticator_state_update_v1(FfiConverterAuthenticatorStateUpdateV1INSTANCE.Lower(tx),_uniffiStatus)
	}))
}

func TransactionKindNewConsensusCommitPrologueV1(tx *ConsensusCommitPrologueV1) *TransactionKind {
	return FfiConverterTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_consensus_commit_prologue_v1(FfiConverterConsensusCommitPrologueV1INSTANCE.Lower(tx),_uniffiStatus)
	}))
}

func TransactionKindNewEndOfEpoch(tx []*EndOfEpochTransactionKind) *TransactionKind {
	return FfiConverterTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_end_of_epoch(FfiConverterSequenceEndOfEpochTransactionKindINSTANCE.Lower(tx),_uniffiStatus)
	}))
}

func TransactionKindNewGenesis(tx *GenesisTransaction) *TransactionKind {
	return FfiConverterTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_genesis(FfiConverterGenesisTransactionINSTANCE.Lower(tx),_uniffiStatus)
	}))
}

func TransactionKindNewProgrammableTransaction(tx *ProgrammableTransaction) *TransactionKind {
	return FfiConverterTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_programmable_transaction(FfiConverterProgrammableTransactionINSTANCE.Lower(tx),_uniffiStatus)
	}))
}

func TransactionKindNewRandomnessStateUpdate(tx RandomnessStateUpdate) *TransactionKind {
	return FfiConverterTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_randomness_state_update(FfiConverterRandomnessStateUpdateINSTANCE.Lower(tx),_uniffiStatus)
	}))
}


func (object *TransactionKind) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTransactionKind struct {}

var FfiConverterTransactionKindINSTANCE = FfiConverterTransactionKind{}


func (c FfiConverterTransactionKind) Lift(pointer unsafe.Pointer) *TransactionKind {
	result := &TransactionKind {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_transactionkind(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_transactionkind(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TransactionKind).Destroy)
	return result
}

func (c FfiConverterTransactionKind) Read(reader io.Reader) *TransactionKind {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTransactionKind) Lower(value *TransactionKind) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TransactionKind")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTransactionKind) Write(writer io.Writer, value *TransactionKind) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTransactionKind struct {}

func (_ FfiDestroyerTransactionKind) Destroy(value *TransactionKind) {
		value.Destroy()
}



// A transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction = %x00 transaction-v1
//
// transaction-v1 = transaction-kind address gas-payment transaction-expiration
// ```
type TransactionV1Interface interface {
	Digest() *Digest
	Expiration() TransactionExpiration
	GasPayment() GasPayment
	Kind() *TransactionKind
	Sender() *Address
	// Get the signing digest.
	SigningDigest() []byte
	// Get the signing digest as a hex string.
	SigningDigestHex() string
	// Serialize the transaction as a base64-encoded string.
	ToBase64() string
}
// A transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction = %x00 transaction-v1
//
// transaction-v1 = transaction-kind address gas-payment transaction-expiration
// ```
type TransactionV1 struct {
	ffiObject FfiObject
}
func NewTransactionV1(kind *TransactionKind, sender *Address, gasPayment GasPayment, expiration TransactionExpiration) *TransactionV1 {
	return FfiConverterTransactionV1INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionv1_new(FfiConverterTransactionKindINSTANCE.Lower(kind), FfiConverterAddressINSTANCE.Lower(sender), FfiConverterGasPaymentINSTANCE.Lower(gasPayment), FfiConverterTransactionExpirationINSTANCE.Lower(expiration),_uniffiStatus)
	}))
}


// Deserialize a transaction from a base64-encoded string.
func TransactionV1FromBase64(bytes string) (*TransactionV1, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transactionv1_from_base64(FfiConverterStringINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *TransactionV1
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionV1INSTANCE.Lift(_uniffiRV), nil
		}
}



func (_self *TransactionV1) Digest() *Digest {
	_pointer := _self.ffiObject.incrementPointer("*TransactionV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDigestINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionv1_digest(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TransactionV1) Expiration() TransactionExpiration {
	_pointer := _self.ffiObject.incrementPointer("*TransactionV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionExpirationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transactionv1_expiration(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *TransactionV1) GasPayment() GasPayment {
	_pointer := _self.ffiObject.incrementPointer("*TransactionV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterGasPaymentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transactionv1_gas_payment(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *TransactionV1) Kind() *TransactionKind {
	_pointer := _self.ffiObject.incrementPointer("*TransactionV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTransactionKindINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionv1_kind(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TransactionV1) Sender() *Address {
	_pointer := _self.ffiObject.incrementPointer("*TransactionV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transactionv1_sender(
		_pointer,_uniffiStatus)
	}))
}

// Get the signing digest.
func (_self *TransactionV1) SigningDigest() []byte {
	_pointer := _self.ffiObject.incrementPointer("*TransactionV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transactionv1_signing_digest(
		_pointer,_uniffiStatus),
	}
	}))
}

// Get the signing digest as a hex string.
func (_self *TransactionV1) SigningDigestHex() string {
	_pointer := _self.ffiObject.incrementPointer("*TransactionV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transactionv1_signing_digest_hex(
		_pointer,_uniffiStatus),
	}
	}))
}

// Serialize the transaction as a base64-encoded string.
func (_self *TransactionV1) ToBase64() string {
	_pointer := _self.ffiObject.incrementPointer("*TransactionV1")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transactionv1_to_base64(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *TransactionV1) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTransactionV1 struct {}

var FfiConverterTransactionV1INSTANCE = FfiConverterTransactionV1{}


func (c FfiConverterTransactionV1) Lift(pointer unsafe.Pointer) *TransactionV1 {
	result := &TransactionV1 {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_transactionv1(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_transactionv1(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TransactionV1).Destroy)
	return result
}

func (c FfiConverterTransactionV1) Read(reader io.Reader) *TransactionV1 {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTransactionV1) Lower(value *TransactionV1) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TransactionV1")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTransactionV1) Write(writer io.Writer, value *TransactionV1) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTransactionV1 struct {}

func (_ FfiDestroyerTransactionV1) Destroy(value *TransactionV1) {
		value.Destroy()
}



// Command to transfer ownership of a set of objects to an address
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transfer-objects = (vector argument) argument
// ```
type TransferObjectsInterface interface {
	// The address to transfer ownership to
	Address() *Argument
	// Set of objects to transfer
	Objects() []*Argument
}
// Command to transfer ownership of a set of objects to an address
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transfer-objects = (vector argument) argument
// ```
type TransferObjects struct {
	ffiObject FfiObject
}
func NewTransferObjects(objects []*Argument, address *Argument) *TransferObjects {
	return FfiConverterTransferObjectsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_transferobjects_new(FfiConverterSequenceArgumentINSTANCE.Lower(objects), FfiConverterArgumentINSTANCE.Lower(address),_uniffiStatus)
	}))
}




// The address to transfer ownership to
func (_self *TransferObjects) Address() *Argument {
	_pointer := _self.ffiObject.incrementPointer("*TransferObjects")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_transferobjects_address(
		_pointer,_uniffiStatus)
	}))
}

// Set of objects to transfer
func (_self *TransferObjects) Objects() []*Argument {
	_pointer := _self.ffiObject.incrementPointer("*TransferObjects")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_transferobjects_objects(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *TransferObjects) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTransferObjects struct {}

var FfiConverterTransferObjectsINSTANCE = FfiConverterTransferObjects{}


func (c FfiConverterTransferObjects) Lift(pointer unsafe.Pointer) *TransferObjects {
	result := &TransferObjects {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_transferobjects(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_transferobjects(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TransferObjects).Destroy)
	return result
}

func (c FfiConverterTransferObjects) Read(reader io.Reader) *TransferObjects {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTransferObjects) Lower(value *TransferObjects) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TransferObjects")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTransferObjects) Write(writer io.Writer, value *TransferObjects) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTransferObjects struct {}

func (_ FfiDestroyerTransferObjects) Destroy(value *TransferObjects) {
		value.Destroy()
}



// Type of a move value
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// type-tag = type-tag-u8 \
// type-tag-u16 \
// type-tag-u32 \
// type-tag-u64 \
// type-tag-u128 \
// type-tag-u256 \
// type-tag-bool \
// type-tag-address \
// type-tag-signer \
// type-tag-vector \
// type-tag-struct
//
// type-tag-u8 = %x01
// type-tag-u16 = %x08
// type-tag-u32 = %x09
// type-tag-u64 = %x02
// type-tag-u128 = %x03
// type-tag-u256 = %x0a
// type-tag-bool = %x00
// type-tag-address = %x04
// type-tag-signer = %x05
// type-tag-vector = %x06 type-tag
// type-tag-struct = %x07 struct-tag
// ```
type TypeTagInterface interface {
	AsStructTag() *StructTag
	AsStructTagOpt() **StructTag
	AsVectorTypeTag() *TypeTag
	AsVectorTypeTagOpt() **TypeTag
	IsAddress() bool
	IsBool() bool
	IsSigner() bool
	IsStruct() bool
	IsU128() bool
	IsU16() bool
	IsU256() bool
	IsU32() bool
	IsU64() bool
	IsU8() bool
	IsVector() bool
}
// Type of a move value
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// type-tag = type-tag-u8 \
// type-tag-u16 \
// type-tag-u32 \
// type-tag-u64 \
// type-tag-u128 \
// type-tag-u256 \
// type-tag-bool \
// type-tag-address \
// type-tag-signer \
// type-tag-vector \
// type-tag-struct
//
// type-tag-u8 = %x01
// type-tag-u16 = %x08
// type-tag-u32 = %x09
// type-tag-u64 = %x02
// type-tag-u128 = %x03
// type-tag-u256 = %x0a
// type-tag-bool = %x00
// type-tag-address = %x04
// type-tag-signer = %x05
// type-tag-vector = %x06 type-tag
// type-tag-struct = %x07 struct-tag
// ```
type TypeTag struct {
	ffiObject FfiObject
}


func TypeTagNewAddress() *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_address(_uniffiStatus)
	}))
}

func TypeTagNewBool() *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_bool(_uniffiStatus)
	}))
}

func TypeTagNewSigner() *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_signer(_uniffiStatus)
	}))
}

func TypeTagNewStruct(structTag *StructTag) *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_struct(FfiConverterStructTagINSTANCE.Lower(structTag),_uniffiStatus)
	}))
}

func TypeTagNewU128() *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u128(_uniffiStatus)
	}))
}

func TypeTagNewU16() *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u16(_uniffiStatus)
	}))
}

func TypeTagNewU256() *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u256(_uniffiStatus)
	}))
}

func TypeTagNewU32() *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u32(_uniffiStatus)
	}))
}

func TypeTagNewU64() *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u64(_uniffiStatus)
	}))
}

func TypeTagNewU8() *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u8(_uniffiStatus)
	}))
}

func TypeTagNewVector(typeTag *TypeTag) *TypeTag {
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_vector(FfiConverterTypeTagINSTANCE.Lower(typeTag),_uniffiStatus)
	}))
}



func (_self *TypeTag) AsStructTag() *StructTag {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_as_struct_tag(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) AsStructTagOpt() **StructTag {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStructTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_typetag_as_struct_tag_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *TypeTag) AsVectorTypeTag() *TypeTag {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_as_vector_type_tag(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) AsVectorTypeTagOpt() **TypeTag {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalTypeTagINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_typetag_as_vector_type_tag_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *TypeTag) IsAddress() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_address(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsBool() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_bool(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsSigner() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_signer(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsStruct() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_struct(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsU128() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_u128(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsU16() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_u16(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsU256() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_u256(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsU32() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_u32(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsU64() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_u64(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsU8() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_u8(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) IsVector() bool {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_typetag_is_vector(
		_pointer,_uniffiStatus)
	}))
}

func (_self *TypeTag) String() string {
	_pointer := _self.ffiObject.incrementPointer("*TypeTag")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_typetag_uniffi_trait_display(
		_pointer,_uniffiStatus),
	}
	}))
}


func (object *TypeTag) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTypeTag struct {}

var FfiConverterTypeTagINSTANCE = FfiConverterTypeTag{}


func (c FfiConverterTypeTag) Lift(pointer unsafe.Pointer) *TypeTag {
	result := &TypeTag {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_typetag(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_typetag(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TypeTag).Destroy)
	return result
}

func (c FfiConverterTypeTag) Read(reader io.Reader) *TypeTag {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTypeTag) Lower(value *TypeTag) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TypeTag")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTypeTag) Write(writer io.Writer, value *TypeTag) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTypeTag struct {}

func (_ FfiDestroyerTypeTag) Destroy(value *TypeTag) {
		value.Destroy()
}



// Command to upgrade an already published package
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// upgrade = (vector bytes)        ; move modules
// (vector object-id)    ; dependencies
// object-id             ; package-id of the package
// argument              ; upgrade ticket
// ```
type UpgradeInterface interface {
	// Set of packages that the to-be published package depends on
	Dependencies() []*ObjectId
	// The serialized move modules
	Modules() [][]byte
	// Package id of the package to upgrade
	Package() *ObjectId
	// Ticket authorizing the upgrade
	Ticket() *Argument
}
// Command to upgrade an already published package
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// upgrade = (vector bytes)        ; move modules
// (vector object-id)    ; dependencies
// object-id             ; package-id of the package
// argument              ; upgrade ticket
// ```
type Upgrade struct {
	ffiObject FfiObject
}
func NewUpgrade(modules [][]byte, dependencies []*ObjectId, varPackage *ObjectId, ticket *Argument) *Upgrade {
	return FfiConverterUpgradeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_upgrade_new(FfiConverterSequenceBytesINSTANCE.Lower(modules), FfiConverterSequenceObjectIdINSTANCE.Lower(dependencies), FfiConverterObjectIdINSTANCE.Lower(varPackage), FfiConverterArgumentINSTANCE.Lower(ticket),_uniffiStatus)
	}))
}




// Set of packages that the to-be published package depends on
func (_self *Upgrade) Dependencies() []*ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*Upgrade")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_upgrade_dependencies(
		_pointer,_uniffiStatus),
	}
	}))
}

// The serialized move modules
func (_self *Upgrade) Modules() [][]byte {
	_pointer := _self.ffiObject.incrementPointer("*Upgrade")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_upgrade_modules(
		_pointer,_uniffiStatus),
	}
	}))
}

// Package id of the package to upgrade
func (_self *Upgrade) Package() *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*Upgrade")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_upgrade_package(
		_pointer,_uniffiStatus)
	}))
}

// Ticket authorizing the upgrade
func (_self *Upgrade) Ticket() *Argument {
	_pointer := _self.ffiObject.incrementPointer("*Upgrade")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterArgumentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_upgrade_ticket(
		_pointer,_uniffiStatus)
	}))
}
func (object *Upgrade) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterUpgrade struct {}

var FfiConverterUpgradeINSTANCE = FfiConverterUpgrade{}


func (c FfiConverterUpgrade) Lift(pointer unsafe.Pointer) *Upgrade {
	result := &Upgrade {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_upgrade(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_upgrade(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Upgrade).Destroy)
	return result
}

func (c FfiConverterUpgrade) Read(reader io.Reader) *Upgrade {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterUpgrade) Lower(value *Upgrade) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Upgrade")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterUpgrade) Write(writer io.Writer, value *Upgrade) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerUpgrade struct {}

func (_ FfiDestroyerUpgrade) Destroy(value *Upgrade) {
		value.Destroy()
}



// Representation of upgrade policy constants in `iota::package`.
type UpgradePolicyInterface interface {
	// Returns the internal representation.
	AsU8() uint8
}
// Representation of upgrade policy constants in `iota::package`.
type UpgradePolicy struct {
	ffiObject FfiObject
}


// Allows adding new functionalities (e.g., new public functions or
// structs) but restricts changes to existing functionalities.
func UpgradePolicyAdditive() *UpgradePolicy {
	return FfiConverterUpgradePolicyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_additive(_uniffiStatus)
	}))
}

// The least restrictive policy. Permits changes to all function
// implementations, the removal of ability constraints on generic type
// parameters in function signatures, and modifications to private,
// public(friend), and entry function signatures. However, public function
// signatures and existing types cannot be changed.
func UpgradePolicyCompatible() *UpgradePolicy {
	return FfiConverterUpgradePolicyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_compatible(_uniffiStatus)
	}))
}

// Limits modifications to the packages dependencies only.
func UpgradePolicyDepOnly() *UpgradePolicy {
	return FfiConverterUpgradePolicyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_dep_only(_uniffiStatus)
	}))
}



// Returns the internal representation.
func (_self *UpgradePolicy) AsU8() uint8 {
	_pointer := _self.ffiObject.incrementPointer("*UpgradePolicy")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint8INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_as_u8(
		_pointer,_uniffiStatus)
	}))
}

func (_self *UpgradePolicy) String() string {
	_pointer := _self.ffiObject.incrementPointer("*UpgradePolicy")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_display(
		_pointer,_uniffiStatus),
	}
	}))
}



func (_self *UpgradePolicy) Eq(other *UpgradePolicy) bool {
	_pointer := _self.ffiObject.incrementPointer("*UpgradePolicy")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_eq_eq(
		_pointer,FfiConverterUpgradePolicyINSTANCE.Lower(other),_uniffiStatus)
	}))
}

func (_self *UpgradePolicy) Ne(other *UpgradePolicy) bool {
	_pointer := _self.ffiObject.incrementPointer("*UpgradePolicy")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_eq_ne(
		_pointer,FfiConverterUpgradePolicyINSTANCE.Lower(other),_uniffiStatus)
	}))
}


func (object *UpgradePolicy) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterUpgradePolicy struct {}

var FfiConverterUpgradePolicyINSTANCE = FfiConverterUpgradePolicy{}


func (c FfiConverterUpgradePolicy) Lift(pointer unsafe.Pointer) *UpgradePolicy {
	result := &UpgradePolicy {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_upgradepolicy(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_upgradepolicy(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*UpgradePolicy).Destroy)
	return result
}

func (c FfiConverterUpgradePolicy) Read(reader io.Reader) *UpgradePolicy {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterUpgradePolicy) Lower(value *UpgradePolicy) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*UpgradePolicy")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterUpgradePolicy) Write(writer io.Writer, value *UpgradePolicy) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerUpgradePolicy struct {}

func (_ FfiDestroyerUpgradePolicy) Destroy(value *UpgradePolicy) {
		value.Destroy()
}



// A signature from a user
//
// A `UserSignature` is most commonly used to authorize the execution and
// inclusion of a transaction to the blockchain.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// user-signature-bcs = bytes ; where the contents of the bytes are defined by <user-signature>
// user-signature = simple-signature / multisig / multisig-legacy / zklogin / passkey
// ```
//
// Note: Due to historical reasons, signatures are serialized slightly
// different from the majority of the types in IOTA. In particular if a
// signature is ever embedded in another structure it generally is serialized
// as `bytes` meaning it has a length prefix that defines the length of
// the completely serialized signature.
type UserSignatureInterface interface {
	AsMultisig() *MultisigAggregatedSignature
	AsMultisigOpt() **MultisigAggregatedSignature
	AsPasskey() *PasskeyAuthenticator
	AsPasskeyOpt() **PasskeyAuthenticator
	AsSimple() *SimpleSignature
	AsSimpleOpt() **SimpleSignature
	AsZklogin() *ZkLoginAuthenticator
	AsZkloginOpt() **ZkLoginAuthenticator
	IsMultisig() bool
	IsPasskey() bool
	IsSimple() bool
	IsZklogin() bool
	// Return the flag for this signature scheme
	Scheme() SignatureScheme
	ToBase64() string
	ToBytes() []byte
}
// A signature from a user
//
// A `UserSignature` is most commonly used to authorize the execution and
// inclusion of a transaction to the blockchain.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// user-signature-bcs = bytes ; where the contents of the bytes are defined by <user-signature>
// user-signature = simple-signature / multisig / multisig-legacy / zklogin / passkey
// ```
//
// Note: Due to historical reasons, signatures are serialized slightly
// different from the majority of the types in IOTA. In particular if a
// signature is ever embedded in another structure it generally is serialized
// as `bytes` meaning it has a length prefix that defines the length of
// the completely serialized signature.
type UserSignature struct {
	ffiObject FfiObject
}


func UserSignatureFromBase64(base64 string) (*UserSignature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_usersignature_from_base64(FfiConverterStringINSTANCE.Lower(base64),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func UserSignatureFromBytes(bytes []byte) (*UserSignature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_usersignature_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

func UserSignatureNewMultisig(signature *MultisigAggregatedSignature) *UserSignature {
	return FfiConverterUserSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_multisig(FfiConverterMultisigAggregatedSignatureINSTANCE.Lower(signature),_uniffiStatus)
	}))
}

func UserSignatureNewPasskey(authenticator *PasskeyAuthenticator) *UserSignature {
	return FfiConverterUserSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_passkey(FfiConverterPasskeyAuthenticatorINSTANCE.Lower(authenticator),_uniffiStatus)
	}))
}

func UserSignatureNewSimple(signature *SimpleSignature) *UserSignature {
	return FfiConverterUserSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_simple(FfiConverterSimpleSignatureINSTANCE.Lower(signature),_uniffiStatus)
	}))
}

func UserSignatureNewZklogin(authenticator *ZkLoginAuthenticator) *UserSignature {
	return FfiConverterUserSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_zklogin(FfiConverterZkLoginAuthenticatorINSTANCE.Lower(authenticator),_uniffiStatus)
	}))
}



func (_self *UserSignature) AsMultisig() *MultisigAggregatedSignature {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMultisigAggregatedSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_usersignature_as_multisig(
		_pointer,_uniffiStatus)
	}))
}

func (_self *UserSignature) AsMultisigOpt() **MultisigAggregatedSignature {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalMultisigAggregatedSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_usersignature_as_multisig_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *UserSignature) AsPasskey() *PasskeyAuthenticator {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterPasskeyAuthenticatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_usersignature_as_passkey(
		_pointer,_uniffiStatus)
	}))
}

func (_self *UserSignature) AsPasskeyOpt() **PasskeyAuthenticator {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalPasskeyAuthenticatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_usersignature_as_passkey_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *UserSignature) AsSimple() *SimpleSignature {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSimpleSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_usersignature_as_simple(
		_pointer,_uniffiStatus)
	}))
}

func (_self *UserSignature) AsSimpleOpt() **SimpleSignature {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSimpleSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_usersignature_as_simple_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *UserSignature) AsZklogin() *ZkLoginAuthenticator {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterZkLoginAuthenticatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_usersignature_as_zklogin(
		_pointer,_uniffiStatus)
	}))
}

func (_self *UserSignature) AsZkloginOpt() **ZkLoginAuthenticator {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalZkLoginAuthenticatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_usersignature_as_zklogin_opt(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *UserSignature) IsMultisig() bool {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_usersignature_is_multisig(
		_pointer,_uniffiStatus)
	}))
}

func (_self *UserSignature) IsPasskey() bool {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_usersignature_is_passkey(
		_pointer,_uniffiStatus)
	}))
}

func (_self *UserSignature) IsSimple() bool {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_usersignature_is_simple(
		_pointer,_uniffiStatus)
	}))
}

func (_self *UserSignature) IsZklogin() bool {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_method_usersignature_is_zklogin(
		_pointer,_uniffiStatus)
	}))
}

// Return the flag for this signature scheme
func (_self *UserSignature) Scheme() SignatureScheme {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSignatureSchemeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_usersignature_scheme(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *UserSignature) ToBase64() string {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_usersignature_to_base64(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *UserSignature) ToBytes() []byte {
	_pointer := _self.ffiObject.incrementPointer("*UserSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBytesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_usersignature_to_bytes(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *UserSignature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterUserSignature struct {}

var FfiConverterUserSignatureINSTANCE = FfiConverterUserSignature{}


func (c FfiConverterUserSignature) Lift(pointer unsafe.Pointer) *UserSignature {
	result := &UserSignature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_usersignature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_usersignature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*UserSignature).Destroy)
	return result
}

func (c FfiConverterUserSignature) Read(reader io.Reader) *UserSignature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterUserSignature) Lower(value *UserSignature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*UserSignature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterUserSignature) Write(writer io.Writer, value *UserSignature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerUserSignature struct {}

func (_ FfiDestroyerUserSignature) Destroy(value *UserSignature) {
		value.Destroy()
}



// Verifier that will verify all UserSignature variants
type UserSignatureVerifierInterface interface {
	Verify(message []byte, signature *UserSignature) error
	WithZkloginVerifier(zkloginVerifier *ZkloginVerifier) *UserSignatureVerifier
	ZkloginVerifier() **ZkloginVerifier
}
// Verifier that will verify all UserSignature variants
type UserSignatureVerifier struct {
	ffiObject FfiObject
}
func NewUserSignatureVerifier() *UserSignatureVerifier {
	return FfiConverterUserSignatureVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_usersignatureverifier_new(_uniffiStatus)
	}))
}




func (_self *UserSignatureVerifier) Verify(message []byte, signature *UserSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*UserSignatureVerifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterUserSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *UserSignatureVerifier) WithZkloginVerifier(zkloginVerifier *ZkloginVerifier) *UserSignatureVerifier {
	_pointer := _self.ffiObject.incrementPointer("*UserSignatureVerifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUserSignatureVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_with_zklogin_verifier(
		_pointer,FfiConverterZkloginVerifierINSTANCE.Lower(zkloginVerifier),_uniffiStatus)
	}))
}

func (_self *UserSignatureVerifier) ZkloginVerifier() **ZkloginVerifier {
	_pointer := _self.ffiObject.incrementPointer("*UserSignatureVerifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalZkloginVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_zklogin_verifier(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *UserSignatureVerifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterUserSignatureVerifier struct {}

var FfiConverterUserSignatureVerifierINSTANCE = FfiConverterUserSignatureVerifier{}


func (c FfiConverterUserSignatureVerifier) Lift(pointer unsafe.Pointer) *UserSignatureVerifier {
	result := &UserSignatureVerifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_usersignatureverifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_usersignatureverifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*UserSignatureVerifier).Destroy)
	return result
}

func (c FfiConverterUserSignatureVerifier) Read(reader io.Reader) *UserSignatureVerifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterUserSignatureVerifier) Lower(value *UserSignatureVerifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*UserSignatureVerifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterUserSignatureVerifier) Write(writer io.Writer, value *UserSignatureVerifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerUserSignatureVerifier struct {}

func (_ FfiDestroyerUserSignatureVerifier) Destroy(value *UserSignatureVerifier) {
		value.Destroy()
}



// An aggregated signature from multiple Validators.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// validator-aggregated-signature = u64               ; epoch
// bls-signature
// roaring-bitmap
// roaring-bitmap = bytes  ; where the contents of the bytes are valid
// ; according to the serialized spec for
// ; roaring bitmaps
// ```
//
// See <https://github.com/RoaringBitmap/RoaringFormatSpec> for the specification for the
// serialized format of RoaringBitmaps.
type ValidatorAggregatedSignatureInterface interface {
	BitmapBytes() ([]byte, error)
	Epoch() uint64
	Signature() *Bls12381Signature
}
// An aggregated signature from multiple Validators.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// validator-aggregated-signature = u64               ; epoch
// bls-signature
// roaring-bitmap
// roaring-bitmap = bytes  ; where the contents of the bytes are valid
// ; according to the serialized spec for
// ; roaring bitmaps
// ```
//
// See <https://github.com/RoaringBitmap/RoaringFormatSpec> for the specification for the
// serialized format of RoaringBitmaps.
type ValidatorAggregatedSignature struct {
	ffiObject FfiObject
}
func NewValidatorAggregatedSignature(epoch uint64, signature *Bls12381Signature, bitmapBytes []byte) (*ValidatorAggregatedSignature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_validatoraggregatedsignature_new(FfiConverterUint64INSTANCE.Lower(epoch), FfiConverterBls12381SignatureINSTANCE.Lower(signature), FfiConverterBytesINSTANCE.Lower(bitmapBytes),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ValidatorAggregatedSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterValidatorAggregatedSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}




func (_self *ValidatorAggregatedSignature) BitmapBytes() ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorAggregatedSignature")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_bitmap_bytes(
		_pointer,_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

func (_self *ValidatorAggregatedSignature) Epoch() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorAggregatedSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_epoch(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ValidatorAggregatedSignature) Signature() *Bls12381Signature {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorAggregatedSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBls12381SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_signature(
		_pointer,_uniffiStatus)
	}))
}
func (object *ValidatorAggregatedSignature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterValidatorAggregatedSignature struct {}

var FfiConverterValidatorAggregatedSignatureINSTANCE = FfiConverterValidatorAggregatedSignature{}


func (c FfiConverterValidatorAggregatedSignature) Lift(pointer unsafe.Pointer) *ValidatorAggregatedSignature {
	result := &ValidatorAggregatedSignature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_validatoraggregatedsignature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_validatoraggregatedsignature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ValidatorAggregatedSignature).Destroy)
	return result
}

func (c FfiConverterValidatorAggregatedSignature) Read(reader io.Reader) *ValidatorAggregatedSignature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterValidatorAggregatedSignature) Lower(value *ValidatorAggregatedSignature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ValidatorAggregatedSignature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterValidatorAggregatedSignature) Write(writer io.Writer, value *ValidatorAggregatedSignature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerValidatorAggregatedSignature struct {}

func (_ FfiDestroyerValidatorAggregatedSignature) Destroy(value *ValidatorAggregatedSignature) {
		value.Destroy()
}



type ValidatorCommitteeSignatureAggregatorInterface interface {
	AddSignature(signature *ValidatorSignature) error
	Committee() ValidatorCommittee
	Finish() (*ValidatorAggregatedSignature, error)
}
type ValidatorCommitteeSignatureAggregator struct {
	ffiObject FfiObject
}


func ValidatorCommitteeSignatureAggregatorNewCheckpointSummary(committee ValidatorCommittee, summary *CheckpointSummary) (*ValidatorCommitteeSignatureAggregator, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_validatorcommitteesignatureaggregator_new_checkpoint_summary(FfiConverterValidatorCommitteeINSTANCE.Lower(committee), FfiConverterCheckpointSummaryINSTANCE.Lower(summary),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ValidatorCommitteeSignatureAggregator
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterValidatorCommitteeSignatureAggregatorINSTANCE.Lift(_uniffiRV), nil
		}
}



func (_self *ValidatorCommitteeSignatureAggregator) AddSignature(signature *ValidatorSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorCommitteeSignatureAggregator")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_add_signature(
		_pointer,FfiConverterValidatorSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *ValidatorCommitteeSignatureAggregator) Committee() ValidatorCommittee {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorCommitteeSignatureAggregator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterValidatorCommitteeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_committee(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ValidatorCommitteeSignatureAggregator) Finish() (*ValidatorAggregatedSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorCommitteeSignatureAggregator")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_finish(
		_pointer,_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ValidatorAggregatedSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterValidatorAggregatedSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}
func (object *ValidatorCommitteeSignatureAggregator) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterValidatorCommitteeSignatureAggregator struct {}

var FfiConverterValidatorCommitteeSignatureAggregatorINSTANCE = FfiConverterValidatorCommitteeSignatureAggregator{}


func (c FfiConverterValidatorCommitteeSignatureAggregator) Lift(pointer unsafe.Pointer) *ValidatorCommitteeSignatureAggregator {
	result := &ValidatorCommitteeSignatureAggregator {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_validatorcommitteesignatureaggregator(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_validatorcommitteesignatureaggregator(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ValidatorCommitteeSignatureAggregator).Destroy)
	return result
}

func (c FfiConverterValidatorCommitteeSignatureAggregator) Read(reader io.Reader) *ValidatorCommitteeSignatureAggregator {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterValidatorCommitteeSignatureAggregator) Lower(value *ValidatorCommitteeSignatureAggregator) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ValidatorCommitteeSignatureAggregator")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterValidatorCommitteeSignatureAggregator) Write(writer io.Writer, value *ValidatorCommitteeSignatureAggregator) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerValidatorCommitteeSignatureAggregator struct {}

func (_ FfiDestroyerValidatorCommitteeSignatureAggregator) Destroy(value *ValidatorCommitteeSignatureAggregator) {
		value.Destroy()
}



type ValidatorCommitteeSignatureVerifierInterface interface {
	Committee() ValidatorCommittee
	Verify(message []byte, signature *ValidatorSignature) error
	VerifyAggregated(message []byte, signature *ValidatorAggregatedSignature) error
	VerifyCheckpointSummary(summary *CheckpointSummary, signature *ValidatorAggregatedSignature) error
}
type ValidatorCommitteeSignatureVerifier struct {
	ffiObject FfiObject
}
func NewValidatorCommitteeSignatureVerifier(committee ValidatorCommittee) (*ValidatorCommitteeSignatureVerifier, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_validatorcommitteesignatureverifier_new(FfiConverterValidatorCommitteeINSTANCE.Lower(committee),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ValidatorCommitteeSignatureVerifier
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterValidatorCommitteeSignatureVerifierINSTANCE.Lift(_uniffiRV), nil
		}
}




func (_self *ValidatorCommitteeSignatureVerifier) Committee() ValidatorCommittee {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorCommitteeSignatureVerifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterValidatorCommitteeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_committee(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ValidatorCommitteeSignatureVerifier) Verify(message []byte, signature *ValidatorSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorCommitteeSignatureVerifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterValidatorSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *ValidatorCommitteeSignatureVerifier) VerifyAggregated(message []byte, signature *ValidatorAggregatedSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorCommitteeSignatureVerifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify_aggregated(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterValidatorAggregatedSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *ValidatorCommitteeSignatureVerifier) VerifyCheckpointSummary(summary *CheckpointSummary, signature *ValidatorAggregatedSignature) error {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorCommitteeSignatureVerifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify_checkpoint_summary(
		_pointer,FfiConverterCheckpointSummaryINSTANCE.Lower(summary), FfiConverterValidatorAggregatedSignatureINSTANCE.Lower(signature),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}
func (object *ValidatorCommitteeSignatureVerifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterValidatorCommitteeSignatureVerifier struct {}

var FfiConverterValidatorCommitteeSignatureVerifierINSTANCE = FfiConverterValidatorCommitteeSignatureVerifier{}


func (c FfiConverterValidatorCommitteeSignatureVerifier) Lift(pointer unsafe.Pointer) *ValidatorCommitteeSignatureVerifier {
	result := &ValidatorCommitteeSignatureVerifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_validatorcommitteesignatureverifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_validatorcommitteesignatureverifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ValidatorCommitteeSignatureVerifier).Destroy)
	return result
}

func (c FfiConverterValidatorCommitteeSignatureVerifier) Read(reader io.Reader) *ValidatorCommitteeSignatureVerifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterValidatorCommitteeSignatureVerifier) Lower(value *ValidatorCommitteeSignatureVerifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ValidatorCommitteeSignatureVerifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterValidatorCommitteeSignatureVerifier) Write(writer io.Writer, value *ValidatorCommitteeSignatureVerifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerValidatorCommitteeSignatureVerifier struct {}

func (_ FfiDestroyerValidatorCommitteeSignatureVerifier) Destroy(value *ValidatorCommitteeSignatureVerifier) {
		value.Destroy()
}



// An execution time observation from a particular validator
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// execution-time-observation = bls-public-key duration
// duration =  u64 ; seconds
// u32 ; subsecond nanoseconds
// ```
type ValidatorExecutionTimeObservationInterface interface {
	Duration() time.Duration
	Validator() *Bls12381PublicKey
}
// An execution time observation from a particular validator
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// execution-time-observation = bls-public-key duration
// duration =  u64 ; seconds
// u32 ; subsecond nanoseconds
// ```
type ValidatorExecutionTimeObservation struct {
	ffiObject FfiObject
}
func NewValidatorExecutionTimeObservation(validator *Bls12381PublicKey, duration time.Duration) *ValidatorExecutionTimeObservation {
	return FfiConverterValidatorExecutionTimeObservationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_validatorexecutiontimeobservation_new(FfiConverterBls12381PublicKeyINSTANCE.Lower(validator), FfiConverterDurationINSTANCE.Lower(duration),_uniffiStatus)
	}))
}




func (_self *ValidatorExecutionTimeObservation) Duration() time.Duration {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorExecutionTimeObservation")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterDurationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_validatorexecutiontimeobservation_duration(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ValidatorExecutionTimeObservation) Validator() *Bls12381PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorExecutionTimeObservation")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBls12381PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_validatorexecutiontimeobservation_validator(
		_pointer,_uniffiStatus)
	}))
}
func (object *ValidatorExecutionTimeObservation) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterValidatorExecutionTimeObservation struct {}

var FfiConverterValidatorExecutionTimeObservationINSTANCE = FfiConverterValidatorExecutionTimeObservation{}


func (c FfiConverterValidatorExecutionTimeObservation) Lift(pointer unsafe.Pointer) *ValidatorExecutionTimeObservation {
	result := &ValidatorExecutionTimeObservation {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_validatorexecutiontimeobservation(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_validatorexecutiontimeobservation(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ValidatorExecutionTimeObservation).Destroy)
	return result
}

func (c FfiConverterValidatorExecutionTimeObservation) Read(reader io.Reader) *ValidatorExecutionTimeObservation {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterValidatorExecutionTimeObservation) Lower(value *ValidatorExecutionTimeObservation) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ValidatorExecutionTimeObservation")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterValidatorExecutionTimeObservation) Write(writer io.Writer, value *ValidatorExecutionTimeObservation) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerValidatorExecutionTimeObservation struct {}

func (_ FfiDestroyerValidatorExecutionTimeObservation) Destroy(value *ValidatorExecutionTimeObservation) {
		value.Destroy()
}



// A signature from a Validator
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// validator-signature = u64               ; epoch
// bls-public-key
// bls-signature
// ```
type ValidatorSignatureInterface interface {
	Epoch() uint64
	PublicKey() *Bls12381PublicKey
	Signature() *Bls12381Signature
}
// A signature from a Validator
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// validator-signature = u64               ; epoch
// bls-public-key
// bls-signature
// ```
type ValidatorSignature struct {
	ffiObject FfiObject
}
func NewValidatorSignature(epoch uint64, publicKey *Bls12381PublicKey, signature *Bls12381Signature) *ValidatorSignature {
	return FfiConverterValidatorSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_validatorsignature_new(FfiConverterUint64INSTANCE.Lower(epoch), FfiConverterBls12381PublicKeyINSTANCE.Lower(publicKey), FfiConverterBls12381SignatureINSTANCE.Lower(signature),_uniffiStatus)
	}))
}




func (_self *ValidatorSignature) Epoch() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_validatorsignature_epoch(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ValidatorSignature) PublicKey() *Bls12381PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBls12381PublicKeyINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_validatorsignature_public_key(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ValidatorSignature) Signature() *Bls12381Signature {
	_pointer := _self.ffiObject.incrementPointer("*ValidatorSignature")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBls12381SignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_validatorsignature_signature(
		_pointer,_uniffiStatus)
	}))
}
func (object *ValidatorSignature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterValidatorSignature struct {}

var FfiConverterValidatorSignatureINSTANCE = FfiConverterValidatorSignature{}


func (c FfiConverterValidatorSignature) Lift(pointer unsafe.Pointer) *ValidatorSignature {
	result := &ValidatorSignature {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_validatorsignature(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_validatorsignature(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ValidatorSignature).Destroy)
	return result
}

func (c FfiConverterValidatorSignature) Read(reader io.Reader) *ValidatorSignature {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterValidatorSignature) Lower(value *ValidatorSignature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ValidatorSignature")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterValidatorSignature) Write(writer io.Writer, value *ValidatorSignature) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerValidatorSignature struct {}

func (_ FfiDestroyerValidatorSignature) Destroy(value *ValidatorSignature) {
		value.Destroy()
}



// Object version assignment from consensus
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// version-assignment = object-id u64
// ```
type VersionAssignmentInterface interface {
	ObjectId() *ObjectId
	Version() uint64
}
// Object version assignment from consensus
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// version-assignment = object-id u64
// ```
type VersionAssignment struct {
	ffiObject FfiObject
}
func NewVersionAssignment(objectId *ObjectId, version uint64) *VersionAssignment {
	return FfiConverterVersionAssignmentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_versionassignment_new(FfiConverterObjectIdINSTANCE.Lower(objectId), FfiConverterUint64INSTANCE.Lower(version),_uniffiStatus)
	}))
}




func (_self *VersionAssignment) ObjectId() *ObjectId {
	_pointer := _self.ffiObject.incrementPointer("*VersionAssignment")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterObjectIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_versionassignment_object_id(
		_pointer,_uniffiStatus)
	}))
}

func (_self *VersionAssignment) Version() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*VersionAssignment")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_versionassignment_version(
		_pointer,_uniffiStatus)
	}))
}
func (object *VersionAssignment) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterVersionAssignment struct {}

var FfiConverterVersionAssignmentINSTANCE = FfiConverterVersionAssignment{}


func (c FfiConverterVersionAssignment) Lift(pointer unsafe.Pointer) *VersionAssignment {
	result := &VersionAssignment {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_versionassignment(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_versionassignment(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*VersionAssignment).Destroy)
	return result
}

func (c FfiConverterVersionAssignment) Read(reader io.Reader) *VersionAssignment {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterVersionAssignment) Lower(value *VersionAssignment) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*VersionAssignment")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterVersionAssignment) Write(writer io.Writer, value *VersionAssignment) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerVersionAssignment struct {}

func (_ FfiDestroyerVersionAssignment) Destroy(value *VersionAssignment) {
		value.Destroy()
}



// A zklogin authenticator
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// zklogin-bcs = bytes             ; contents are defined by <zklogin-authenticator>
// zklogin     = zklogin-flag
// zklogin-inputs
// u64               ; max epoch
// simple-signature
// ```
//
// Note: Due to historical reasons, signatures are serialized slightly
// different from the majority of the types in IOTA. In particular if a
// signature is ever embedded in another structure it generally is serialized
// as `bytes` meaning it has a length prefix that defines the length of
// the completely serialized signature.
type ZkLoginAuthenticatorInterface interface {
	Inputs() *ZkLoginInputs
	MaxEpoch() uint64
	Signature() *SimpleSignature
}
// A zklogin authenticator
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// zklogin-bcs = bytes             ; contents are defined by <zklogin-authenticator>
// zklogin     = zklogin-flag
// zklogin-inputs
// u64               ; max epoch
// simple-signature
// ```
//
// Note: Due to historical reasons, signatures are serialized slightly
// different from the majority of the types in IOTA. In particular if a
// signature is ever embedded in another structure it generally is serialized
// as `bytes` meaning it has a length prefix that defines the length of
// the completely serialized signature.
type ZkLoginAuthenticator struct {
	ffiObject FfiObject
}
func NewZkLoginAuthenticator(inputs *ZkLoginInputs, maxEpoch uint64, signature *SimpleSignature) *ZkLoginAuthenticator {
	return FfiConverterZkLoginAuthenticatorINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_zkloginauthenticator_new(FfiConverterZkLoginInputsINSTANCE.Lower(inputs), FfiConverterUint64INSTANCE.Lower(maxEpoch), FfiConverterSimpleSignatureINSTANCE.Lower(signature),_uniffiStatus)
	}))
}




func (_self *ZkLoginAuthenticator) Inputs() *ZkLoginInputs {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginAuthenticator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterZkLoginInputsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_inputs(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ZkLoginAuthenticator) MaxEpoch() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginAuthenticator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_max_epoch(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ZkLoginAuthenticator) Signature() *SimpleSignature {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginAuthenticator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSimpleSignatureINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_signature(
		_pointer,_uniffiStatus)
	}))
}
func (object *ZkLoginAuthenticator) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterZkLoginAuthenticator struct {}

var FfiConverterZkLoginAuthenticatorINSTANCE = FfiConverterZkLoginAuthenticator{}


func (c FfiConverterZkLoginAuthenticator) Lift(pointer unsafe.Pointer) *ZkLoginAuthenticator {
	result := &ZkLoginAuthenticator {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_zkloginauthenticator(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_zkloginauthenticator(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ZkLoginAuthenticator).Destroy)
	return result
}

func (c FfiConverterZkLoginAuthenticator) Read(reader io.Reader) *ZkLoginAuthenticator {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterZkLoginAuthenticator) Lower(value *ZkLoginAuthenticator) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ZkLoginAuthenticator")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterZkLoginAuthenticator) Write(writer io.Writer, value *ZkLoginAuthenticator) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerZkLoginAuthenticator struct {}

func (_ FfiDestroyerZkLoginAuthenticator) Destroy(value *ZkLoginAuthenticator) {
		value.Destroy()
}



// A zklogin groth16 proof and the required inputs to perform proof
// verification.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// zklogin-inputs = zklogin-proof
// zklogin-claim
// string              ; base64url-unpadded encoded JwtHeader
// bn254-field-element ; address_seed
// ```
type ZkLoginInputsInterface interface {
	AddressSeed() *Bn254FieldElement
	HeaderBase64() string
	Iss() string
	IssBase64Details() ZkLoginClaim
	JwkId() JwkId
	ProofPoints() *ZkLoginProof
	PublicIdentifier() *ZkLoginPublicIdentifier
}
// A zklogin groth16 proof and the required inputs to perform proof
// verification.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// zklogin-inputs = zklogin-proof
// zklogin-claim
// string              ; base64url-unpadded encoded JwtHeader
// bn254-field-element ; address_seed
// ```
type ZkLoginInputs struct {
	ffiObject FfiObject
}
func NewZkLoginInputs(proofPoints *ZkLoginProof, issBase64Details ZkLoginClaim, headerBase64 string, addressSeed *Bn254FieldElement) (*ZkLoginInputs, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_zklogininputs_new(FfiConverterZkLoginProofINSTANCE.Lower(proofPoints), FfiConverterZkLoginClaimINSTANCE.Lower(issBase64Details), FfiConverterStringINSTANCE.Lower(headerBase64), FfiConverterBn254FieldElementINSTANCE.Lower(addressSeed),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ZkLoginInputs
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterZkLoginInputsINSTANCE.Lift(_uniffiRV), nil
		}
}




func (_self *ZkLoginInputs) AddressSeed() *Bn254FieldElement {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginInputs")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBn254FieldElementINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zklogininputs_address_seed(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ZkLoginInputs) HeaderBase64() string {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginInputs")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_zklogininputs_header_base64(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ZkLoginInputs) Iss() string {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginInputs")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_zklogininputs_iss(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ZkLoginInputs) IssBase64Details() ZkLoginClaim {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginInputs")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterZkLoginClaimINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_zklogininputs_iss_base64_details(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ZkLoginInputs) JwkId() JwkId {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginInputs")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterJwkIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_zklogininputs_jwk_id(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ZkLoginInputs) ProofPoints() *ZkLoginProof {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginInputs")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterZkLoginProofINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zklogininputs_proof_points(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ZkLoginInputs) PublicIdentifier() *ZkLoginPublicIdentifier {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginInputs")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterZkLoginPublicIdentifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zklogininputs_public_identifier(
		_pointer,_uniffiStatus)
	}))
}
func (object *ZkLoginInputs) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterZkLoginInputs struct {}

var FfiConverterZkLoginInputsINSTANCE = FfiConverterZkLoginInputs{}


func (c FfiConverterZkLoginInputs) Lift(pointer unsafe.Pointer) *ZkLoginInputs {
	result := &ZkLoginInputs {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_zklogininputs(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_zklogininputs(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ZkLoginInputs).Destroy)
	return result
}

func (c FfiConverterZkLoginInputs) Read(reader io.Reader) *ZkLoginInputs {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterZkLoginInputs) Lower(value *ZkLoginInputs) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ZkLoginInputs")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterZkLoginInputs) Write(writer io.Writer, value *ZkLoginInputs) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerZkLoginInputs struct {}

func (_ FfiDestroyerZkLoginInputs) Destroy(value *ZkLoginInputs) {
		value.Destroy()
}



// A zklogin groth16 proof
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// zklogin-proof = circom-g1 circom-g2 circom-g1
// ```
type ZkLoginProofInterface interface {
	A() *CircomG1
	B() *CircomG2
	C() *CircomG1
}
// A zklogin groth16 proof
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// zklogin-proof = circom-g1 circom-g2 circom-g1
// ```
type ZkLoginProof struct {
	ffiObject FfiObject
}
func NewZkLoginProof(a *CircomG1, b *CircomG2, c *CircomG1) *ZkLoginProof {
	return FfiConverterZkLoginProofINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_zkloginproof_new(FfiConverterCircomG1INSTANCE.Lower(a), FfiConverterCircomG2INSTANCE.Lower(b), FfiConverterCircomG1INSTANCE.Lower(c),_uniffiStatus)
	}))
}




func (_self *ZkLoginProof) A() *CircomG1 {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginProof")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterCircomG1INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginproof_a(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ZkLoginProof) B() *CircomG2 {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginProof")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterCircomG2INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginproof_b(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ZkLoginProof) C() *CircomG1 {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginProof")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterCircomG1INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginproof_c(
		_pointer,_uniffiStatus)
	}))
}
func (object *ZkLoginProof) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterZkLoginProof struct {}

var FfiConverterZkLoginProofINSTANCE = FfiConverterZkLoginProof{}


func (c FfiConverterZkLoginProof) Lift(pointer unsafe.Pointer) *ZkLoginProof {
	result := &ZkLoginProof {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_zkloginproof(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_zkloginproof(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ZkLoginProof).Destroy)
	return result
}

func (c FfiConverterZkLoginProof) Read(reader io.Reader) *ZkLoginProof {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterZkLoginProof) Lower(value *ZkLoginProof) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ZkLoginProof")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterZkLoginProof) Write(writer io.Writer, value *ZkLoginProof) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerZkLoginProof struct {}

func (_ FfiDestroyerZkLoginProof) Destroy(value *ZkLoginProof) {
		value.Destroy()
}



// Public Key equivalent for Zklogin authenticators
//
// A `ZkLoginPublicIdentifier` is the equivalent of a public key for other
// account authenticators, and contains the information required to derive the
// onchain account `Address` for a Zklogin authenticator.
//
// ## Note
//
// Due to a historical bug that was introduced in the IOTA Typescript SDK when
// the zklogin authenticator was first introduced, there are now possibly two
// "valid" addresses for each zklogin authenticator depending on the
// bit-pattern of the `address_seed` value.
//
// The original bug incorrectly derived a zklogin's address by stripping any
// leading zero-bytes that could have been present in the 32-byte length
// `address_seed` value prior to hashing, leading to a different derived
// address. This incorrectly derived address was presented to users of various
// wallets, leading them to sending funds to these addresses that they couldn't
// access. Instead of letting these users lose any assets that were sent to
// these addresses, the IOTA network decided to change the protocol to allow
// for a zklogin authenticator who's `address_seed` value had leading
// zero-bytes be authorized to sign for both the addresses derived from both
// the unpadded and padded `address_seed` value.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// zklogin-public-identifier-bcs = bytes ; where the contents are defined by
// ; <zklogin-public-identifier>
//
// zklogin-public-identifier = zklogin-public-identifier-iss
// address-seed
//
// zklogin-public-identifier-unpadded = zklogin-public-identifier-iss
// address-seed-unpadded
//
// ; The iss, or issuer, is a utf8 string that is less than 255 bytes long
// ; and is serialized with the iss's length in bytes as a u8 followed by
// ; the bytes of the iss
// zklogin-public-identifier-iss = u8 *255(OCTET)
//
// ; A Bn254FieldElement serialized as a 32-byte big-endian value
// address-seed = 32(OCTET)
//
// ; A Bn254FieldElement serialized as a 32-byte big-endian value
// ; with any leading zero bytes stripped
// address-seed-unpadded = %x00 / %x01-ff *31(OCTET)
// ```
type ZkLoginPublicIdentifierInterface interface {
	AddressSeed() *Bn254FieldElement
	// Provides an iterator over the addresses that correspond to this zklogin
	// authenticator.
	//
	// In the majority of instances this will only yield a single address,
	// except for the instances where the `address_seed` value has a
	// leading zero-byte, in such cases the returned iterator will yield
	// two addresses.
	DeriveAddress() []*Address
	// Derive an `Address` from this `ZkLoginPublicIdentifier` by hashing the
	// byte length of the `iss` followed by the `iss` bytes themselves and
	// the full 32 byte `address_seed` value, all prefixed with the zklogin
	// `SignatureScheme` flag (`0x05`).
	//
	// `hash( 0x05 || iss_bytes_len || iss_bytes || 32_byte_address_seed )`
	DeriveAddressPadded() *Address
	// Derive an `Address` from this `ZkLoginPublicIdentifier` by hashing the
	// byte length of the `iss` followed by the `iss` bytes themselves and
	// the `address_seed` bytes with any leading zero-bytes stripped, all
	// prefixed with the zklogin `SignatureScheme` flag (`0x05`).
	//
	// `hash( 0x05 || iss_bytes_len || iss_bytes ||
	// unpadded_32_byte_address_seed )`
	DeriveAddressUnpadded() *Address
	Iss() string
}
// Public Key equivalent for Zklogin authenticators
//
// A `ZkLoginPublicIdentifier` is the equivalent of a public key for other
// account authenticators, and contains the information required to derive the
// onchain account `Address` for a Zklogin authenticator.
//
// ## Note
//
// Due to a historical bug that was introduced in the IOTA Typescript SDK when
// the zklogin authenticator was first introduced, there are now possibly two
// "valid" addresses for each zklogin authenticator depending on the
// bit-pattern of the `address_seed` value.
//
// The original bug incorrectly derived a zklogin's address by stripping any
// leading zero-bytes that could have been present in the 32-byte length
// `address_seed` value prior to hashing, leading to a different derived
// address. This incorrectly derived address was presented to users of various
// wallets, leading them to sending funds to these addresses that they couldn't
// access. Instead of letting these users lose any assets that were sent to
// these addresses, the IOTA network decided to change the protocol to allow
// for a zklogin authenticator who's `address_seed` value had leading
// zero-bytes be authorized to sign for both the addresses derived from both
// the unpadded and padded `address_seed` value.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// zklogin-public-identifier-bcs = bytes ; where the contents are defined by
// ; <zklogin-public-identifier>
//
// zklogin-public-identifier = zklogin-public-identifier-iss
// address-seed
//
// zklogin-public-identifier-unpadded = zklogin-public-identifier-iss
// address-seed-unpadded
//
// ; The iss, or issuer, is a utf8 string that is less than 255 bytes long
// ; and is serialized with the iss's length in bytes as a u8 followed by
// ; the bytes of the iss
// zklogin-public-identifier-iss = u8 *255(OCTET)
//
// ; A Bn254FieldElement serialized as a 32-byte big-endian value
// address-seed = 32(OCTET)
//
// ; A Bn254FieldElement serialized as a 32-byte big-endian value
// ; with any leading zero bytes stripped
// address-seed-unpadded = %x00 / %x01-ff *31(OCTET)
// ```
type ZkLoginPublicIdentifier struct {
	ffiObject FfiObject
}
func NewZkLoginPublicIdentifier(iss string, addressSeed *Bn254FieldElement) (*ZkLoginPublicIdentifier, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_zkloginpublicidentifier_new(FfiConverterStringINSTANCE.Lower(iss), FfiConverterBn254FieldElementINSTANCE.Lower(addressSeed),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ZkLoginPublicIdentifier
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterZkLoginPublicIdentifierINSTANCE.Lift(_uniffiRV), nil
		}
}




func (_self *ZkLoginPublicIdentifier) AddressSeed() *Bn254FieldElement {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginPublicIdentifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBn254FieldElementINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_address_seed(
		_pointer,_uniffiStatus)
	}))
}

// Provides an iterator over the addresses that correspond to this zklogin
// authenticator.
//
// In the majority of instances this will only yield a single address,
// except for the instances where the `address_seed` value has a
// leading zero-byte, in such cases the returned iterator will yield
// two addresses.
func (_self *ZkLoginPublicIdentifier) DeriveAddress() []*Address {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginPublicIdentifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address(
		_pointer,_uniffiStatus),
	}
	}))
}

// Derive an `Address` from this `ZkLoginPublicIdentifier` by hashing the
// byte length of the `iss` followed by the `iss` bytes themselves and
// the full 32 byte `address_seed` value, all prefixed with the zklogin
// `SignatureScheme` flag (`0x05`).
//
// `hash( 0x05 || iss_bytes_len || iss_bytes || 32_byte_address_seed )`
func (_self *ZkLoginPublicIdentifier) DeriveAddressPadded() *Address {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginPublicIdentifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address_padded(
		_pointer,_uniffiStatus)
	}))
}

// Derive an `Address` from this `ZkLoginPublicIdentifier` by hashing the
// byte length of the `iss` followed by the `iss` bytes themselves and
// the `address_seed` bytes with any leading zero-bytes stripped, all
// prefixed with the zklogin `SignatureScheme` flag (`0x05`).
//
// `hash( 0x05 || iss_bytes_len || iss_bytes ||
// unpadded_32_byte_address_seed )`
func (_self *ZkLoginPublicIdentifier) DeriveAddressUnpadded() *Address {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginPublicIdentifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterAddressINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address_unpadded(
		_pointer,_uniffiStatus)
	}))
}

func (_self *ZkLoginPublicIdentifier) Iss() string {
	_pointer := _self.ffiObject.incrementPointer("*ZkLoginPublicIdentifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_iss(
		_pointer,_uniffiStatus),
	}
	}))
}
func (object *ZkLoginPublicIdentifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterZkLoginPublicIdentifier struct {}

var FfiConverterZkLoginPublicIdentifierINSTANCE = FfiConverterZkLoginPublicIdentifier{}


func (c FfiConverterZkLoginPublicIdentifier) Lift(pointer unsafe.Pointer) *ZkLoginPublicIdentifier {
	result := &ZkLoginPublicIdentifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_zkloginpublicidentifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_zkloginpublicidentifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ZkLoginPublicIdentifier).Destroy)
	return result
}

func (c FfiConverterZkLoginPublicIdentifier) Read(reader io.Reader) *ZkLoginPublicIdentifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterZkLoginPublicIdentifier) Lower(value *ZkLoginPublicIdentifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ZkLoginPublicIdentifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterZkLoginPublicIdentifier) Write(writer io.Writer, value *ZkLoginPublicIdentifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerZkLoginPublicIdentifier struct {}

func (_ FfiDestroyerZkLoginPublicIdentifier) Destroy(value *ZkLoginPublicIdentifier) {
		value.Destroy()
}



type ZkloginVerifierInterface interface {
	Jwks() map[JwkId]Jwk
	Verify(message []byte, authenticator *ZkLoginAuthenticator) error
	WithJwks(jwks map[JwkId]Jwk) *ZkloginVerifier
}
type ZkloginVerifier struct {
	ffiObject FfiObject
}


// Load a fixed verifying key from zkLogin.vkey output. This is based on a
// local setup and should not be used in production.
func ZkloginVerifierNewDev() *ZkloginVerifier {
	return FfiConverterZkloginVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_zkloginverifier_new_dev(_uniffiStatus)
	}))
}

func ZkloginVerifierNewMainnet() *ZkloginVerifier {
	return FfiConverterZkloginVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_constructor_zkloginverifier_new_mainnet(_uniffiStatus)
	}))
}



func (_self *ZkloginVerifier) Jwks() map[JwkId]Jwk {
	_pointer := _self.ffiObject.incrementPointer("*ZkloginVerifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMapJwkIdJwkINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_jwks(
		_pointer,_uniffiStatus),
	}
	}))
}

func (_self *ZkloginVerifier) Verify(message []byte, authenticator *ZkLoginAuthenticator) error {
	_pointer := _self.ffiObject.incrementPointer("*ZkloginVerifier")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_verify(
		_pointer,FfiConverterBytesINSTANCE.Lower(message), FfiConverterZkLoginAuthenticatorINSTANCE.Lower(authenticator),_uniffiStatus)
		return false
	})
		return _uniffiErr.AsError()
}

func (_self *ZkloginVerifier) WithJwks(jwks map[JwkId]Jwk) *ZkloginVerifier {
	_pointer := _self.ffiObject.incrementPointer("*ZkloginVerifier")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterZkloginVerifierINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_with_jwks(
		_pointer,FfiConverterMapJwkIdJwkINSTANCE.Lower(jwks),_uniffiStatus)
	}))
}
func (object *ZkloginVerifier) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterZkloginVerifier struct {}

var FfiConverterZkloginVerifierINSTANCE = FfiConverterZkloginVerifier{}


func (c FfiConverterZkloginVerifier) Lift(pointer unsafe.Pointer) *ZkloginVerifier {
	result := &ZkloginVerifier {
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_iota_sdk_ffi_fn_clone_zkloginverifier(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_iota_sdk_ffi_fn_free_zkloginverifier(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ZkloginVerifier).Destroy)
	return result
}

func (c FfiConverterZkloginVerifier) Read(reader io.Reader) *ZkloginVerifier {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterZkloginVerifier) Lower(value *ZkloginVerifier) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ZkloginVerifier")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterZkloginVerifier) Write(writer io.Writer, value *ZkloginVerifier) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerZkloginVerifier struct {}

func (_ FfiDestroyerZkloginVerifier) Destroy(value *ZkloginVerifier) {
		value.Destroy()
}



// A new Jwk
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// active-jwk = jwk-id jwk u64
// ```
type ActiveJwk struct {
	// Identifier used to uniquely identify a Jwk
	JwkId JwkId
	// The Jwk
	Jwk Jwk
	// Most recent epoch in which the jwk was validated
	Epoch uint64
}

func (r *ActiveJwk) Destroy() {
		FfiDestroyerJwkId{}.Destroy(r.JwkId);
		FfiDestroyerJwk{}.Destroy(r.Jwk);
		FfiDestroyerUint64{}.Destroy(r.Epoch);
}

type FfiConverterActiveJwk struct {}

var FfiConverterActiveJwkINSTANCE = FfiConverterActiveJwk{}

func (c FfiConverterActiveJwk) Lift(rb RustBufferI) ActiveJwk {
	return LiftFromRustBuffer[ActiveJwk](c, rb)
}

func (c FfiConverterActiveJwk) Read(reader io.Reader) ActiveJwk {
	return ActiveJwk {
			FfiConverterJwkIdINSTANCE.Read(reader),
			FfiConverterJwkINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterActiveJwk) Lower(value ActiveJwk) C.RustBuffer {
	return LowerIntoRustBuffer[ActiveJwk](c, value)
}

func (c FfiConverterActiveJwk) Write(writer io.Writer, value ActiveJwk) {
		FfiConverterJwkIdINSTANCE.Write(writer, value.JwkId);
		FfiConverterJwkINSTANCE.Write(writer, value.Jwk);
		FfiConverterUint64INSTANCE.Write(writer, value.Epoch);
}

type FfiDestroyerActiveJwk struct {}

func (_ FfiDestroyerActiveJwk) Destroy(value ActiveJwk) {
	value.Destroy()
}
// Expire old JWKs
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// authenticator-state-expire = u64 u64
// ```
type AuthenticatorStateExpire struct {
	// Expire JWKs that have a lower epoch than this
	MinEpoch uint64
	// The initial version of the authenticator object that it was shared at.
	AuthenticatorObjInitialSharedVersion uint64
}

func (r *AuthenticatorStateExpire) Destroy() {
		FfiDestroyerUint64{}.Destroy(r.MinEpoch);
		FfiDestroyerUint64{}.Destroy(r.AuthenticatorObjInitialSharedVersion);
}

type FfiConverterAuthenticatorStateExpire struct {}

var FfiConverterAuthenticatorStateExpireINSTANCE = FfiConverterAuthenticatorStateExpire{}

func (c FfiConverterAuthenticatorStateExpire) Lift(rb RustBufferI) AuthenticatorStateExpire {
	return LiftFromRustBuffer[AuthenticatorStateExpire](c, rb)
}

func (c FfiConverterAuthenticatorStateExpire) Read(reader io.Reader) AuthenticatorStateExpire {
	return AuthenticatorStateExpire {
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterAuthenticatorStateExpire) Lower(value AuthenticatorStateExpire) C.RustBuffer {
	return LowerIntoRustBuffer[AuthenticatorStateExpire](c, value)
}

func (c FfiConverterAuthenticatorStateExpire) Write(writer io.Writer, value AuthenticatorStateExpire) {
		FfiConverterUint64INSTANCE.Write(writer, value.MinEpoch);
		FfiConverterUint64INSTANCE.Write(writer, value.AuthenticatorObjInitialSharedVersion);
}

type FfiDestroyerAuthenticatorStateExpire struct {}

func (_ FfiDestroyerAuthenticatorStateExpire) Destroy(value AuthenticatorStateExpire) {
	value.Destroy()
}
// Update the set of valid JWKs
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// authenticator-state-update = u64 ; epoch
// u64 ; round
// (vector active-jwk)
// u64 ; initial version of the authenticator object
// ```
type AuthenticatorStateUpdateV1 struct {
	// Epoch of the authenticator state update transaction
	Epoch uint64
	// Consensus round of the authenticator state update
	Round uint64
	// newly active jwks
	NewActiveJwks []ActiveJwk
	AuthenticatorObjInitialSharedVersion uint64
}

func (r *AuthenticatorStateUpdateV1) Destroy() {
		FfiDestroyerUint64{}.Destroy(r.Epoch);
		FfiDestroyerUint64{}.Destroy(r.Round);
		FfiDestroyerSequenceActiveJwk{}.Destroy(r.NewActiveJwks);
		FfiDestroyerUint64{}.Destroy(r.AuthenticatorObjInitialSharedVersion);
}

type FfiConverterAuthenticatorStateUpdateV1 struct {}

var FfiConverterAuthenticatorStateUpdateV1INSTANCE = FfiConverterAuthenticatorStateUpdateV1{}

func (c FfiConverterAuthenticatorStateUpdateV1) Lift(rb RustBufferI) AuthenticatorStateUpdateV1 {
	return LiftFromRustBuffer[AuthenticatorStateUpdateV1](c, rb)
}

func (c FfiConverterAuthenticatorStateUpdateV1) Read(reader io.Reader) AuthenticatorStateUpdateV1 {
	return AuthenticatorStateUpdateV1 {
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterSequenceActiveJwkINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterAuthenticatorStateUpdateV1) Lower(value AuthenticatorStateUpdateV1) C.RustBuffer {
	return LowerIntoRustBuffer[AuthenticatorStateUpdateV1](c, value)
}

func (c FfiConverterAuthenticatorStateUpdateV1) Write(writer io.Writer, value AuthenticatorStateUpdateV1) {
		FfiConverterUint64INSTANCE.Write(writer, value.Epoch);
		FfiConverterUint64INSTANCE.Write(writer, value.Round);
		FfiConverterSequenceActiveJwkINSTANCE.Write(writer, value.NewActiveJwks);
		FfiConverterUint64INSTANCE.Write(writer, value.AuthenticatorObjInitialSharedVersion);
}

type FfiDestroyerAuthenticatorStateUpdateV1 struct {}

func (_ FfiDestroyerAuthenticatorStateUpdateV1) Destroy(value AuthenticatorStateUpdateV1) {
	value.Destroy()
}
type BatchSendStatus struct {
	Status BatchSendStatusType
	TransferredGasObjects *FaucetReceipt
}

func (r *BatchSendStatus) Destroy() {
		FfiDestroyerBatchSendStatusType{}.Destroy(r.Status);
		FfiDestroyerOptionalFaucetReceipt{}.Destroy(r.TransferredGasObjects);
}

type FfiConverterBatchSendStatus struct {}

var FfiConverterBatchSendStatusINSTANCE = FfiConverterBatchSendStatus{}

func (c FfiConverterBatchSendStatus) Lift(rb RustBufferI) BatchSendStatus {
	return LiftFromRustBuffer[BatchSendStatus](c, rb)
}

func (c FfiConverterBatchSendStatus) Read(reader io.Reader) BatchSendStatus {
	return BatchSendStatus {
			FfiConverterBatchSendStatusTypeINSTANCE.Read(reader),
			FfiConverterOptionalFaucetReceiptINSTANCE.Read(reader),
	}
}

func (c FfiConverterBatchSendStatus) Lower(value BatchSendStatus) C.RustBuffer {
	return LowerIntoRustBuffer[BatchSendStatus](c, value)
}

func (c FfiConverterBatchSendStatus) Write(writer io.Writer, value BatchSendStatus) {
		FfiConverterBatchSendStatusTypeINSTANCE.Write(writer, value.Status);
		FfiConverterOptionalFaucetReceiptINSTANCE.Write(writer, value.TransferredGasObjects);
}

type FfiDestroyerBatchSendStatus struct {}

func (_ FfiDestroyerBatchSendStatus) Destroy(value BatchSendStatus) {
	value.Destroy()
}
// Input/output state of an object that was changed during execution
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// changed-object = object-id object-in object-out id-operation
// ```
type ChangedObject struct {
	// Id of the object
	ObjectId *ObjectId
	// State of the object in the store prior to this transaction.
	InputState ObjectIn
	// State of the object in the store after this transaction.
	OutputState ObjectOut
	// Whether this object ID is created or deleted in this transaction.
	// This information isn't required by the protocol but is useful for
	// providing more detailed semantics on object changes.
	IdOperation IdOperation
}

func (r *ChangedObject) Destroy() {
		FfiDestroyerObjectId{}.Destroy(r.ObjectId);
		FfiDestroyerObjectIn{}.Destroy(r.InputState);
		FfiDestroyerObjectOut{}.Destroy(r.OutputState);
		FfiDestroyerIdOperation{}.Destroy(r.IdOperation);
}

type FfiConverterChangedObject struct {}

var FfiConverterChangedObjectINSTANCE = FfiConverterChangedObject{}

func (c FfiConverterChangedObject) Lift(rb RustBufferI) ChangedObject {
	return LiftFromRustBuffer[ChangedObject](c, rb)
}

func (c FfiConverterChangedObject) Read(reader io.Reader) ChangedObject {
	return ChangedObject {
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterObjectInINSTANCE.Read(reader),
			FfiConverterObjectOutINSTANCE.Read(reader),
			FfiConverterIdOperationINSTANCE.Read(reader),
	}
}

func (c FfiConverterChangedObject) Lower(value ChangedObject) C.RustBuffer {
	return LowerIntoRustBuffer[ChangedObject](c, value)
}

func (c FfiConverterChangedObject) Write(writer io.Writer, value ChangedObject) {
		FfiConverterObjectIdINSTANCE.Write(writer, value.ObjectId);
		FfiConverterObjectInINSTANCE.Write(writer, value.InputState);
		FfiConverterObjectOutINSTANCE.Write(writer, value.OutputState);
		FfiConverterIdOperationINSTANCE.Write(writer, value.IdOperation);
}

type FfiDestroyerChangedObject struct {}

func (_ FfiDestroyerChangedObject) Destroy(value ChangedObject) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type CheckpointSummaryPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []*CheckpointSummary
}

func (r *CheckpointSummaryPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceCheckpointSummary{}.Destroy(r.Data);
}

type FfiConverterCheckpointSummaryPage struct {}

var FfiConverterCheckpointSummaryPageINSTANCE = FfiConverterCheckpointSummaryPage{}

func (c FfiConverterCheckpointSummaryPage) Lift(rb RustBufferI) CheckpointSummaryPage {
	return LiftFromRustBuffer[CheckpointSummaryPage](c, rb)
}

func (c FfiConverterCheckpointSummaryPage) Read(reader io.Reader) CheckpointSummaryPage {
	return CheckpointSummaryPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceCheckpointSummaryINSTANCE.Read(reader),
	}
}

func (c FfiConverterCheckpointSummaryPage) Lower(value CheckpointSummaryPage) C.RustBuffer {
	return LowerIntoRustBuffer[CheckpointSummaryPage](c, value)
}

func (c FfiConverterCheckpointSummaryPage) Write(writer io.Writer, value CheckpointSummaryPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceCheckpointSummaryINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerCheckpointSummaryPage struct {}

func (_ FfiDestroyerCheckpointSummaryPage) Destroy(value CheckpointSummaryPage) {
	value.Destroy()
}
type CoinInfo struct {
	Amount uint64
	Id *ObjectId
	TransferTxDigest *Digest
}

func (r *CoinInfo) Destroy() {
		FfiDestroyerUint64{}.Destroy(r.Amount);
		FfiDestroyerObjectId{}.Destroy(r.Id);
		FfiDestroyerDigest{}.Destroy(r.TransferTxDigest);
}

type FfiConverterCoinInfo struct {}

var FfiConverterCoinInfoINSTANCE = FfiConverterCoinInfo{}

func (c FfiConverterCoinInfo) Lift(rb RustBufferI) CoinInfo {
	return LiftFromRustBuffer[CoinInfo](c, rb)
}

func (c FfiConverterCoinInfo) Read(reader io.Reader) CoinInfo {
	return CoinInfo {
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterDigestINSTANCE.Read(reader),
	}
}

func (c FfiConverterCoinInfo) Lower(value CoinInfo) C.RustBuffer {
	return LowerIntoRustBuffer[CoinInfo](c, value)
}

func (c FfiConverterCoinInfo) Write(writer io.Writer, value CoinInfo) {
		FfiConverterUint64INSTANCE.Write(writer, value.Amount);
		FfiConverterObjectIdINSTANCE.Write(writer, value.Id);
		FfiConverterDigestINSTANCE.Write(writer, value.TransferTxDigest);
}

type FfiDestroyerCoinInfo struct {}

func (_ FfiDestroyerCoinInfo) Destroy(value CoinInfo) {
	value.Destroy()
}
// The coin metadata associated with the given coin type.
type CoinMetadata struct {
	// The CoinMetadata object ID.
	Address *ObjectId
	// The number of decimal places used to represent the token.
	Decimals *int32
	// Optional description of the token, provided by the creator of the token.
	Description *string
	// Icon URL of the coin.
	IconUrl *string
	// Full, official name of the token.
	Name *string
	// The token's identifying abbreviation.
	Symbol *string
	// The overall quantity of tokens that will be issued.
	Supply *BigInt
	// Version of the token.
	Version uint64
}

func (r *CoinMetadata) Destroy() {
		FfiDestroyerObjectId{}.Destroy(r.Address);
		FfiDestroyerOptionalInt32{}.Destroy(r.Decimals);
		FfiDestroyerOptionalString{}.Destroy(r.Description);
		FfiDestroyerOptionalString{}.Destroy(r.IconUrl);
		FfiDestroyerOptionalString{}.Destroy(r.Name);
		FfiDestroyerOptionalString{}.Destroy(r.Symbol);
		FfiDestroyerOptionalTypeBigInt{}.Destroy(r.Supply);
		FfiDestroyerUint64{}.Destroy(r.Version);
}

type FfiConverterCoinMetadata struct {}

var FfiConverterCoinMetadataINSTANCE = FfiConverterCoinMetadata{}

func (c FfiConverterCoinMetadata) Lift(rb RustBufferI) CoinMetadata {
	return LiftFromRustBuffer[CoinMetadata](c, rb)
}

func (c FfiConverterCoinMetadata) Read(reader io.Reader) CoinMetadata {
	return CoinMetadata {
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterOptionalInt32INSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalTypeBigIntINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterCoinMetadata) Lower(value CoinMetadata) C.RustBuffer {
	return LowerIntoRustBuffer[CoinMetadata](c, value)
}

func (c FfiConverterCoinMetadata) Write(writer io.Writer, value CoinMetadata) {
		FfiConverterObjectIdINSTANCE.Write(writer, value.Address);
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.Decimals);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.Description);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.IconUrl);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.Name);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.Symbol);
		FfiConverterOptionalTypeBigIntINSTANCE.Write(writer, value.Supply);
		FfiConverterUint64INSTANCE.Write(writer, value.Version);
}

type FfiDestroyerCoinMetadata struct {}

func (_ FfiDestroyerCoinMetadata) Destroy(value CoinMetadata) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type CoinPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []*Coin
}

func (r *CoinPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceCoin{}.Destroy(r.Data);
}

type FfiConverterCoinPage struct {}

var FfiConverterCoinPageINSTANCE = FfiConverterCoinPage{}

func (c FfiConverterCoinPage) Lift(rb RustBufferI) CoinPage {
	return LiftFromRustBuffer[CoinPage](c, rb)
}

func (c FfiConverterCoinPage) Read(reader io.Reader) CoinPage {
	return CoinPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceCoinINSTANCE.Read(reader),
	}
}

func (c FfiConverterCoinPage) Lower(value CoinPage) C.RustBuffer {
	return LowerIntoRustBuffer[CoinPage](c, value)
}

func (c FfiConverterCoinPage) Write(writer io.Writer, value CoinPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceCoinINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerCoinPage struct {}

func (_ FfiDestroyerCoinPage) Destroy(value CoinPage) {
	value.Destroy()
}
// Effects of a single command in the dry run, including mutated references
// and return values.
type DryRunEffect struct {
	// Changes made to arguments that were mutably borrowed by this command.
	MutatedReferences []DryRunMutation
	// Return results of this command.
	ReturnValues []DryRunReturn
}

func (r *DryRunEffect) Destroy() {
		FfiDestroyerSequenceDryRunMutation{}.Destroy(r.MutatedReferences);
		FfiDestroyerSequenceDryRunReturn{}.Destroy(r.ReturnValues);
}

type FfiConverterDryRunEffect struct {}

var FfiConverterDryRunEffectINSTANCE = FfiConverterDryRunEffect{}

func (c FfiConverterDryRunEffect) Lift(rb RustBufferI) DryRunEffect {
	return LiftFromRustBuffer[DryRunEffect](c, rb)
}

func (c FfiConverterDryRunEffect) Read(reader io.Reader) DryRunEffect {
	return DryRunEffect {
			FfiConverterSequenceDryRunMutationINSTANCE.Read(reader),
			FfiConverterSequenceDryRunReturnINSTANCE.Read(reader),
	}
}

func (c FfiConverterDryRunEffect) Lower(value DryRunEffect) C.RustBuffer {
	return LowerIntoRustBuffer[DryRunEffect](c, value)
}

func (c FfiConverterDryRunEffect) Write(writer io.Writer, value DryRunEffect) {
		FfiConverterSequenceDryRunMutationINSTANCE.Write(writer, value.MutatedReferences);
		FfiConverterSequenceDryRunReturnINSTANCE.Write(writer, value.ReturnValues);
}

type FfiDestroyerDryRunEffect struct {}

func (_ FfiDestroyerDryRunEffect) Destroy(value DryRunEffect) {
	value.Destroy()
}
// A mutation to an argument that was mutably borrowed by a command.
type DryRunMutation struct {
	// The transaction argument that was mutated.
	Input TransactionArgument
	// The Move type of the mutated value.
	TypeTag *TypeTag
	// The BCS representation of the mutated value.
	Bcs []byte
}

func (r *DryRunMutation) Destroy() {
		FfiDestroyerTransactionArgument{}.Destroy(r.Input);
		FfiDestroyerTypeTag{}.Destroy(r.TypeTag);
		FfiDestroyerBytes{}.Destroy(r.Bcs);
}

type FfiConverterDryRunMutation struct {}

var FfiConverterDryRunMutationINSTANCE = FfiConverterDryRunMutation{}

func (c FfiConverterDryRunMutation) Lift(rb RustBufferI) DryRunMutation {
	return LiftFromRustBuffer[DryRunMutation](c, rb)
}

func (c FfiConverterDryRunMutation) Read(reader io.Reader) DryRunMutation {
	return DryRunMutation {
			FfiConverterTransactionArgumentINSTANCE.Read(reader),
			FfiConverterTypeTagINSTANCE.Read(reader),
			FfiConverterBytesINSTANCE.Read(reader),
	}
}

func (c FfiConverterDryRunMutation) Lower(value DryRunMutation) C.RustBuffer {
	return LowerIntoRustBuffer[DryRunMutation](c, value)
}

func (c FfiConverterDryRunMutation) Write(writer io.Writer, value DryRunMutation) {
		FfiConverterTransactionArgumentINSTANCE.Write(writer, value.Input);
		FfiConverterTypeTagINSTANCE.Write(writer, value.TypeTag);
		FfiConverterBytesINSTANCE.Write(writer, value.Bcs);
}

type FfiDestroyerDryRunMutation struct {}

func (_ FfiDestroyerDryRunMutation) Destroy(value DryRunMutation) {
	value.Destroy()
}
// The result of a simulation (dry run), which includes the effects of the
// transaction, any errors that may have occurred, and intermediate results for
// each command.
type DryRunResult struct {
	// The error that occurred during dry run execution, if any.
	Error *string
	// The intermediate results for each command of the dry run execution,
	// including contents of mutated references and return values.
	Results []DryRunEffect
	// The transaction block representing the dry run execution.
	Transaction *SignedTransaction
	// The effects of the transaction execution.
	Effects **TransactionEffects
}

func (r *DryRunResult) Destroy() {
		FfiDestroyerOptionalString{}.Destroy(r.Error);
		FfiDestroyerSequenceDryRunEffect{}.Destroy(r.Results);
		FfiDestroyerOptionalSignedTransaction{}.Destroy(r.Transaction);
		FfiDestroyerOptionalTransactionEffects{}.Destroy(r.Effects);
}

type FfiConverterDryRunResult struct {}

var FfiConverterDryRunResultINSTANCE = FfiConverterDryRunResult{}

func (c FfiConverterDryRunResult) Lift(rb RustBufferI) DryRunResult {
	return LiftFromRustBuffer[DryRunResult](c, rb)
}

func (c FfiConverterDryRunResult) Read(reader io.Reader) DryRunResult {
	return DryRunResult {
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterSequenceDryRunEffectINSTANCE.Read(reader),
			FfiConverterOptionalSignedTransactionINSTANCE.Read(reader),
			FfiConverterOptionalTransactionEffectsINSTANCE.Read(reader),
	}
}

func (c FfiConverterDryRunResult) Lower(value DryRunResult) C.RustBuffer {
	return LowerIntoRustBuffer[DryRunResult](c, value)
}

func (c FfiConverterDryRunResult) Write(writer io.Writer, value DryRunResult) {
		FfiConverterOptionalStringINSTANCE.Write(writer, value.Error);
		FfiConverterSequenceDryRunEffectINSTANCE.Write(writer, value.Results);
		FfiConverterOptionalSignedTransactionINSTANCE.Write(writer, value.Transaction);
		FfiConverterOptionalTransactionEffectsINSTANCE.Write(writer, value.Effects);
}

type FfiDestroyerDryRunResult struct {}

func (_ FfiDestroyerDryRunResult) Destroy(value DryRunResult) {
	value.Destroy()
}
// A return value from a command in the dry run.
type DryRunReturn struct {
	// The Move type of the return value.
	TypeTag *TypeTag
	// The BCS representation of the return value.
	Bcs []byte
}

func (r *DryRunReturn) Destroy() {
		FfiDestroyerTypeTag{}.Destroy(r.TypeTag);
		FfiDestroyerBytes{}.Destroy(r.Bcs);
}

type FfiConverterDryRunReturn struct {}

var FfiConverterDryRunReturnINSTANCE = FfiConverterDryRunReturn{}

func (c FfiConverterDryRunReturn) Lift(rb RustBufferI) DryRunReturn {
	return LiftFromRustBuffer[DryRunReturn](c, rb)
}

func (c FfiConverterDryRunReturn) Read(reader io.Reader) DryRunReturn {
	return DryRunReturn {
			FfiConverterTypeTagINSTANCE.Read(reader),
			FfiConverterBytesINSTANCE.Read(reader),
	}
}

func (c FfiConverterDryRunReturn) Lower(value DryRunReturn) C.RustBuffer {
	return LowerIntoRustBuffer[DryRunReturn](c, value)
}

func (c FfiConverterDryRunReturn) Write(writer io.Writer, value DryRunReturn) {
		FfiConverterTypeTagINSTANCE.Write(writer, value.TypeTag);
		FfiConverterBytesINSTANCE.Write(writer, value.Bcs);
}

type FfiDestroyerDryRunReturn struct {}

func (_ FfiDestroyerDryRunReturn) Destroy(value DryRunReturn) {
	value.Destroy()
}
// The name part of a dynamic field, including its type, bcs, and json
// representation.
type DynamicFieldName struct {
	// The type name of this dynamic field name
	TypeTag *TypeTag
	// The bcs bytes of this dynamic field name
	Bcs []byte
	// The json representation of the dynamic field name
	Json *Value
}

func (r *DynamicFieldName) Destroy() {
		FfiDestroyerTypeTag{}.Destroy(r.TypeTag);
		FfiDestroyerBytes{}.Destroy(r.Bcs);
		FfiDestroyerOptionalTypeValue{}.Destroy(r.Json);
}

type FfiConverterDynamicFieldName struct {}

var FfiConverterDynamicFieldNameINSTANCE = FfiConverterDynamicFieldName{}

func (c FfiConverterDynamicFieldName) Lift(rb RustBufferI) DynamicFieldName {
	return LiftFromRustBuffer[DynamicFieldName](c, rb)
}

func (c FfiConverterDynamicFieldName) Read(reader io.Reader) DynamicFieldName {
	return DynamicFieldName {
			FfiConverterTypeTagINSTANCE.Read(reader),
			FfiConverterBytesINSTANCE.Read(reader),
			FfiConverterOptionalTypeValueINSTANCE.Read(reader),
	}
}

func (c FfiConverterDynamicFieldName) Lower(value DynamicFieldName) C.RustBuffer {
	return LowerIntoRustBuffer[DynamicFieldName](c, value)
}

func (c FfiConverterDynamicFieldName) Write(writer io.Writer, value DynamicFieldName) {
		FfiConverterTypeTagINSTANCE.Write(writer, value.TypeTag);
		FfiConverterBytesINSTANCE.Write(writer, value.Bcs);
		FfiConverterOptionalTypeValueINSTANCE.Write(writer, value.Json);
}

type FfiDestroyerDynamicFieldName struct {}

func (_ FfiDestroyerDynamicFieldName) Destroy(value DynamicFieldName) {
	value.Destroy()
}
// The output of a dynamic field query, that includes the name, value, and
// value's json representation.
type DynamicFieldOutput struct {
	// The name of the dynamic field
	Name DynamicFieldName
	// The dynamic field value typename and bcs
	Value *DynamicFieldValue
	// The json representation of the dynamic field value object
	ValueAsJson *Value
}

func (r *DynamicFieldOutput) Destroy() {
		FfiDestroyerDynamicFieldName{}.Destroy(r.Name);
		FfiDestroyerOptionalDynamicFieldValue{}.Destroy(r.Value);
		FfiDestroyerOptionalTypeValue{}.Destroy(r.ValueAsJson);
}

type FfiConverterDynamicFieldOutput struct {}

var FfiConverterDynamicFieldOutputINSTANCE = FfiConverterDynamicFieldOutput{}

func (c FfiConverterDynamicFieldOutput) Lift(rb RustBufferI) DynamicFieldOutput {
	return LiftFromRustBuffer[DynamicFieldOutput](c, rb)
}

func (c FfiConverterDynamicFieldOutput) Read(reader io.Reader) DynamicFieldOutput {
	return DynamicFieldOutput {
			FfiConverterDynamicFieldNameINSTANCE.Read(reader),
			FfiConverterOptionalDynamicFieldValueINSTANCE.Read(reader),
			FfiConverterOptionalTypeValueINSTANCE.Read(reader),
	}
}

func (c FfiConverterDynamicFieldOutput) Lower(value DynamicFieldOutput) C.RustBuffer {
	return LowerIntoRustBuffer[DynamicFieldOutput](c, value)
}

func (c FfiConverterDynamicFieldOutput) Write(writer io.Writer, value DynamicFieldOutput) {
		FfiConverterDynamicFieldNameINSTANCE.Write(writer, value.Name);
		FfiConverterOptionalDynamicFieldValueINSTANCE.Write(writer, value.Value);
		FfiConverterOptionalTypeValueINSTANCE.Write(writer, value.ValueAsJson);
}

type FfiDestroyerDynamicFieldOutput struct {}

func (_ FfiDestroyerDynamicFieldOutput) Destroy(value DynamicFieldOutput) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type DynamicFieldOutputPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []DynamicFieldOutput
}

func (r *DynamicFieldOutputPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceDynamicFieldOutput{}.Destroy(r.Data);
}

type FfiConverterDynamicFieldOutputPage struct {}

var FfiConverterDynamicFieldOutputPageINSTANCE = FfiConverterDynamicFieldOutputPage{}

func (c FfiConverterDynamicFieldOutputPage) Lift(rb RustBufferI) DynamicFieldOutputPage {
	return LiftFromRustBuffer[DynamicFieldOutputPage](c, rb)
}

func (c FfiConverterDynamicFieldOutputPage) Read(reader io.Reader) DynamicFieldOutputPage {
	return DynamicFieldOutputPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceDynamicFieldOutputINSTANCE.Read(reader),
	}
}

func (c FfiConverterDynamicFieldOutputPage) Lower(value DynamicFieldOutputPage) C.RustBuffer {
	return LowerIntoRustBuffer[DynamicFieldOutputPage](c, value)
}

func (c FfiConverterDynamicFieldOutputPage) Write(writer io.Writer, value DynamicFieldOutputPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceDynamicFieldOutputINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerDynamicFieldOutputPage struct {}

func (_ FfiDestroyerDynamicFieldOutputPage) Destroy(value DynamicFieldOutputPage) {
	value.Destroy()
}
// The value part of a dynamic field.
type DynamicFieldValue struct {
	TypeTag *TypeTag
	Bcs []byte
}

func (r *DynamicFieldValue) Destroy() {
		FfiDestroyerTypeTag{}.Destroy(r.TypeTag);
		FfiDestroyerBytes{}.Destroy(r.Bcs);
}

type FfiConverterDynamicFieldValue struct {}

var FfiConverterDynamicFieldValueINSTANCE = FfiConverterDynamicFieldValue{}

func (c FfiConverterDynamicFieldValue) Lift(rb RustBufferI) DynamicFieldValue {
	return LiftFromRustBuffer[DynamicFieldValue](c, rb)
}

func (c FfiConverterDynamicFieldValue) Read(reader io.Reader) DynamicFieldValue {
	return DynamicFieldValue {
			FfiConverterTypeTagINSTANCE.Read(reader),
			FfiConverterBytesINSTANCE.Read(reader),
	}
}

func (c FfiConverterDynamicFieldValue) Lower(value DynamicFieldValue) C.RustBuffer {
	return LowerIntoRustBuffer[DynamicFieldValue](c, value)
}

func (c FfiConverterDynamicFieldValue) Write(writer io.Writer, value DynamicFieldValue) {
		FfiConverterTypeTagINSTANCE.Write(writer, value.TypeTag);
		FfiConverterBytesINSTANCE.Write(writer, value.Bcs);
}

type FfiDestroyerDynamicFieldValue struct {}

func (_ FfiDestroyerDynamicFieldValue) Destroy(value DynamicFieldValue) {
	value.Destroy()
}
// Data which, when included in a [`CheckpointSummary`], signals the end of an
// `Epoch`.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// end-of-epoch-data = (vector validator-committee-member) ; next_epoch_committee
// u64                                 ; next_epoch_protocol_version
// (vector checkpoint-commitment)      ; epoch_commitments
// ```
type EndOfEpochData struct {
	NextEpochCommittee []ValidatorCommitteeMember
	NextEpochProtocolVersion uint64
	EpochCommitments []*CheckpointCommitment
	EpochSupplyChange int64
}

func (r *EndOfEpochData) Destroy() {
		FfiDestroyerSequenceValidatorCommitteeMember{}.Destroy(r.NextEpochCommittee);
		FfiDestroyerUint64{}.Destroy(r.NextEpochProtocolVersion);
		FfiDestroyerSequenceCheckpointCommitment{}.Destroy(r.EpochCommitments);
		FfiDestroyerInt64{}.Destroy(r.EpochSupplyChange);
}

type FfiConverterEndOfEpochData struct {}

var FfiConverterEndOfEpochDataINSTANCE = FfiConverterEndOfEpochData{}

func (c FfiConverterEndOfEpochData) Lift(rb RustBufferI) EndOfEpochData {
	return LiftFromRustBuffer[EndOfEpochData](c, rb)
}

func (c FfiConverterEndOfEpochData) Read(reader io.Reader) EndOfEpochData {
	return EndOfEpochData {
			FfiConverterSequenceValidatorCommitteeMemberINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterSequenceCheckpointCommitmentINSTANCE.Read(reader),
			FfiConverterInt64INSTANCE.Read(reader),
	}
}

func (c FfiConverterEndOfEpochData) Lower(value EndOfEpochData) C.RustBuffer {
	return LowerIntoRustBuffer[EndOfEpochData](c, value)
}

func (c FfiConverterEndOfEpochData) Write(writer io.Writer, value EndOfEpochData) {
		FfiConverterSequenceValidatorCommitteeMemberINSTANCE.Write(writer, value.NextEpochCommittee);
		FfiConverterUint64INSTANCE.Write(writer, value.NextEpochProtocolVersion);
		FfiConverterSequenceCheckpointCommitmentINSTANCE.Write(writer, value.EpochCommitments);
		FfiConverterInt64INSTANCE.Write(writer, value.EpochSupplyChange);
}

type FfiDestroyerEndOfEpochData struct {}

func (_ FfiDestroyerEndOfEpochData) Destroy(value EndOfEpochData) {
	value.Destroy()
}
type Epoch struct {
	// The epoch's id as a sequence number that starts at 0 and is incremented
	// by one at every epoch change.
	EpochId uint64
	// The storage fees paid for transactions executed during the epoch.
	FundInflow *string
	// The storage fee rebates paid to users who deleted the data associated
	// with past transactions.
	FundOutflow *string
	// The storage fund available in this epoch.
	// This fund is used to redistribute storage fees from past transactions
	// to future validators.
	FundSize *string
	// A commitment by the committee at the end of epoch on the contents of the
	// live object set at that time. This can be used to verify state
	// snapshots.
	LiveObjectSetDigest *string
	// The difference between the fund inflow and outflow, representing
	// the net amount of storage fees accumulated in this epoch.
	NetInflow *string
	// The epoch's corresponding protocol configuration, including the feature
	// flags and the configuration options.
	ProtocolConfigs *ProtocolConfigs
	// The minimum gas price that a quorum of validators are guaranteed to sign
	// a transaction for.
	ReferenceGasPrice *string
	// The epoch's starting timestamp.
	StartTimestamp uint64
	// The epoch's ending timestamp. Note that this is available only on epochs
	// that have ended.
	EndTimestamp *uint64
	// The value of the `version` field of `0x5`, the
	// `0x3::iota::IotaSystemState` object.  This version changes whenever
	// the fields contained in the system state object (held in a dynamic
	// field attached to `0x5`) change.
	SystemStateVersion *uint64
	// The total number of checkpoints in this epoch.
	TotalCheckpoints *uint64
	// The total amount of gas fees (in IOTA) that were paid in this epoch.
	TotalGasFees *string
	// The total IOTA rewarded as stake.
	TotalStakeRewards *string
	// The total number of transaction in this epoch.
	TotalTransactions *uint64
	// Validator related properties. For active validators, see
	// `active_validators` API.
	// For epochs other than the current the data provided refer to the start
	// of the epoch.
	ValidatorSet *ValidatorSet
}

func (r *Epoch) Destroy() {
		FfiDestroyerUint64{}.Destroy(r.EpochId);
		FfiDestroyerOptionalString{}.Destroy(r.FundInflow);
		FfiDestroyerOptionalString{}.Destroy(r.FundOutflow);
		FfiDestroyerOptionalString{}.Destroy(r.FundSize);
		FfiDestroyerOptionalString{}.Destroy(r.LiveObjectSetDigest);
		FfiDestroyerOptionalString{}.Destroy(r.NetInflow);
		FfiDestroyerOptionalProtocolConfigs{}.Destroy(r.ProtocolConfigs);
		FfiDestroyerOptionalString{}.Destroy(r.ReferenceGasPrice);
		FfiDestroyerUint64{}.Destroy(r.StartTimestamp);
		FfiDestroyerOptionalUint64{}.Destroy(r.EndTimestamp);
		FfiDestroyerOptionalUint64{}.Destroy(r.SystemStateVersion);
		FfiDestroyerOptionalUint64{}.Destroy(r.TotalCheckpoints);
		FfiDestroyerOptionalString{}.Destroy(r.TotalGasFees);
		FfiDestroyerOptionalString{}.Destroy(r.TotalStakeRewards);
		FfiDestroyerOptionalUint64{}.Destroy(r.TotalTransactions);
		FfiDestroyerOptionalValidatorSet{}.Destroy(r.ValidatorSet);
}

type FfiConverterEpoch struct {}

var FfiConverterEpochINSTANCE = FfiConverterEpoch{}

func (c FfiConverterEpoch) Lift(rb RustBufferI) Epoch {
	return LiftFromRustBuffer[Epoch](c, rb)
}

func (c FfiConverterEpoch) Read(reader io.Reader) Epoch {
	return Epoch {
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalProtocolConfigsINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalValidatorSetINSTANCE.Read(reader),
	}
}

func (c FfiConverterEpoch) Lower(value Epoch) C.RustBuffer {
	return LowerIntoRustBuffer[Epoch](c, value)
}

func (c FfiConverterEpoch) Write(writer io.Writer, value Epoch) {
		FfiConverterUint64INSTANCE.Write(writer, value.EpochId);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.FundInflow);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.FundOutflow);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.FundSize);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.LiveObjectSetDigest);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.NetInflow);
		FfiConverterOptionalProtocolConfigsINSTANCE.Write(writer, value.ProtocolConfigs);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.ReferenceGasPrice);
		FfiConverterUint64INSTANCE.Write(writer, value.StartTimestamp);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.EndTimestamp);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.SystemStateVersion);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.TotalCheckpoints);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.TotalGasFees);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.TotalStakeRewards);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.TotalTransactions);
		FfiConverterOptionalValidatorSetINSTANCE.Write(writer, value.ValidatorSet);
}

type FfiDestroyerEpoch struct {}

func (_ FfiDestroyerEpoch) Destroy(value Epoch) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type EpochPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []Epoch
}

func (r *EpochPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceEpoch{}.Destroy(r.Data);
}

type FfiConverterEpochPage struct {}

var FfiConverterEpochPageINSTANCE = FfiConverterEpochPage{}

func (c FfiConverterEpochPage) Lift(rb RustBufferI) EpochPage {
	return LiftFromRustBuffer[EpochPage](c, rb)
}

func (c FfiConverterEpochPage) Read(reader io.Reader) EpochPage {
	return EpochPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceEpochINSTANCE.Read(reader),
	}
}

func (c FfiConverterEpochPage) Lower(value EpochPage) C.RustBuffer {
	return LowerIntoRustBuffer[EpochPage](c, value)
}

func (c FfiConverterEpochPage) Write(writer io.Writer, value EpochPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceEpochINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerEpochPage struct {}

func (_ FfiDestroyerEpochPage) Destroy(value EpochPage) {
	value.Destroy()
}
// An event
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// event = object-id identifier address struct-tag bytes
// ```
type Event struct {
	// Package id of the top-level function invoked by a MoveCall command which
	// triggered this event to be emitted.
	PackageId *ObjectId
	// Module name of the top-level function invoked by a MoveCall command
	// which triggered this event to be emitted.
	Module string
	// Address of the account that sent the transaction where this event was
	// emitted.
	Sender *Address
	// The type of the event emitted
	Type string
	// BCS serialized bytes of the event
	Contents []byte
	// UTC timestamp in milliseconds since epoch (1/1/1970)
	Timestamp string
	// Structured contents of a Move value
	Data string
	// Representation of a Move value in JSON
	Json string
}

func (r *Event) Destroy() {
		FfiDestroyerObjectId{}.Destroy(r.PackageId);
		FfiDestroyerString{}.Destroy(r.Module);
		FfiDestroyerAddress{}.Destroy(r.Sender);
		FfiDestroyerString{}.Destroy(r.Type);
		FfiDestroyerBytes{}.Destroy(r.Contents);
		FfiDestroyerString{}.Destroy(r.Timestamp);
		FfiDestroyerString{}.Destroy(r.Data);
		FfiDestroyerString{}.Destroy(r.Json);
}

type FfiConverterEvent struct {}

var FfiConverterEventINSTANCE = FfiConverterEvent{}

func (c FfiConverterEvent) Lift(rb RustBufferI) Event {
	return LiftFromRustBuffer[Event](c, rb)
}

func (c FfiConverterEvent) Read(reader io.Reader) Event {
	return Event {
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterAddressINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterBytesINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterEvent) Lower(value Event) C.RustBuffer {
	return LowerIntoRustBuffer[Event](c, value)
}

func (c FfiConverterEvent) Write(writer io.Writer, value Event) {
		FfiConverterObjectIdINSTANCE.Write(writer, value.PackageId);
		FfiConverterStringINSTANCE.Write(writer, value.Module);
		FfiConverterAddressINSTANCE.Write(writer, value.Sender);
		FfiConverterStringINSTANCE.Write(writer, value.Type);
		FfiConverterBytesINSTANCE.Write(writer, value.Contents);
		FfiConverterStringINSTANCE.Write(writer, value.Timestamp);
		FfiConverterStringINSTANCE.Write(writer, value.Data);
		FfiConverterStringINSTANCE.Write(writer, value.Json);
}

type FfiDestroyerEvent struct {}

func (_ FfiDestroyerEvent) Destroy(value Event) {
	value.Destroy()
}
type EventFilter struct {
	EmittingModule *string
	EventType *string
	Sender **Address
	TransactionDigest *string
}

func (r *EventFilter) Destroy() {
		FfiDestroyerOptionalString{}.Destroy(r.EmittingModule);
		FfiDestroyerOptionalString{}.Destroy(r.EventType);
		FfiDestroyerOptionalAddress{}.Destroy(r.Sender);
		FfiDestroyerOptionalString{}.Destroy(r.TransactionDigest);
}

type FfiConverterEventFilter struct {}

var FfiConverterEventFilterINSTANCE = FfiConverterEventFilter{}

func (c FfiConverterEventFilter) Lift(rb RustBufferI) EventFilter {
	return LiftFromRustBuffer[EventFilter](c, rb)
}

func (c FfiConverterEventFilter) Read(reader io.Reader) EventFilter {
	return EventFilter {
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalAddressINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterEventFilter) Lower(value EventFilter) C.RustBuffer {
	return LowerIntoRustBuffer[EventFilter](c, value)
}

func (c FfiConverterEventFilter) Write(writer io.Writer, value EventFilter) {
		FfiConverterOptionalStringINSTANCE.Write(writer, value.EmittingModule);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.EventType);
		FfiConverterOptionalAddressINSTANCE.Write(writer, value.Sender);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.TransactionDigest);
}

type FfiDestroyerEventFilter struct {}

func (_ FfiDestroyerEventFilter) Destroy(value EventFilter) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type EventPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []Event
}

func (r *EventPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceEvent{}.Destroy(r.Data);
}

type FfiConverterEventPage struct {}

var FfiConverterEventPageINSTANCE = FfiConverterEventPage{}

func (c FfiConverterEventPage) Lift(rb RustBufferI) EventPage {
	return LiftFromRustBuffer[EventPage](c, rb)
}

func (c FfiConverterEventPage) Read(reader io.Reader) EventPage {
	return EventPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceEventINSTANCE.Read(reader),
	}
}

func (c FfiConverterEventPage) Lower(value EventPage) C.RustBuffer {
	return LowerIntoRustBuffer[EventPage](c, value)
}

func (c FfiConverterEventPage) Write(writer io.Writer, value EventPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceEventINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerEventPage struct {}

func (_ FfiDestroyerEventPage) Destroy(value EventPage) {
	value.Destroy()
}
type FaucetReceipt struct {
	Sent []CoinInfo
}

func (r *FaucetReceipt) Destroy() {
		FfiDestroyerSequenceCoinInfo{}.Destroy(r.Sent);
}

type FfiConverterFaucetReceipt struct {}

var FfiConverterFaucetReceiptINSTANCE = FfiConverterFaucetReceipt{}

func (c FfiConverterFaucetReceipt) Lift(rb RustBufferI) FaucetReceipt {
	return LiftFromRustBuffer[FaucetReceipt](c, rb)
}

func (c FfiConverterFaucetReceipt) Read(reader io.Reader) FaucetReceipt {
	return FaucetReceipt {
			FfiConverterSequenceCoinInfoINSTANCE.Read(reader),
	}
}

func (c FfiConverterFaucetReceipt) Lower(value FaucetReceipt) C.RustBuffer {
	return LowerIntoRustBuffer[FaucetReceipt](c, value)
}

func (c FfiConverterFaucetReceipt) Write(writer io.Writer, value FaucetReceipt) {
		FfiConverterSequenceCoinInfoINSTANCE.Write(writer, value.Sent);
}

type FfiDestroyerFaucetReceipt struct {}

func (_ FfiDestroyerFaucetReceipt) Destroy(value FaucetReceipt) {
	value.Destroy()
}
type GqlAddress struct {
	Address *Address
}

func (r *GqlAddress) Destroy() {
		FfiDestroyerAddress{}.Destroy(r.Address);
}

type FfiConverterGqlAddress struct {}

var FfiConverterGqlAddressINSTANCE = FfiConverterGqlAddress{}

func (c FfiConverterGqlAddress) Lift(rb RustBufferI) GqlAddress {
	return LiftFromRustBuffer[GqlAddress](c, rb)
}

func (c FfiConverterGqlAddress) Read(reader io.Reader) GqlAddress {
	return GqlAddress {
			FfiConverterAddressINSTANCE.Read(reader),
	}
}

func (c FfiConverterGqlAddress) Lower(value GqlAddress) C.RustBuffer {
	return LowerIntoRustBuffer[GqlAddress](c, value)
}

func (c FfiConverterGqlAddress) Write(writer io.Writer, value GqlAddress) {
		FfiConverterAddressINSTANCE.Write(writer, value.Address);
}

type FfiDestroyerGqlAddress struct {}

func (_ FfiDestroyerGqlAddress) Destroy(value GqlAddress) {
	value.Destroy()
}
// Summary of gas charges.
//
// Storage is charged independently of computation.
// There are 3 parts to the storage charges:
// `storage_cost`: it is the charge of storage at the time the transaction is
// executed.                 The cost of storage is the number of bytes of the
// objects being mutated                 multiplied by a variable storage cost
// per byte `storage_rebate`: this is the amount a user gets back when
// manipulating an object.                   The `storage_rebate` is the
// `storage_cost` for an object minus fees. `non_refundable_storage_fee`: not
// all the value of the object storage cost is
// given back to user and there is a small fraction that
// is kept by the system. This value tracks that charge.
//
// When looking at a gas cost summary the amount charged to the user is
// `computation_cost + storage_cost - storage_rebate`
// and that is the amount that is deducted from the gas coins.
// `non_refundable_storage_fee` is collected from the objects being
// mutated/deleted and it is tracked by the system in storage funds.
//
// Objects deleted, including the older versions of objects mutated, have the
// storage field on the objects added up to a pool of "potential rebate". This
// rebate then is reduced by the "nonrefundable rate" such that:
// `potential_rebate(storage cost of deleted/mutated objects) =
// storage_rebate + non_refundable_storage_fee`
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// gas-cost-summary = u64 ; computation-cost
// u64 ; storage-cost
// u64 ; storage-rebate
// u64 ; non-refundable-storage-fee
// ```
type GasCostSummary struct {
	// Cost of computation/execution
	ComputationCost uint64
	// The burned component of the computation/execution costs
	ComputationCostBurned uint64
	// Storage cost, it's the sum of all storage cost for all objects created
	// or mutated.
	StorageCost uint64
	// The amount of storage cost refunded to the user for all objects deleted
	// or mutated in the transaction.
	StorageRebate uint64
	// The fee for the rebate. The portion of the storage rebate kept by the
	// system.
	NonRefundableStorageFee uint64
}

func (r *GasCostSummary) Destroy() {
		FfiDestroyerUint64{}.Destroy(r.ComputationCost);
		FfiDestroyerUint64{}.Destroy(r.ComputationCostBurned);
		FfiDestroyerUint64{}.Destroy(r.StorageCost);
		FfiDestroyerUint64{}.Destroy(r.StorageRebate);
		FfiDestroyerUint64{}.Destroy(r.NonRefundableStorageFee);
}

type FfiConverterGasCostSummary struct {}

var FfiConverterGasCostSummaryINSTANCE = FfiConverterGasCostSummary{}

func (c FfiConverterGasCostSummary) Lift(rb RustBufferI) GasCostSummary {
	return LiftFromRustBuffer[GasCostSummary](c, rb)
}

func (c FfiConverterGasCostSummary) Read(reader io.Reader) GasCostSummary {
	return GasCostSummary {
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterGasCostSummary) Lower(value GasCostSummary) C.RustBuffer {
	return LowerIntoRustBuffer[GasCostSummary](c, value)
}

func (c FfiConverterGasCostSummary) Write(writer io.Writer, value GasCostSummary) {
		FfiConverterUint64INSTANCE.Write(writer, value.ComputationCost);
		FfiConverterUint64INSTANCE.Write(writer, value.ComputationCostBurned);
		FfiConverterUint64INSTANCE.Write(writer, value.StorageCost);
		FfiConverterUint64INSTANCE.Write(writer, value.StorageRebate);
		FfiConverterUint64INSTANCE.Write(writer, value.NonRefundableStorageFee);
}

type FfiDestroyerGasCostSummary struct {}

func (_ FfiDestroyerGasCostSummary) Destroy(value GasCostSummary) {
	value.Destroy()
}
// Payment information for executing a transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// gas-payment = (vector object-ref) ; gas coin objects
// address             ; owner
// u64                 ; price
// u64                 ; budget
// ```
type GasPayment struct {
	Objects []ObjectReference
	// Owner of the gas objects, either the transaction sender or a sponsor
	Owner *Address
	// Gas unit price to use when charging for computation
	//
	// Must be greater-than-or-equal-to the network's current RGP (reference
	// gas price)
	Price uint64
	// Total budget willing to spend for the execution of a transaction
	Budget uint64
}

func (r *GasPayment) Destroy() {
		FfiDestroyerSequenceObjectReference{}.Destroy(r.Objects);
		FfiDestroyerAddress{}.Destroy(r.Owner);
		FfiDestroyerUint64{}.Destroy(r.Price);
		FfiDestroyerUint64{}.Destroy(r.Budget);
}

type FfiConverterGasPayment struct {}

var FfiConverterGasPaymentINSTANCE = FfiConverterGasPayment{}

func (c FfiConverterGasPayment) Lift(rb RustBufferI) GasPayment {
	return LiftFromRustBuffer[GasPayment](c, rb)
}

func (c FfiConverterGasPayment) Read(reader io.Reader) GasPayment {
	return GasPayment {
			FfiConverterSequenceObjectReferenceINSTANCE.Read(reader),
			FfiConverterAddressINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterGasPayment) Lower(value GasPayment) C.RustBuffer {
	return LowerIntoRustBuffer[GasPayment](c, value)
}

func (c FfiConverterGasPayment) Write(writer io.Writer, value GasPayment) {
		FfiConverterSequenceObjectReferenceINSTANCE.Write(writer, value.Objects);
		FfiConverterAddressINSTANCE.Write(writer, value.Owner);
		FfiConverterUint64INSTANCE.Write(writer, value.Price);
		FfiConverterUint64INSTANCE.Write(writer, value.Budget);
}

type FfiDestroyerGasPayment struct {}

func (_ FfiDestroyerGasPayment) Destroy(value GasPayment) {
	value.Destroy()
}
// A JSON Web Key
//
// Struct that contains info for a JWK. A list of them for different kids can
// be retrieved from the JWK endpoint (e.g. <https://www.googleapis.com/oauth2/v3/certs>).
// The JWK is used to verify the JWT token.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// jwk = string string string string
// ```
type Jwk struct {
	// Key type parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.1>
	Kty string
	// RSA public exponent, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3>
	E string
	// RSA modulus, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3>
	N string
	// Algorithm parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.4>
	Alg string
}

func (r *Jwk) Destroy() {
		FfiDestroyerString{}.Destroy(r.Kty);
		FfiDestroyerString{}.Destroy(r.E);
		FfiDestroyerString{}.Destroy(r.N);
		FfiDestroyerString{}.Destroy(r.Alg);
}

type FfiConverterJwk struct {}

var FfiConverterJwkINSTANCE = FfiConverterJwk{}

func (c FfiConverterJwk) Lift(rb RustBufferI) Jwk {
	return LiftFromRustBuffer[Jwk](c, rb)
}

func (c FfiConverterJwk) Read(reader io.Reader) Jwk {
	return Jwk {
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterJwk) Lower(value Jwk) C.RustBuffer {
	return LowerIntoRustBuffer[Jwk](c, value)
}

func (c FfiConverterJwk) Write(writer io.Writer, value Jwk) {
		FfiConverterStringINSTANCE.Write(writer, value.Kty);
		FfiConverterStringINSTANCE.Write(writer, value.E);
		FfiConverterStringINSTANCE.Write(writer, value.N);
		FfiConverterStringINSTANCE.Write(writer, value.Alg);
}

type FfiDestroyerJwk struct {}

func (_ FfiDestroyerJwk) Destroy(value Jwk) {
	value.Destroy()
}
// Key to uniquely identify a JWK
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// jwk-id = string string
// ```
type JwkId struct {
	// The issuer or identity of the OIDC provider.
	Iss string
	// A key id use to uniquely identify a key from an OIDC provider.
	Kid string
}

func (r *JwkId) Destroy() {
		FfiDestroyerString{}.Destroy(r.Iss);
		FfiDestroyerString{}.Destroy(r.Kid);
}

type FfiConverterJwkId struct {}

var FfiConverterJwkIdINSTANCE = FfiConverterJwkId{}

func (c FfiConverterJwkId) Lift(rb RustBufferI) JwkId {
	return LiftFromRustBuffer[JwkId](c, rb)
}

func (c FfiConverterJwkId) Read(reader io.Reader) JwkId {
	return JwkId {
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterJwkId) Lower(value JwkId) C.RustBuffer {
	return LowerIntoRustBuffer[JwkId](c, value)
}

func (c FfiConverterJwkId) Write(writer io.Writer, value JwkId) {
		FfiConverterStringINSTANCE.Write(writer, value.Iss);
		FfiConverterStringINSTANCE.Write(writer, value.Kid);
}

type FfiDestroyerJwkId struct {}

func (_ FfiDestroyerJwkId) Destroy(value JwkId) {
	value.Destroy()
}
type MoveEnum struct {
	Abilities *[]MoveAbility
	Name string
	TypeParameters *[]MoveStructTypeParameter
	Variants *[]MoveEnumVariant
}

func (r *MoveEnum) Destroy() {
		FfiDestroyerOptionalSequenceMoveAbility{}.Destroy(r.Abilities);
		FfiDestroyerString{}.Destroy(r.Name);
		FfiDestroyerOptionalSequenceMoveStructTypeParameter{}.Destroy(r.TypeParameters);
		FfiDestroyerOptionalSequenceMoveEnumVariant{}.Destroy(r.Variants);
}

type FfiConverterMoveEnum struct {}

var FfiConverterMoveEnumINSTANCE = FfiConverterMoveEnum{}

func (c FfiConverterMoveEnum) Lift(rb RustBufferI) MoveEnum {
	return LiftFromRustBuffer[MoveEnum](c, rb)
}

func (c FfiConverterMoveEnum) Read(reader io.Reader) MoveEnum {
	return MoveEnum {
			FfiConverterOptionalSequenceMoveAbilityINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterOptionalSequenceMoveStructTypeParameterINSTANCE.Read(reader),
			FfiConverterOptionalSequenceMoveEnumVariantINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveEnum) Lower(value MoveEnum) C.RustBuffer {
	return LowerIntoRustBuffer[MoveEnum](c, value)
}

func (c FfiConverterMoveEnum) Write(writer io.Writer, value MoveEnum) {
		FfiConverterOptionalSequenceMoveAbilityINSTANCE.Write(writer, value.Abilities);
		FfiConverterStringINSTANCE.Write(writer, value.Name);
		FfiConverterOptionalSequenceMoveStructTypeParameterINSTANCE.Write(writer, value.TypeParameters);
		FfiConverterOptionalSequenceMoveEnumVariantINSTANCE.Write(writer, value.Variants);
}

type FfiDestroyerMoveEnum struct {}

func (_ FfiDestroyerMoveEnum) Destroy(value MoveEnum) {
	value.Destroy()
}
type MoveEnumConnection struct {
	Nodes []MoveEnum
	PageInfo PageInfo
}

func (r *MoveEnumConnection) Destroy() {
		FfiDestroyerSequenceMoveEnum{}.Destroy(r.Nodes);
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
}

type FfiConverterMoveEnumConnection struct {}

var FfiConverterMoveEnumConnectionINSTANCE = FfiConverterMoveEnumConnection{}

func (c FfiConverterMoveEnumConnection) Lift(rb RustBufferI) MoveEnumConnection {
	return LiftFromRustBuffer[MoveEnumConnection](c, rb)
}

func (c FfiConverterMoveEnumConnection) Read(reader io.Reader) MoveEnumConnection {
	return MoveEnumConnection {
			FfiConverterSequenceMoveEnumINSTANCE.Read(reader),
			FfiConverterPageInfoINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveEnumConnection) Lower(value MoveEnumConnection) C.RustBuffer {
	return LowerIntoRustBuffer[MoveEnumConnection](c, value)
}

func (c FfiConverterMoveEnumConnection) Write(writer io.Writer, value MoveEnumConnection) {
		FfiConverterSequenceMoveEnumINSTANCE.Write(writer, value.Nodes);
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
}

type FfiDestroyerMoveEnumConnection struct {}

func (_ FfiDestroyerMoveEnumConnection) Destroy(value MoveEnumConnection) {
	value.Destroy()
}
type MoveEnumVariant struct {
	Fields *[]MoveField
	Name string
}

func (r *MoveEnumVariant) Destroy() {
		FfiDestroyerOptionalSequenceMoveField{}.Destroy(r.Fields);
		FfiDestroyerString{}.Destroy(r.Name);
}

type FfiConverterMoveEnumVariant struct {}

var FfiConverterMoveEnumVariantINSTANCE = FfiConverterMoveEnumVariant{}

func (c FfiConverterMoveEnumVariant) Lift(rb RustBufferI) MoveEnumVariant {
	return LiftFromRustBuffer[MoveEnumVariant](c, rb)
}

func (c FfiConverterMoveEnumVariant) Read(reader io.Reader) MoveEnumVariant {
	return MoveEnumVariant {
			FfiConverterOptionalSequenceMoveFieldINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveEnumVariant) Lower(value MoveEnumVariant) C.RustBuffer {
	return LowerIntoRustBuffer[MoveEnumVariant](c, value)
}

func (c FfiConverterMoveEnumVariant) Write(writer io.Writer, value MoveEnumVariant) {
		FfiConverterOptionalSequenceMoveFieldINSTANCE.Write(writer, value.Fields);
		FfiConverterStringINSTANCE.Write(writer, value.Name);
}

type FfiDestroyerMoveEnumVariant struct {}

func (_ FfiDestroyerMoveEnumVariant) Destroy(value MoveEnumVariant) {
	value.Destroy()
}
type MoveField struct {
	Name string
	Type *OpenMoveType
}

func (r *MoveField) Destroy() {
		FfiDestroyerString{}.Destroy(r.Name);
		FfiDestroyerOptionalOpenMoveType{}.Destroy(r.Type);
}

type FfiConverterMoveField struct {}

var FfiConverterMoveFieldINSTANCE = FfiConverterMoveField{}

func (c FfiConverterMoveField) Lift(rb RustBufferI) MoveField {
	return LiftFromRustBuffer[MoveField](c, rb)
}

func (c FfiConverterMoveField) Read(reader io.Reader) MoveField {
	return MoveField {
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterOptionalOpenMoveTypeINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveField) Lower(value MoveField) C.RustBuffer {
	return LowerIntoRustBuffer[MoveField](c, value)
}

func (c FfiConverterMoveField) Write(writer io.Writer, value MoveField) {
		FfiConverterStringINSTANCE.Write(writer, value.Name);
		FfiConverterOptionalOpenMoveTypeINSTANCE.Write(writer, value.Type);
}

type FfiDestroyerMoveField struct {}

func (_ FfiDestroyerMoveField) Destroy(value MoveField) {
	value.Destroy()
}
type MoveFunctionConnection struct {
	Nodes []*MoveFunction
	PageInfo PageInfo
}

func (r *MoveFunctionConnection) Destroy() {
		FfiDestroyerSequenceMoveFunction{}.Destroy(r.Nodes);
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
}

type FfiConverterMoveFunctionConnection struct {}

var FfiConverterMoveFunctionConnectionINSTANCE = FfiConverterMoveFunctionConnection{}

func (c FfiConverterMoveFunctionConnection) Lift(rb RustBufferI) MoveFunctionConnection {
	return LiftFromRustBuffer[MoveFunctionConnection](c, rb)
}

func (c FfiConverterMoveFunctionConnection) Read(reader io.Reader) MoveFunctionConnection {
	return MoveFunctionConnection {
			FfiConverterSequenceMoveFunctionINSTANCE.Read(reader),
			FfiConverterPageInfoINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveFunctionConnection) Lower(value MoveFunctionConnection) C.RustBuffer {
	return LowerIntoRustBuffer[MoveFunctionConnection](c, value)
}

func (c FfiConverterMoveFunctionConnection) Write(writer io.Writer, value MoveFunctionConnection) {
		FfiConverterSequenceMoveFunctionINSTANCE.Write(writer, value.Nodes);
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
}

type FfiDestroyerMoveFunctionConnection struct {}

func (_ FfiDestroyerMoveFunctionConnection) Destroy(value MoveFunctionConnection) {
	value.Destroy()
}
type MoveFunctionTypeParameter struct {
	Constraints []MoveAbility
}

func (r *MoveFunctionTypeParameter) Destroy() {
		FfiDestroyerSequenceMoveAbility{}.Destroy(r.Constraints);
}

type FfiConverterMoveFunctionTypeParameter struct {}

var FfiConverterMoveFunctionTypeParameterINSTANCE = FfiConverterMoveFunctionTypeParameter{}

func (c FfiConverterMoveFunctionTypeParameter) Lift(rb RustBufferI) MoveFunctionTypeParameter {
	return LiftFromRustBuffer[MoveFunctionTypeParameter](c, rb)
}

func (c FfiConverterMoveFunctionTypeParameter) Read(reader io.Reader) MoveFunctionTypeParameter {
	return MoveFunctionTypeParameter {
			FfiConverterSequenceMoveAbilityINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveFunctionTypeParameter) Lower(value MoveFunctionTypeParameter) C.RustBuffer {
	return LowerIntoRustBuffer[MoveFunctionTypeParameter](c, value)
}

func (c FfiConverterMoveFunctionTypeParameter) Write(writer io.Writer, value MoveFunctionTypeParameter) {
		FfiConverterSequenceMoveAbilityINSTANCE.Write(writer, value.Constraints);
}

type FfiDestroyerMoveFunctionTypeParameter struct {}

func (_ FfiDestroyerMoveFunctionTypeParameter) Destroy(value MoveFunctionTypeParameter) {
	value.Destroy()
}
// Location in move bytecode where an error occurred
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// move-location = object-id identifier u16 u16 (option identifier)
// ```
type MoveLocation struct {
	// The package id
	Package *ObjectId
	// The module name
	Module string
	// The function index
	Function uint16
	// Index into the code stream for a jump. The offset is relative to the
	// beginning of the instruction stream.
	Instruction uint16
	// The name of the function if available
	FunctionName *string
}

func (r *MoveLocation) Destroy() {
		FfiDestroyerObjectId{}.Destroy(r.Package);
		FfiDestroyerString{}.Destroy(r.Module);
		FfiDestroyerUint16{}.Destroy(r.Function);
		FfiDestroyerUint16{}.Destroy(r.Instruction);
		FfiDestroyerOptionalString{}.Destroy(r.FunctionName);
}

type FfiConverterMoveLocation struct {}

var FfiConverterMoveLocationINSTANCE = FfiConverterMoveLocation{}

func (c FfiConverterMoveLocation) Lift(rb RustBufferI) MoveLocation {
	return LiftFromRustBuffer[MoveLocation](c, rb)
}

func (c FfiConverterMoveLocation) Read(reader io.Reader) MoveLocation {
	return MoveLocation {
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterUint16INSTANCE.Read(reader),
			FfiConverterUint16INSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveLocation) Lower(value MoveLocation) C.RustBuffer {
	return LowerIntoRustBuffer[MoveLocation](c, value)
}

func (c FfiConverterMoveLocation) Write(writer io.Writer, value MoveLocation) {
		FfiConverterObjectIdINSTANCE.Write(writer, value.Package);
		FfiConverterStringINSTANCE.Write(writer, value.Module);
		FfiConverterUint16INSTANCE.Write(writer, value.Function);
		FfiConverterUint16INSTANCE.Write(writer, value.Instruction);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.FunctionName);
}

type FfiDestroyerMoveLocation struct {}

func (_ FfiDestroyerMoveLocation) Destroy(value MoveLocation) {
	value.Destroy()
}
type MoveModule struct {
	FileFormatVersion int32
	Enums *MoveEnumConnection
	Friends MoveModuleConnection
	Functions *MoveFunctionConnection
	Structs *MoveStructConnection
}

func (r *MoveModule) Destroy() {
		FfiDestroyerInt32{}.Destroy(r.FileFormatVersion);
		FfiDestroyerOptionalMoveEnumConnection{}.Destroy(r.Enums);
		FfiDestroyerMoveModuleConnection{}.Destroy(r.Friends);
		FfiDestroyerOptionalMoveFunctionConnection{}.Destroy(r.Functions);
		FfiDestroyerOptionalMoveStructConnection{}.Destroy(r.Structs);
}

type FfiConverterMoveModule struct {}

var FfiConverterMoveModuleINSTANCE = FfiConverterMoveModule{}

func (c FfiConverterMoveModule) Lift(rb RustBufferI) MoveModule {
	return LiftFromRustBuffer[MoveModule](c, rb)
}

func (c FfiConverterMoveModule) Read(reader io.Reader) MoveModule {
	return MoveModule {
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterOptionalMoveEnumConnectionINSTANCE.Read(reader),
			FfiConverterMoveModuleConnectionINSTANCE.Read(reader),
			FfiConverterOptionalMoveFunctionConnectionINSTANCE.Read(reader),
			FfiConverterOptionalMoveStructConnectionINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveModule) Lower(value MoveModule) C.RustBuffer {
	return LowerIntoRustBuffer[MoveModule](c, value)
}

func (c FfiConverterMoveModule) Write(writer io.Writer, value MoveModule) {
		FfiConverterInt32INSTANCE.Write(writer, value.FileFormatVersion);
		FfiConverterOptionalMoveEnumConnectionINSTANCE.Write(writer, value.Enums);
		FfiConverterMoveModuleConnectionINSTANCE.Write(writer, value.Friends);
		FfiConverterOptionalMoveFunctionConnectionINSTANCE.Write(writer, value.Functions);
		FfiConverterOptionalMoveStructConnectionINSTANCE.Write(writer, value.Structs);
}

type FfiDestroyerMoveModule struct {}

func (_ FfiDestroyerMoveModule) Destroy(value MoveModule) {
	value.Destroy()
}
type MoveModuleConnection struct {
	Nodes []MoveModuleQuery
	PageInfo PageInfo
}

func (r *MoveModuleConnection) Destroy() {
		FfiDestroyerSequenceMoveModuleQuery{}.Destroy(r.Nodes);
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
}

type FfiConverterMoveModuleConnection struct {}

var FfiConverterMoveModuleConnectionINSTANCE = FfiConverterMoveModuleConnection{}

func (c FfiConverterMoveModuleConnection) Lift(rb RustBufferI) MoveModuleConnection {
	return LiftFromRustBuffer[MoveModuleConnection](c, rb)
}

func (c FfiConverterMoveModuleConnection) Read(reader io.Reader) MoveModuleConnection {
	return MoveModuleConnection {
			FfiConverterSequenceMoveModuleQueryINSTANCE.Read(reader),
			FfiConverterPageInfoINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveModuleConnection) Lower(value MoveModuleConnection) C.RustBuffer {
	return LowerIntoRustBuffer[MoveModuleConnection](c, value)
}

func (c FfiConverterMoveModuleConnection) Write(writer io.Writer, value MoveModuleConnection) {
		FfiConverterSequenceMoveModuleQueryINSTANCE.Write(writer, value.Nodes);
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
}

type FfiDestroyerMoveModuleConnection struct {}

func (_ FfiDestroyerMoveModuleConnection) Destroy(value MoveModuleConnection) {
	value.Destroy()
}
type MoveModuleQuery struct {
	Package MovePackageQuery
	Name string
}

func (r *MoveModuleQuery) Destroy() {
		FfiDestroyerMovePackageQuery{}.Destroy(r.Package);
		FfiDestroyerString{}.Destroy(r.Name);
}

type FfiConverterMoveModuleQuery struct {}

var FfiConverterMoveModuleQueryINSTANCE = FfiConverterMoveModuleQuery{}

func (c FfiConverterMoveModuleQuery) Lift(rb RustBufferI) MoveModuleQuery {
	return LiftFromRustBuffer[MoveModuleQuery](c, rb)
}

func (c FfiConverterMoveModuleQuery) Read(reader io.Reader) MoveModuleQuery {
	return MoveModuleQuery {
			FfiConverterMovePackageQueryINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveModuleQuery) Lower(value MoveModuleQuery) C.RustBuffer {
	return LowerIntoRustBuffer[MoveModuleQuery](c, value)
}

func (c FfiConverterMoveModuleQuery) Write(writer io.Writer, value MoveModuleQuery) {
		FfiConverterMovePackageQueryINSTANCE.Write(writer, value.Package);
		FfiConverterStringINSTANCE.Write(writer, value.Name);
}

type FfiDestroyerMoveModuleQuery struct {}

func (_ FfiDestroyerMoveModuleQuery) Destroy(value MoveModuleQuery) {
	value.Destroy()
}
type MoveObject struct {
	Bcs *Base64
}

func (r *MoveObject) Destroy() {
		FfiDestroyerOptionalTypeBase64{}.Destroy(r.Bcs);
}

type FfiConverterMoveObject struct {}

var FfiConverterMoveObjectINSTANCE = FfiConverterMoveObject{}

func (c FfiConverterMoveObject) Lift(rb RustBufferI) MoveObject {
	return LiftFromRustBuffer[MoveObject](c, rb)
}

func (c FfiConverterMoveObject) Read(reader io.Reader) MoveObject {
	return MoveObject {
			FfiConverterOptionalTypeBase64INSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveObject) Lower(value MoveObject) C.RustBuffer {
	return LowerIntoRustBuffer[MoveObject](c, value)
}

func (c FfiConverterMoveObject) Write(writer io.Writer, value MoveObject) {
		FfiConverterOptionalTypeBase64INSTANCE.Write(writer, value.Bcs);
}

type FfiDestroyerMoveObject struct {}

func (_ FfiDestroyerMoveObject) Destroy(value MoveObject) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type MovePackagePage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []*MovePackage
}

func (r *MovePackagePage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceMovePackage{}.Destroy(r.Data);
}

type FfiConverterMovePackagePage struct {}

var FfiConverterMovePackagePageINSTANCE = FfiConverterMovePackagePage{}

func (c FfiConverterMovePackagePage) Lift(rb RustBufferI) MovePackagePage {
	return LiftFromRustBuffer[MovePackagePage](c, rb)
}

func (c FfiConverterMovePackagePage) Read(reader io.Reader) MovePackagePage {
	return MovePackagePage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceMovePackageINSTANCE.Read(reader),
	}
}

func (c FfiConverterMovePackagePage) Lower(value MovePackagePage) C.RustBuffer {
	return LowerIntoRustBuffer[MovePackagePage](c, value)
}

func (c FfiConverterMovePackagePage) Write(writer io.Writer, value MovePackagePage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceMovePackageINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerMovePackagePage struct {}

func (_ FfiDestroyerMovePackagePage) Destroy(value MovePackagePage) {
	value.Destroy()
}
type MovePackageQuery struct {
	Address *Address
	Bcs *Base64
}

func (r *MovePackageQuery) Destroy() {
		FfiDestroyerAddress{}.Destroy(r.Address);
		FfiDestroyerOptionalTypeBase64{}.Destroy(r.Bcs);
}

type FfiConverterMovePackageQuery struct {}

var FfiConverterMovePackageQueryINSTANCE = FfiConverterMovePackageQuery{}

func (c FfiConverterMovePackageQuery) Lift(rb RustBufferI) MovePackageQuery {
	return LiftFromRustBuffer[MovePackageQuery](c, rb)
}

func (c FfiConverterMovePackageQuery) Read(reader io.Reader) MovePackageQuery {
	return MovePackageQuery {
			FfiConverterAddressINSTANCE.Read(reader),
			FfiConverterOptionalTypeBase64INSTANCE.Read(reader),
	}
}

func (c FfiConverterMovePackageQuery) Lower(value MovePackageQuery) C.RustBuffer {
	return LowerIntoRustBuffer[MovePackageQuery](c, value)
}

func (c FfiConverterMovePackageQuery) Write(writer io.Writer, value MovePackageQuery) {
		FfiConverterAddressINSTANCE.Write(writer, value.Address);
		FfiConverterOptionalTypeBase64INSTANCE.Write(writer, value.Bcs);
}

type FfiDestroyerMovePackageQuery struct {}

func (_ FfiDestroyerMovePackageQuery) Destroy(value MovePackageQuery) {
	value.Destroy()
}
// A move struct
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object-move-struct = compressed-struct-tag bool u64 object-contents
//
// compressed-struct-tag = other-struct-type / gas-coin-type / staked-iota-type / coin-type
// other-struct-type     = %x00 struct-tag
// gas-coin-type         = %x01
// staked-iota-type      = %x02
// coin-type             = %x03 type-tag
//
// ; first 32 bytes of the contents are the object's object-id
// object-contents = uleb128 (object-id *OCTET) ; length followed by contents
// ```
type MoveStruct struct {
	// The type of this object
	StructType *StructTag
	// Number that increases each time a tx takes this object as a mutable
	// input This is a lamport timestamp, not a sequentially increasing
	// version
	Version uint64
	// BCS bytes of a Move struct value
	Contents []byte
}

func (r *MoveStruct) Destroy() {
		FfiDestroyerStructTag{}.Destroy(r.StructType);
		FfiDestroyerUint64{}.Destroy(r.Version);
		FfiDestroyerBytes{}.Destroy(r.Contents);
}

type FfiConverterMoveStruct struct {}

var FfiConverterMoveStructINSTANCE = FfiConverterMoveStruct{}

func (c FfiConverterMoveStruct) Lift(rb RustBufferI) MoveStruct {
	return LiftFromRustBuffer[MoveStruct](c, rb)
}

func (c FfiConverterMoveStruct) Read(reader io.Reader) MoveStruct {
	return MoveStruct {
			FfiConverterStructTagINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterBytesINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveStruct) Lower(value MoveStruct) C.RustBuffer {
	return LowerIntoRustBuffer[MoveStruct](c, value)
}

func (c FfiConverterMoveStruct) Write(writer io.Writer, value MoveStruct) {
		FfiConverterStructTagINSTANCE.Write(writer, value.StructType);
		FfiConverterUint64INSTANCE.Write(writer, value.Version);
		FfiConverterBytesINSTANCE.Write(writer, value.Contents);
}

type FfiDestroyerMoveStruct struct {}

func (_ FfiDestroyerMoveStruct) Destroy(value MoveStruct) {
	value.Destroy()
}
type MoveStructConnection struct {
	PageInfo PageInfo
	Nodes []MoveStructQuery
}

func (r *MoveStructConnection) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceMoveStructQuery{}.Destroy(r.Nodes);
}

type FfiConverterMoveStructConnection struct {}

var FfiConverterMoveStructConnectionINSTANCE = FfiConverterMoveStructConnection{}

func (c FfiConverterMoveStructConnection) Lift(rb RustBufferI) MoveStructConnection {
	return LiftFromRustBuffer[MoveStructConnection](c, rb)
}

func (c FfiConverterMoveStructConnection) Read(reader io.Reader) MoveStructConnection {
	return MoveStructConnection {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceMoveStructQueryINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveStructConnection) Lower(value MoveStructConnection) C.RustBuffer {
	return LowerIntoRustBuffer[MoveStructConnection](c, value)
}

func (c FfiConverterMoveStructConnection) Write(writer io.Writer, value MoveStructConnection) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceMoveStructQueryINSTANCE.Write(writer, value.Nodes);
}

type FfiDestroyerMoveStructConnection struct {}

func (_ FfiDestroyerMoveStructConnection) Destroy(value MoveStructConnection) {
	value.Destroy()
}
type MoveStructQuery struct {
	Abilities *[]MoveAbility
	Name string
	Fields *[]MoveField
	TypeParameters *[]MoveStructTypeParameter
}

func (r *MoveStructQuery) Destroy() {
		FfiDestroyerOptionalSequenceMoveAbility{}.Destroy(r.Abilities);
		FfiDestroyerString{}.Destroy(r.Name);
		FfiDestroyerOptionalSequenceMoveField{}.Destroy(r.Fields);
		FfiDestroyerOptionalSequenceMoveStructTypeParameter{}.Destroy(r.TypeParameters);
}

type FfiConverterMoveStructQuery struct {}

var FfiConverterMoveStructQueryINSTANCE = FfiConverterMoveStructQuery{}

func (c FfiConverterMoveStructQuery) Lift(rb RustBufferI) MoveStructQuery {
	return LiftFromRustBuffer[MoveStructQuery](c, rb)
}

func (c FfiConverterMoveStructQuery) Read(reader io.Reader) MoveStructQuery {
	return MoveStructQuery {
			FfiConverterOptionalSequenceMoveAbilityINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterOptionalSequenceMoveFieldINSTANCE.Read(reader),
			FfiConverterOptionalSequenceMoveStructTypeParameterINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveStructQuery) Lower(value MoveStructQuery) C.RustBuffer {
	return LowerIntoRustBuffer[MoveStructQuery](c, value)
}

func (c FfiConverterMoveStructQuery) Write(writer io.Writer, value MoveStructQuery) {
		FfiConverterOptionalSequenceMoveAbilityINSTANCE.Write(writer, value.Abilities);
		FfiConverterStringINSTANCE.Write(writer, value.Name);
		FfiConverterOptionalSequenceMoveFieldINSTANCE.Write(writer, value.Fields);
		FfiConverterOptionalSequenceMoveStructTypeParameterINSTANCE.Write(writer, value.TypeParameters);
}

type FfiDestroyerMoveStructQuery struct {}

func (_ FfiDestroyerMoveStructQuery) Destroy(value MoveStructQuery) {
	value.Destroy()
}
type MoveStructTypeParameter struct {
	Constraints []MoveAbility
	IsPhantom bool
}

func (r *MoveStructTypeParameter) Destroy() {
		FfiDestroyerSequenceMoveAbility{}.Destroy(r.Constraints);
		FfiDestroyerBool{}.Destroy(r.IsPhantom);
}

type FfiConverterMoveStructTypeParameter struct {}

var FfiConverterMoveStructTypeParameterINSTANCE = FfiConverterMoveStructTypeParameter{}

func (c FfiConverterMoveStructTypeParameter) Lift(rb RustBufferI) MoveStructTypeParameter {
	return LiftFromRustBuffer[MoveStructTypeParameter](c, rb)
}

func (c FfiConverterMoveStructTypeParameter) Read(reader io.Reader) MoveStructTypeParameter {
	return MoveStructTypeParameter {
			FfiConverterSequenceMoveAbilityINSTANCE.Read(reader),
			FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterMoveStructTypeParameter) Lower(value MoveStructTypeParameter) C.RustBuffer {
	return LowerIntoRustBuffer[MoveStructTypeParameter](c, value)
}

func (c FfiConverterMoveStructTypeParameter) Write(writer io.Writer, value MoveStructTypeParameter) {
		FfiConverterSequenceMoveAbilityINSTANCE.Write(writer, value.Constraints);
		FfiConverterBoolINSTANCE.Write(writer, value.IsPhantom);
}

type FfiDestroyerMoveStructTypeParameter struct {}

func (_ FfiDestroyerMoveStructTypeParameter) Destroy(value MoveStructTypeParameter) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type NameRegistrationPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []*NameRegistration
}

func (r *NameRegistrationPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceNameRegistration{}.Destroy(r.Data);
}

type FfiConverterNameRegistrationPage struct {}

var FfiConverterNameRegistrationPageINSTANCE = FfiConverterNameRegistrationPage{}

func (c FfiConverterNameRegistrationPage) Lift(rb RustBufferI) NameRegistrationPage {
	return LiftFromRustBuffer[NameRegistrationPage](c, rb)
}

func (c FfiConverterNameRegistrationPage) Read(reader io.Reader) NameRegistrationPage {
	return NameRegistrationPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceNameRegistrationINSTANCE.Read(reader),
	}
}

func (c FfiConverterNameRegistrationPage) Lower(value NameRegistrationPage) C.RustBuffer {
	return LowerIntoRustBuffer[NameRegistrationPage](c, value)
}

func (c FfiConverterNameRegistrationPage) Write(writer io.Writer, value NameRegistrationPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceNameRegistrationINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerNameRegistrationPage struct {}

func (_ FfiDestroyerNameRegistrationPage) Destroy(value NameRegistrationPage) {
	value.Destroy()
}
type ObjectFilter struct {
	TypeTag *string
	Owner **Address
	ObjectIds *[]*ObjectId
}

func (r *ObjectFilter) Destroy() {
		FfiDestroyerOptionalString{}.Destroy(r.TypeTag);
		FfiDestroyerOptionalAddress{}.Destroy(r.Owner);
		FfiDestroyerOptionalSequenceObjectId{}.Destroy(r.ObjectIds);
}

type FfiConverterObjectFilter struct {}

var FfiConverterObjectFilterINSTANCE = FfiConverterObjectFilter{}

func (c FfiConverterObjectFilter) Lift(rb RustBufferI) ObjectFilter {
	return LiftFromRustBuffer[ObjectFilter](c, rb)
}

func (c FfiConverterObjectFilter) Read(reader io.Reader) ObjectFilter {
	return ObjectFilter {
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalAddressINSTANCE.Read(reader),
			FfiConverterOptionalSequenceObjectIdINSTANCE.Read(reader),
	}
}

func (c FfiConverterObjectFilter) Lower(value ObjectFilter) C.RustBuffer {
	return LowerIntoRustBuffer[ObjectFilter](c, value)
}

func (c FfiConverterObjectFilter) Write(writer io.Writer, value ObjectFilter) {
		FfiConverterOptionalStringINSTANCE.Write(writer, value.TypeTag);
		FfiConverterOptionalAddressINSTANCE.Write(writer, value.Owner);
		FfiConverterOptionalSequenceObjectIdINSTANCE.Write(writer, value.ObjectIds);
}

type FfiDestroyerObjectFilter struct {}

func (_ FfiDestroyerObjectFilter) Destroy(value ObjectFilter) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type ObjectPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []*Object
}

func (r *ObjectPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceObject{}.Destroy(r.Data);
}

type FfiConverterObjectPage struct {}

var FfiConverterObjectPageINSTANCE = FfiConverterObjectPage{}

func (c FfiConverterObjectPage) Lift(rb RustBufferI) ObjectPage {
	return LiftFromRustBuffer[ObjectPage](c, rb)
}

func (c FfiConverterObjectPage) Read(reader io.Reader) ObjectPage {
	return ObjectPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceObjectINSTANCE.Read(reader),
	}
}

func (c FfiConverterObjectPage) Lower(value ObjectPage) C.RustBuffer {
	return LowerIntoRustBuffer[ObjectPage](c, value)
}

func (c FfiConverterObjectPage) Write(writer io.Writer, value ObjectPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceObjectINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerObjectPage struct {}

func (_ FfiDestroyerObjectPage) Destroy(value ObjectPage) {
	value.Destroy()
}
type ObjectRef struct {
	Address *ObjectId
	Digest string
	Version uint64
}

func (r *ObjectRef) Destroy() {
		FfiDestroyerObjectId{}.Destroy(r.Address);
		FfiDestroyerString{}.Destroy(r.Digest);
		FfiDestroyerUint64{}.Destroy(r.Version);
}

type FfiConverterObjectRef struct {}

var FfiConverterObjectRefINSTANCE = FfiConverterObjectRef{}

func (c FfiConverterObjectRef) Lift(rb RustBufferI) ObjectRef {
	return LiftFromRustBuffer[ObjectRef](c, rb)
}

func (c FfiConverterObjectRef) Read(reader io.Reader) ObjectRef {
	return ObjectRef {
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterObjectRef) Lower(value ObjectRef) C.RustBuffer {
	return LowerIntoRustBuffer[ObjectRef](c, value)
}

func (c FfiConverterObjectRef) Write(writer io.Writer, value ObjectRef) {
		FfiConverterObjectIdINSTANCE.Write(writer, value.Address);
		FfiConverterStringINSTANCE.Write(writer, value.Digest);
		FfiConverterUint64INSTANCE.Write(writer, value.Version);
}

type FfiDestroyerObjectRef struct {}

func (_ FfiDestroyerObjectRef) Destroy(value ObjectRef) {
	value.Destroy()
}
// Reference to an object
//
// Contains sufficient information to uniquely identify a specific object.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object-ref = object-id u64 digest
// ```
type ObjectReference struct {
	ObjectId *ObjectId
	Version uint64
	Digest *Digest
}

func (r *ObjectReference) Destroy() {
		FfiDestroyerObjectId{}.Destroy(r.ObjectId);
		FfiDestroyerUint64{}.Destroy(r.Version);
		FfiDestroyerDigest{}.Destroy(r.Digest);
}

type FfiConverterObjectReference struct {}

var FfiConverterObjectReferenceINSTANCE = FfiConverterObjectReference{}

func (c FfiConverterObjectReference) Lift(rb RustBufferI) ObjectReference {
	return LiftFromRustBuffer[ObjectReference](c, rb)
}

func (c FfiConverterObjectReference) Read(reader io.Reader) ObjectReference {
	return ObjectReference {
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterDigestINSTANCE.Read(reader),
	}
}

func (c FfiConverterObjectReference) Lower(value ObjectReference) C.RustBuffer {
	return LowerIntoRustBuffer[ObjectReference](c, value)
}

func (c FfiConverterObjectReference) Write(writer io.Writer, value ObjectReference) {
		FfiConverterObjectIdINSTANCE.Write(writer, value.ObjectId);
		FfiConverterUint64INSTANCE.Write(writer, value.Version);
		FfiConverterDigestINSTANCE.Write(writer, value.Digest);
}

type FfiDestroyerObjectReference struct {}

func (_ FfiDestroyerObjectReference) Destroy(value ObjectReference) {
	value.Destroy()
}
type OpenMoveType struct {
	Repr string
}

func (r *OpenMoveType) Destroy() {
		FfiDestroyerString{}.Destroy(r.Repr);
}

type FfiConverterOpenMoveType struct {}

var FfiConverterOpenMoveTypeINSTANCE = FfiConverterOpenMoveType{}

func (c FfiConverterOpenMoveType) Lift(rb RustBufferI) OpenMoveType {
	return LiftFromRustBuffer[OpenMoveType](c, rb)
}

func (c FfiConverterOpenMoveType) Read(reader io.Reader) OpenMoveType {
	return OpenMoveType {
			FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterOpenMoveType) Lower(value OpenMoveType) C.RustBuffer {
	return LowerIntoRustBuffer[OpenMoveType](c, value)
}

func (c FfiConverterOpenMoveType) Write(writer io.Writer, value OpenMoveType) {
		FfiConverterStringINSTANCE.Write(writer, value.Repr);
}

type FfiDestroyerOpenMoveType struct {}

func (_ FfiDestroyerOpenMoveType) Destroy(value OpenMoveType) {
	value.Destroy()
}
// Information about pagination in a connection.
type PageInfo struct {
	// When paginating backwards, are there more items?
	HasPreviousPage bool
	// Are there more items when paginating forwards?
	HasNextPage bool
	// When paginating backwards, the cursor to continue.
	StartCursor *string
	// When paginating forwards, the cursor to continue.
	EndCursor *string
}

func (r *PageInfo) Destroy() {
		FfiDestroyerBool{}.Destroy(r.HasPreviousPage);
		FfiDestroyerBool{}.Destroy(r.HasNextPage);
		FfiDestroyerOptionalString{}.Destroy(r.StartCursor);
		FfiDestroyerOptionalString{}.Destroy(r.EndCursor);
}

type FfiConverterPageInfo struct {}

var FfiConverterPageInfoINSTANCE = FfiConverterPageInfo{}

func (c FfiConverterPageInfo) Lift(rb RustBufferI) PageInfo {
	return LiftFromRustBuffer[PageInfo](c, rb)
}

func (c FfiConverterPageInfo) Read(reader io.Reader) PageInfo {
	return PageInfo {
			FfiConverterBoolINSTANCE.Read(reader),
			FfiConverterBoolINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterPageInfo) Lower(value PageInfo) C.RustBuffer {
	return LowerIntoRustBuffer[PageInfo](c, value)
}

func (c FfiConverterPageInfo) Write(writer io.Writer, value PageInfo) {
		FfiConverterBoolINSTANCE.Write(writer, value.HasPreviousPage);
		FfiConverterBoolINSTANCE.Write(writer, value.HasNextPage);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.StartCursor);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.EndCursor);
}

type FfiDestroyerPageInfo struct {}

func (_ FfiDestroyerPageInfo) Destroy(value PageInfo) {
	value.Destroy()
}
// Pagination options for querying the GraphQL server. It defaults to forward
// pagination with the GraphQL server's max page size.
type PaginationFilter struct {
	// The direction of pagination.
	Direction Direction
	// An opaque cursor used for pagination.
	Cursor *string
	// The maximum number of items to return. If this is omitted, it will
	// lazily query the service configuration for the max page size.
	Limit *int32
}

func (r *PaginationFilter) Destroy() {
		FfiDestroyerDirection{}.Destroy(r.Direction);
		FfiDestroyerOptionalString{}.Destroy(r.Cursor);
		FfiDestroyerOptionalInt32{}.Destroy(r.Limit);
}

type FfiConverterPaginationFilter struct {}

var FfiConverterPaginationFilterINSTANCE = FfiConverterPaginationFilter{}

func (c FfiConverterPaginationFilter) Lift(rb RustBufferI) PaginationFilter {
	return LiftFromRustBuffer[PaginationFilter](c, rb)
}

func (c FfiConverterPaginationFilter) Read(reader io.Reader) PaginationFilter {
	return PaginationFilter {
			FfiConverterDirectionINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalInt32INSTANCE.Read(reader),
	}
}

func (c FfiConverterPaginationFilter) Lower(value PaginationFilter) C.RustBuffer {
	return LowerIntoRustBuffer[PaginationFilter](c, value)
}

func (c FfiConverterPaginationFilter) Write(writer io.Writer, value PaginationFilter) {
		FfiConverterDirectionINSTANCE.Write(writer, value.Direction);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.Cursor);
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.Limit);
}

type FfiDestroyerPaginationFilter struct {}

func (_ FfiDestroyerPaginationFilter) Destroy(value PaginationFilter) {
	value.Destroy()
}
// A key-value protocol configuration attribute.
type ProtocolConfigAttr struct {
	Key string
	Value *string
}

func (r *ProtocolConfigAttr) Destroy() {
		FfiDestroyerString{}.Destroy(r.Key);
		FfiDestroyerOptionalString{}.Destroy(r.Value);
}

type FfiConverterProtocolConfigAttr struct {}

var FfiConverterProtocolConfigAttrINSTANCE = FfiConverterProtocolConfigAttr{}

func (c FfiConverterProtocolConfigAttr) Lift(rb RustBufferI) ProtocolConfigAttr {
	return LiftFromRustBuffer[ProtocolConfigAttr](c, rb)
}

func (c FfiConverterProtocolConfigAttr) Read(reader io.Reader) ProtocolConfigAttr {
	return ProtocolConfigAttr {
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterProtocolConfigAttr) Lower(value ProtocolConfigAttr) C.RustBuffer {
	return LowerIntoRustBuffer[ProtocolConfigAttr](c, value)
}

func (c FfiConverterProtocolConfigAttr) Write(writer io.Writer, value ProtocolConfigAttr) {
		FfiConverterStringINSTANCE.Write(writer, value.Key);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.Value);
}

type FfiDestroyerProtocolConfigAttr struct {}

func (_ FfiDestroyerProtocolConfigAttr) Destroy(value ProtocolConfigAttr) {
	value.Destroy()
}
// Feature flags are a form of boolean configuration that are usually used to
// gate features while they are in development. Once a lag has been enabled, it
// is rare for it to be disabled.
type ProtocolConfigFeatureFlag struct {
	Key string
	Value bool
}

func (r *ProtocolConfigFeatureFlag) Destroy() {
		FfiDestroyerString{}.Destroy(r.Key);
		FfiDestroyerBool{}.Destroy(r.Value);
}

type FfiConverterProtocolConfigFeatureFlag struct {}

var FfiConverterProtocolConfigFeatureFlagINSTANCE = FfiConverterProtocolConfigFeatureFlag{}

func (c FfiConverterProtocolConfigFeatureFlag) Lift(rb RustBufferI) ProtocolConfigFeatureFlag {
	return LiftFromRustBuffer[ProtocolConfigFeatureFlag](c, rb)
}

func (c FfiConverterProtocolConfigFeatureFlag) Read(reader io.Reader) ProtocolConfigFeatureFlag {
	return ProtocolConfigFeatureFlag {
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterProtocolConfigFeatureFlag) Lower(value ProtocolConfigFeatureFlag) C.RustBuffer {
	return LowerIntoRustBuffer[ProtocolConfigFeatureFlag](c, value)
}

func (c FfiConverterProtocolConfigFeatureFlag) Write(writer io.Writer, value ProtocolConfigFeatureFlag) {
		FfiConverterStringINSTANCE.Write(writer, value.Key);
		FfiConverterBoolINSTANCE.Write(writer, value.Value);
}

type FfiDestroyerProtocolConfigFeatureFlag struct {}

func (_ FfiDestroyerProtocolConfigFeatureFlag) Destroy(value ProtocolConfigFeatureFlag) {
	value.Destroy()
}
// Information about the configuration of the protocol.
// Constants that control how the chain operates.
// These can only change during protocol upgrades which happen on epoch
// boundaries.
type ProtocolConfigs struct {
	// The protocol is not required to change on every epoch boundary, so the
	// protocol version tracks which change to the protocol these configs
	// are from.
	ProtocolVersion uint64
	// List all available feature flags and their values. Feature flags are a
	// form of boolean configuration that are usually used to gate features
	// while they are in development. Once a flag has been enabled, it is
	// rare for it to be disabled.
	FeatureFlags []ProtocolConfigFeatureFlag
	// List all available configurations and their values. These configurations
	// can take any value (but they will all be represented in string
	// form), and do not include feature flags.
	Configs []ProtocolConfigAttr
}

func (r *ProtocolConfigs) Destroy() {
		FfiDestroyerUint64{}.Destroy(r.ProtocolVersion);
		FfiDestroyerSequenceProtocolConfigFeatureFlag{}.Destroy(r.FeatureFlags);
		FfiDestroyerSequenceProtocolConfigAttr{}.Destroy(r.Configs);
}

type FfiConverterProtocolConfigs struct {}

var FfiConverterProtocolConfigsINSTANCE = FfiConverterProtocolConfigs{}

func (c FfiConverterProtocolConfigs) Lift(rb RustBufferI) ProtocolConfigs {
	return LiftFromRustBuffer[ProtocolConfigs](c, rb)
}

func (c FfiConverterProtocolConfigs) Read(reader io.Reader) ProtocolConfigs {
	return ProtocolConfigs {
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterSequenceProtocolConfigFeatureFlagINSTANCE.Read(reader),
			FfiConverterSequenceProtocolConfigAttrINSTANCE.Read(reader),
	}
}

func (c FfiConverterProtocolConfigs) Lower(value ProtocolConfigs) C.RustBuffer {
	return LowerIntoRustBuffer[ProtocolConfigs](c, value)
}

func (c FfiConverterProtocolConfigs) Write(writer io.Writer, value ProtocolConfigs) {
		FfiConverterUint64INSTANCE.Write(writer, value.ProtocolVersion);
		FfiConverterSequenceProtocolConfigFeatureFlagINSTANCE.Write(writer, value.FeatureFlags);
		FfiConverterSequenceProtocolConfigAttrINSTANCE.Write(writer, value.Configs);
}

type FfiDestroyerProtocolConfigs struct {}

func (_ FfiDestroyerProtocolConfigs) Destroy(value ProtocolConfigs) {
	value.Destroy()
}
type Query struct {
	Query string
	Variables *Value
}

func (r *Query) Destroy() {
		FfiDestroyerString{}.Destroy(r.Query);
		FfiDestroyerOptionalTypeValue{}.Destroy(r.Variables);
}

type FfiConverterQuery struct {}

var FfiConverterQueryINSTANCE = FfiConverterQuery{}

func (c FfiConverterQuery) Lift(rb RustBufferI) Query {
	return LiftFromRustBuffer[Query](c, rb)
}

func (c FfiConverterQuery) Read(reader io.Reader) Query {
	return Query {
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterOptionalTypeValueINSTANCE.Read(reader),
	}
}

func (c FfiConverterQuery) Lower(value Query) C.RustBuffer {
	return LowerIntoRustBuffer[Query](c, value)
}

func (c FfiConverterQuery) Write(writer io.Writer, value Query) {
		FfiConverterStringINSTANCE.Write(writer, value.Query);
		FfiConverterOptionalTypeValueINSTANCE.Write(writer, value.Variables);
}

type FfiDestroyerQuery struct {}

func (_ FfiDestroyerQuery) Destroy(value Query) {
	value.Destroy()
}
// Randomness update
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// randomness-state-update = u64 u64 bytes u64
// ```
type RandomnessStateUpdate struct {
	// Epoch of the randomness state update transaction
	Epoch uint64
	// Randomness round of the update
	RandomnessRound uint64
	// Updated random bytes
	RandomBytes []byte
	// The initial version of the randomness object that it was shared at
	RandomnessObjInitialSharedVersion uint64
}

func (r *RandomnessStateUpdate) Destroy() {
		FfiDestroyerUint64{}.Destroy(r.Epoch);
		FfiDestroyerUint64{}.Destroy(r.RandomnessRound);
		FfiDestroyerBytes{}.Destroy(r.RandomBytes);
		FfiDestroyerUint64{}.Destroy(r.RandomnessObjInitialSharedVersion);
}

type FfiConverterRandomnessStateUpdate struct {}

var FfiConverterRandomnessStateUpdateINSTANCE = FfiConverterRandomnessStateUpdate{}

func (c FfiConverterRandomnessStateUpdate) Lift(rb RustBufferI) RandomnessStateUpdate {
	return LiftFromRustBuffer[RandomnessStateUpdate](c, rb)
}

func (c FfiConverterRandomnessStateUpdate) Read(reader io.Reader) RandomnessStateUpdate {
	return RandomnessStateUpdate {
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterBytesINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterRandomnessStateUpdate) Lower(value RandomnessStateUpdate) C.RustBuffer {
	return LowerIntoRustBuffer[RandomnessStateUpdate](c, value)
}

func (c FfiConverterRandomnessStateUpdate) Write(writer io.Writer, value RandomnessStateUpdate) {
		FfiConverterUint64INSTANCE.Write(writer, value.Epoch);
		FfiConverterUint64INSTANCE.Write(writer, value.RandomnessRound);
		FfiConverterBytesINSTANCE.Write(writer, value.RandomBytes);
		FfiConverterUint64INSTANCE.Write(writer, value.RandomnessObjInitialSharedVersion);
}

type FfiDestroyerRandomnessStateUpdate struct {}

func (_ FfiDestroyerRandomnessStateUpdate) Destroy(value RandomnessStateUpdate) {
	value.Destroy()
}
type ServiceConfig struct {
	// Default number of elements allowed on a single page of a connection.
	DefaultPageSize int32
	// List of all features that are enabled on this RPC service.
	EnabledFeatures []Feature
	// Maximum estimated cost of a database query used to serve a GraphQL
	// request.  This is measured in the same units that the database uses
	// in EXPLAIN queries.
	// Maximum nesting allowed in struct fields when calculating the layout of
	// a single Move Type.
	MaxMoveValueDepth int32
	// The maximum number of output nodes in a GraphQL response.
	// Non-connection nodes have a count of 1, while connection nodes are
	// counted as the specified 'first' or 'last' number of items, or the
	// default_page_size as set by the server if those arguments are not
	// set. Counts accumulate multiplicatively down the query tree. For
	// example, if a query starts with a connection of first: 10 and has a
	// field to a connection with last: 20, the count at the second level
	// would be 200 nodes. This is then summed to the count of 10 nodes
	// at the first level, for a total of 210 nodes.
	MaxOutputNodes int32
	// Maximum number of elements allowed on a single page of a connection.
	MaxPageSize int32
	// The maximum depth a GraphQL query can be to be accepted by this service.
	MaxQueryDepth int32
	// The maximum number of nodes (field names) the service will accept in a
	// single query.
	MaxQueryNodes int32
	// Maximum length of a query payload string.
	MaxQueryPayloadSize int32
	// Maximum nesting allowed in type arguments in Move Types resolved by this
	// service.
	MaxTypeArgumentDepth int32
	// Maximum number of type arguments passed into a generic instantiation of
	// a Move Type resolved by this service.
	MaxTypeArgumentWidth int32
	// Maximum number of structs that need to be processed when calculating the
	// layout of a single Move Type.
	MaxTypeNodes int32
	// Maximum time in milliseconds spent waiting for a response from fullnode
	// after issuing a a transaction to execute. Note that the transaction
	// may still succeed even in the case of a timeout. Transactions are
	// idempotent, so a transaction that times out should be resubmitted
	// until the network returns a definite response (success or failure, not
	// timeout).
	MutationTimeoutMs int32
	// Maximum time in milliseconds that will be spent to serve one query
	// request.
	RequestTimeoutMs int32
}

func (r *ServiceConfig) Destroy() {
		FfiDestroyerInt32{}.Destroy(r.DefaultPageSize);
		FfiDestroyerSequenceFeature{}.Destroy(r.EnabledFeatures);
		FfiDestroyerInt32{}.Destroy(r.MaxMoveValueDepth);
		FfiDestroyerInt32{}.Destroy(r.MaxOutputNodes);
		FfiDestroyerInt32{}.Destroy(r.MaxPageSize);
		FfiDestroyerInt32{}.Destroy(r.MaxQueryDepth);
		FfiDestroyerInt32{}.Destroy(r.MaxQueryNodes);
		FfiDestroyerInt32{}.Destroy(r.MaxQueryPayloadSize);
		FfiDestroyerInt32{}.Destroy(r.MaxTypeArgumentDepth);
		FfiDestroyerInt32{}.Destroy(r.MaxTypeArgumentWidth);
		FfiDestroyerInt32{}.Destroy(r.MaxTypeNodes);
		FfiDestroyerInt32{}.Destroy(r.MutationTimeoutMs);
		FfiDestroyerInt32{}.Destroy(r.RequestTimeoutMs);
}

type FfiConverterServiceConfig struct {}

var FfiConverterServiceConfigINSTANCE = FfiConverterServiceConfig{}

func (c FfiConverterServiceConfig) Lift(rb RustBufferI) ServiceConfig {
	return LiftFromRustBuffer[ServiceConfig](c, rb)
}

func (c FfiConverterServiceConfig) Read(reader io.Reader) ServiceConfig {
	return ServiceConfig {
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterSequenceFeatureINSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
			FfiConverterInt32INSTANCE.Read(reader),
	}
}

func (c FfiConverterServiceConfig) Lower(value ServiceConfig) C.RustBuffer {
	return LowerIntoRustBuffer[ServiceConfig](c, value)
}

func (c FfiConverterServiceConfig) Write(writer io.Writer, value ServiceConfig) {
		FfiConverterInt32INSTANCE.Write(writer, value.DefaultPageSize);
		FfiConverterSequenceFeatureINSTANCE.Write(writer, value.EnabledFeatures);
		FfiConverterInt32INSTANCE.Write(writer, value.MaxMoveValueDepth);
		FfiConverterInt32INSTANCE.Write(writer, value.MaxOutputNodes);
		FfiConverterInt32INSTANCE.Write(writer, value.MaxPageSize);
		FfiConverterInt32INSTANCE.Write(writer, value.MaxQueryDepth);
		FfiConverterInt32INSTANCE.Write(writer, value.MaxQueryNodes);
		FfiConverterInt32INSTANCE.Write(writer, value.MaxQueryPayloadSize);
		FfiConverterInt32INSTANCE.Write(writer, value.MaxTypeArgumentDepth);
		FfiConverterInt32INSTANCE.Write(writer, value.MaxTypeArgumentWidth);
		FfiConverterInt32INSTANCE.Write(writer, value.MaxTypeNodes);
		FfiConverterInt32INSTANCE.Write(writer, value.MutationTimeoutMs);
		FfiConverterInt32INSTANCE.Write(writer, value.RequestTimeoutMs);
}

type FfiDestroyerServiceConfig struct {}

func (_ FfiDestroyerServiceConfig) Destroy(value ServiceConfig) {
	value.Destroy()
}
type SignedTransaction struct {
	Transaction *Transaction
	Signatures []*UserSignature
}

func (r *SignedTransaction) Destroy() {
		FfiDestroyerTransaction{}.Destroy(r.Transaction);
		FfiDestroyerSequenceUserSignature{}.Destroy(r.Signatures);
}

type FfiConverterSignedTransaction struct {}

var FfiConverterSignedTransactionINSTANCE = FfiConverterSignedTransaction{}

func (c FfiConverterSignedTransaction) Lift(rb RustBufferI) SignedTransaction {
	return LiftFromRustBuffer[SignedTransaction](c, rb)
}

func (c FfiConverterSignedTransaction) Read(reader io.Reader) SignedTransaction {
	return SignedTransaction {
			FfiConverterTransactionINSTANCE.Read(reader),
			FfiConverterSequenceUserSignatureINSTANCE.Read(reader),
	}
}

func (c FfiConverterSignedTransaction) Lower(value SignedTransaction) C.RustBuffer {
	return LowerIntoRustBuffer[SignedTransaction](c, value)
}

func (c FfiConverterSignedTransaction) Write(writer io.Writer, value SignedTransaction) {
		FfiConverterTransactionINSTANCE.Write(writer, value.Transaction);
		FfiConverterSequenceUserSignatureINSTANCE.Write(writer, value.Signatures);
}

type FfiDestroyerSignedTransaction struct {}

func (_ FfiDestroyerSignedTransaction) Destroy(value SignedTransaction) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type SignedTransactionPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []SignedTransaction
}

func (r *SignedTransactionPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceSignedTransaction{}.Destroy(r.Data);
}

type FfiConverterSignedTransactionPage struct {}

var FfiConverterSignedTransactionPageINSTANCE = FfiConverterSignedTransactionPage{}

func (c FfiConverterSignedTransactionPage) Lift(rb RustBufferI) SignedTransactionPage {
	return LiftFromRustBuffer[SignedTransactionPage](c, rb)
}

func (c FfiConverterSignedTransactionPage) Read(reader io.Reader) SignedTransactionPage {
	return SignedTransactionPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceSignedTransactionINSTANCE.Read(reader),
	}
}

func (c FfiConverterSignedTransactionPage) Lower(value SignedTransactionPage) C.RustBuffer {
	return LowerIntoRustBuffer[SignedTransactionPage](c, value)
}

func (c FfiConverterSignedTransactionPage) Write(writer io.Writer, value SignedTransactionPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceSignedTransactionINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerSignedTransactionPage struct {}

func (_ FfiDestroyerSignedTransactionPage) Destroy(value SignedTransactionPage) {
	value.Destroy()
}
type TransactionDataEffects struct {
	Tx SignedTransaction
	Effects *TransactionEffects
}

func (r *TransactionDataEffects) Destroy() {
		FfiDestroyerSignedTransaction{}.Destroy(r.Tx);
		FfiDestroyerTransactionEffects{}.Destroy(r.Effects);
}

type FfiConverterTransactionDataEffects struct {}

var FfiConverterTransactionDataEffectsINSTANCE = FfiConverterTransactionDataEffects{}

func (c FfiConverterTransactionDataEffects) Lift(rb RustBufferI) TransactionDataEffects {
	return LiftFromRustBuffer[TransactionDataEffects](c, rb)
}

func (c FfiConverterTransactionDataEffects) Read(reader io.Reader) TransactionDataEffects {
	return TransactionDataEffects {
			FfiConverterSignedTransactionINSTANCE.Read(reader),
			FfiConverterTransactionEffectsINSTANCE.Read(reader),
	}
}

func (c FfiConverterTransactionDataEffects) Lower(value TransactionDataEffects) C.RustBuffer {
	return LowerIntoRustBuffer[TransactionDataEffects](c, value)
}

func (c FfiConverterTransactionDataEffects) Write(writer io.Writer, value TransactionDataEffects) {
		FfiConverterSignedTransactionINSTANCE.Write(writer, value.Tx);
		FfiConverterTransactionEffectsINSTANCE.Write(writer, value.Effects);
}

type FfiDestroyerTransactionDataEffects struct {}

func (_ FfiDestroyerTransactionDataEffects) Destroy(value TransactionDataEffects) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type TransactionDataEffectsPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []TransactionDataEffects
}

func (r *TransactionDataEffectsPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceTransactionDataEffects{}.Destroy(r.Data);
}

type FfiConverterTransactionDataEffectsPage struct {}

var FfiConverterTransactionDataEffectsPageINSTANCE = FfiConverterTransactionDataEffectsPage{}

func (c FfiConverterTransactionDataEffectsPage) Lift(rb RustBufferI) TransactionDataEffectsPage {
	return LiftFromRustBuffer[TransactionDataEffectsPage](c, rb)
}

func (c FfiConverterTransactionDataEffectsPage) Read(reader io.Reader) TransactionDataEffectsPage {
	return TransactionDataEffectsPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceTransactionDataEffectsINSTANCE.Read(reader),
	}
}

func (c FfiConverterTransactionDataEffectsPage) Lower(value TransactionDataEffectsPage) C.RustBuffer {
	return LowerIntoRustBuffer[TransactionDataEffectsPage](c, value)
}

func (c FfiConverterTransactionDataEffectsPage) Write(writer io.Writer, value TransactionDataEffectsPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceTransactionDataEffectsINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerTransactionDataEffectsPage struct {}

func (_ FfiDestroyerTransactionDataEffectsPage) Destroy(value TransactionDataEffectsPage) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type TransactionEffectsPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []*TransactionEffects
}

func (r *TransactionEffectsPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceTransactionEffects{}.Destroy(r.Data);
}

type FfiConverterTransactionEffectsPage struct {}

var FfiConverterTransactionEffectsPageINSTANCE = FfiConverterTransactionEffectsPage{}

func (c FfiConverterTransactionEffectsPage) Lift(rb RustBufferI) TransactionEffectsPage {
	return LiftFromRustBuffer[TransactionEffectsPage](c, rb)
}

func (c FfiConverterTransactionEffectsPage) Read(reader io.Reader) TransactionEffectsPage {
	return TransactionEffectsPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceTransactionEffectsINSTANCE.Read(reader),
	}
}

func (c FfiConverterTransactionEffectsPage) Lower(value TransactionEffectsPage) C.RustBuffer {
	return LowerIntoRustBuffer[TransactionEffectsPage](c, value)
}

func (c FfiConverterTransactionEffectsPage) Write(writer io.Writer, value TransactionEffectsPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceTransactionEffectsINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerTransactionEffectsPage struct {}

func (_ FfiDestroyerTransactionEffectsPage) Destroy(value TransactionEffectsPage) {
	value.Destroy()
}
// Version 1 of TransactionEffects
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// effects-v1 = execution-status
// u64                                ; epoch
// gas-cost-summary
// digest                             ; transaction digest
// (option u32)                       ; gas object index
// (option digest)                    ; events digest
// (vector digest)                    ; list of transaction dependencies
// u64                                ; lamport version
// (vector changed-object)
// (vector unchanged-shared-object)
// (option digest)                    ; auxiliary data digest
// ```
type TransactionEffectsV1 struct {
	// The status of the execution
	Status ExecutionStatus
	// The epoch when this transaction was executed.
	Epoch uint64
	// The gas used by this transaction
	GasUsed GasCostSummary
	// The transaction digest
	TransactionDigest *Digest
	// The updated gas object reference, as an index into the `changed_objects`
	// vector. Having a dedicated field for convenient access.
	// System transaction that don't require gas will leave this as None.
	GasObjectIndex *uint32
	// The digest of the events emitted during execution,
	// can be None if the transaction does not emit any event.
	EventsDigest **Digest
	// The set of transaction digests this transaction depends on.
	Dependencies []*Digest
	// The version number of all the written Move objects by this transaction.
	LamportVersion uint64
	// Objects whose state are changed in the object store.
	ChangedObjects []ChangedObject
	// Shared objects that are not mutated in this transaction. Unlike owned
	// objects, read-only shared objects' version are not committed in the
	// transaction, and in order for a node to catch up and execute it
	// without consensus sequencing, the version needs to be committed in
	// the effects.
	UnchangedSharedObjects []UnchangedSharedObject
	// Auxiliary data that are not protocol-critical, generated as part of the
	// effects but are stored separately. Storing it separately allows us
	// to avoid bloating the effects with data that are not critical.
	// It also provides more flexibility on the format and type of the data.
	AuxiliaryDataDigest **Digest
}

func (r *TransactionEffectsV1) Destroy() {
		FfiDestroyerExecutionStatus{}.Destroy(r.Status);
		FfiDestroyerUint64{}.Destroy(r.Epoch);
		FfiDestroyerGasCostSummary{}.Destroy(r.GasUsed);
		FfiDestroyerDigest{}.Destroy(r.TransactionDigest);
		FfiDestroyerOptionalUint32{}.Destroy(r.GasObjectIndex);
		FfiDestroyerOptionalDigest{}.Destroy(r.EventsDigest);
		FfiDestroyerSequenceDigest{}.Destroy(r.Dependencies);
		FfiDestroyerUint64{}.Destroy(r.LamportVersion);
		FfiDestroyerSequenceChangedObject{}.Destroy(r.ChangedObjects);
		FfiDestroyerSequenceUnchangedSharedObject{}.Destroy(r.UnchangedSharedObjects);
		FfiDestroyerOptionalDigest{}.Destroy(r.AuxiliaryDataDigest);
}

type FfiConverterTransactionEffectsV1 struct {}

var FfiConverterTransactionEffectsV1INSTANCE = FfiConverterTransactionEffectsV1{}

func (c FfiConverterTransactionEffectsV1) Lift(rb RustBufferI) TransactionEffectsV1 {
	return LiftFromRustBuffer[TransactionEffectsV1](c, rb)
}

func (c FfiConverterTransactionEffectsV1) Read(reader io.Reader) TransactionEffectsV1 {
	return TransactionEffectsV1 {
			FfiConverterExecutionStatusINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterGasCostSummaryINSTANCE.Read(reader),
			FfiConverterDigestINSTANCE.Read(reader),
			FfiConverterOptionalUint32INSTANCE.Read(reader),
			FfiConverterOptionalDigestINSTANCE.Read(reader),
			FfiConverterSequenceDigestINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterSequenceChangedObjectINSTANCE.Read(reader),
			FfiConverterSequenceUnchangedSharedObjectINSTANCE.Read(reader),
			FfiConverterOptionalDigestINSTANCE.Read(reader),
	}
}

func (c FfiConverterTransactionEffectsV1) Lower(value TransactionEffectsV1) C.RustBuffer {
	return LowerIntoRustBuffer[TransactionEffectsV1](c, value)
}

func (c FfiConverterTransactionEffectsV1) Write(writer io.Writer, value TransactionEffectsV1) {
		FfiConverterExecutionStatusINSTANCE.Write(writer, value.Status);
		FfiConverterUint64INSTANCE.Write(writer, value.Epoch);
		FfiConverterGasCostSummaryINSTANCE.Write(writer, value.GasUsed);
		FfiConverterDigestINSTANCE.Write(writer, value.TransactionDigest);
		FfiConverterOptionalUint32INSTANCE.Write(writer, value.GasObjectIndex);
		FfiConverterOptionalDigestINSTANCE.Write(writer, value.EventsDigest);
		FfiConverterSequenceDigestINSTANCE.Write(writer, value.Dependencies);
		FfiConverterUint64INSTANCE.Write(writer, value.LamportVersion);
		FfiConverterSequenceChangedObjectINSTANCE.Write(writer, value.ChangedObjects);
		FfiConverterSequenceUnchangedSharedObjectINSTANCE.Write(writer, value.UnchangedSharedObjects);
		FfiConverterOptionalDigestINSTANCE.Write(writer, value.AuxiliaryDataDigest);
}

type FfiDestroyerTransactionEffectsV1 struct {}

func (_ FfiDestroyerTransactionEffectsV1) Destroy(value TransactionEffectsV1) {
	value.Destroy()
}
type TransactionMetadata struct {
	GasBudget *uint64
	GasObjects *[]ObjectRef
	GasPrice *uint64
	GasSponsor **Address
	Sender **Address
}

func (r *TransactionMetadata) Destroy() {
		FfiDestroyerOptionalUint64{}.Destroy(r.GasBudget);
		FfiDestroyerOptionalSequenceObjectRef{}.Destroy(r.GasObjects);
		FfiDestroyerOptionalUint64{}.Destroy(r.GasPrice);
		FfiDestroyerOptionalAddress{}.Destroy(r.GasSponsor);
		FfiDestroyerOptionalAddress{}.Destroy(r.Sender);
}

type FfiConverterTransactionMetadata struct {}

var FfiConverterTransactionMetadataINSTANCE = FfiConverterTransactionMetadata{}

func (c FfiConverterTransactionMetadata) Lift(rb RustBufferI) TransactionMetadata {
	return LiftFromRustBuffer[TransactionMetadata](c, rb)
}

func (c FfiConverterTransactionMetadata) Read(reader io.Reader) TransactionMetadata {
	return TransactionMetadata {
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalSequenceObjectRefINSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalAddressINSTANCE.Read(reader),
			FfiConverterOptionalAddressINSTANCE.Read(reader),
	}
}

func (c FfiConverterTransactionMetadata) Lower(value TransactionMetadata) C.RustBuffer {
	return LowerIntoRustBuffer[TransactionMetadata](c, value)
}

func (c FfiConverterTransactionMetadata) Write(writer io.Writer, value TransactionMetadata) {
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.GasBudget);
		FfiConverterOptionalSequenceObjectRefINSTANCE.Write(writer, value.GasObjects);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.GasPrice);
		FfiConverterOptionalAddressINSTANCE.Write(writer, value.GasSponsor);
		FfiConverterOptionalAddressINSTANCE.Write(writer, value.Sender);
}

type FfiDestroyerTransactionMetadata struct {}

func (_ FfiDestroyerTransactionMetadata) Destroy(value TransactionMetadata) {
	value.Destroy()
}
type TransactionsFilter struct {
	Function *string
	Kind *TransactionBlockKindInput
	AfterCheckpoint *uint64
	AtCheckpoint *uint64
	BeforeCheckpoint *uint64
	SignAddress **Address
	RecvAddress **Address
	InputObject **ObjectId
	ChangedObject **ObjectId
	TransactionIds *[]string
	WrappedOrDeletedObject **ObjectId
}

func (r *TransactionsFilter) Destroy() {
		FfiDestroyerOptionalString{}.Destroy(r.Function);
		FfiDestroyerOptionalTransactionBlockKindInput{}.Destroy(r.Kind);
		FfiDestroyerOptionalUint64{}.Destroy(r.AfterCheckpoint);
		FfiDestroyerOptionalUint64{}.Destroy(r.AtCheckpoint);
		FfiDestroyerOptionalUint64{}.Destroy(r.BeforeCheckpoint);
		FfiDestroyerOptionalAddress{}.Destroy(r.SignAddress);
		FfiDestroyerOptionalAddress{}.Destroy(r.RecvAddress);
		FfiDestroyerOptionalObjectId{}.Destroy(r.InputObject);
		FfiDestroyerOptionalObjectId{}.Destroy(r.ChangedObject);
		FfiDestroyerOptionalSequenceString{}.Destroy(r.TransactionIds);
		FfiDestroyerOptionalObjectId{}.Destroy(r.WrappedOrDeletedObject);
}

type FfiConverterTransactionsFilter struct {}

var FfiConverterTransactionsFilterINSTANCE = FfiConverterTransactionsFilter{}

func (c FfiConverterTransactionsFilter) Lift(rb RustBufferI) TransactionsFilter {
	return LiftFromRustBuffer[TransactionsFilter](c, rb)
}

func (c FfiConverterTransactionsFilter) Read(reader io.Reader) TransactionsFilter {
	return TransactionsFilter {
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalTransactionBlockKindInputINSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalAddressINSTANCE.Read(reader),
			FfiConverterOptionalAddressINSTANCE.Read(reader),
			FfiConverterOptionalObjectIdINSTANCE.Read(reader),
			FfiConverterOptionalObjectIdINSTANCE.Read(reader),
			FfiConverterOptionalSequenceStringINSTANCE.Read(reader),
			FfiConverterOptionalObjectIdINSTANCE.Read(reader),
	}
}

func (c FfiConverterTransactionsFilter) Lower(value TransactionsFilter) C.RustBuffer {
	return LowerIntoRustBuffer[TransactionsFilter](c, value)
}

func (c FfiConverterTransactionsFilter) Write(writer io.Writer, value TransactionsFilter) {
		FfiConverterOptionalStringINSTANCE.Write(writer, value.Function);
		FfiConverterOptionalTransactionBlockKindInputINSTANCE.Write(writer, value.Kind);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.AfterCheckpoint);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.AtCheckpoint);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.BeforeCheckpoint);
		FfiConverterOptionalAddressINSTANCE.Write(writer, value.SignAddress);
		FfiConverterOptionalAddressINSTANCE.Write(writer, value.RecvAddress);
		FfiConverterOptionalObjectIdINSTANCE.Write(writer, value.InputObject);
		FfiConverterOptionalObjectIdINSTANCE.Write(writer, value.ChangedObject);
		FfiConverterOptionalSequenceStringINSTANCE.Write(writer, value.TransactionIds);
		FfiConverterOptionalObjectIdINSTANCE.Write(writer, value.WrappedOrDeletedObject);
}

type FfiDestroyerTransactionsFilter struct {}

func (_ FfiDestroyerTransactionsFilter) Destroy(value TransactionsFilter) {
	value.Destroy()
}
// Identifies a struct and the module it was defined in
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// type-origin = identifier identifier object-id
// ```
type TypeOrigin struct {
	ModuleName *Identifier
	StructName *Identifier
	Package *ObjectId
}

func (r *TypeOrigin) Destroy() {
		FfiDestroyerIdentifier{}.Destroy(r.ModuleName);
		FfiDestroyerIdentifier{}.Destroy(r.StructName);
		FfiDestroyerObjectId{}.Destroy(r.Package);
}

type FfiConverterTypeOrigin struct {}

var FfiConverterTypeOriginINSTANCE = FfiConverterTypeOrigin{}

func (c FfiConverterTypeOrigin) Lift(rb RustBufferI) TypeOrigin {
	return LiftFromRustBuffer[TypeOrigin](c, rb)
}

func (c FfiConverterTypeOrigin) Read(reader io.Reader) TypeOrigin {
	return TypeOrigin {
			FfiConverterIdentifierINSTANCE.Read(reader),
			FfiConverterIdentifierINSTANCE.Read(reader),
			FfiConverterObjectIdINSTANCE.Read(reader),
	}
}

func (c FfiConverterTypeOrigin) Lower(value TypeOrigin) C.RustBuffer {
	return LowerIntoRustBuffer[TypeOrigin](c, value)
}

func (c FfiConverterTypeOrigin) Write(writer io.Writer, value TypeOrigin) {
		FfiConverterIdentifierINSTANCE.Write(writer, value.ModuleName);
		FfiConverterIdentifierINSTANCE.Write(writer, value.StructName);
		FfiConverterObjectIdINSTANCE.Write(writer, value.Package);
}

type FfiDestroyerTypeOrigin struct {}

func (_ FfiDestroyerTypeOrigin) Destroy(value TypeOrigin) {
	value.Destroy()
}
// A shared object that wasn't changed during execution
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// unchanged-shared-object = object-id unchanged-shared-object-kind
// ```
type UnchangedSharedObject struct {
	ObjectId *ObjectId
	Kind UnchangedSharedKind
}

func (r *UnchangedSharedObject) Destroy() {
		FfiDestroyerObjectId{}.Destroy(r.ObjectId);
		FfiDestroyerUnchangedSharedKind{}.Destroy(r.Kind);
}

type FfiConverterUnchangedSharedObject struct {}

var FfiConverterUnchangedSharedObjectINSTANCE = FfiConverterUnchangedSharedObject{}

func (c FfiConverterUnchangedSharedObject) Lift(rb RustBufferI) UnchangedSharedObject {
	return LiftFromRustBuffer[UnchangedSharedObject](c, rb)
}

func (c FfiConverterUnchangedSharedObject) Read(reader io.Reader) UnchangedSharedObject {
	return UnchangedSharedObject {
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterUnchangedSharedKindINSTANCE.Read(reader),
	}
}

func (c FfiConverterUnchangedSharedObject) Lower(value UnchangedSharedObject) C.RustBuffer {
	return LowerIntoRustBuffer[UnchangedSharedObject](c, value)
}

func (c FfiConverterUnchangedSharedObject) Write(writer io.Writer, value UnchangedSharedObject) {
		FfiConverterObjectIdINSTANCE.Write(writer, value.ObjectId);
		FfiConverterUnchangedSharedKindINSTANCE.Write(writer, value.Kind);
}

type FfiDestroyerUnchangedSharedObject struct {}

func (_ FfiDestroyerUnchangedSharedObject) Destroy(value UnchangedSharedObject) {
	value.Destroy()
}
// Upgraded package info for the linkage table
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// upgrade-info = object-id u64
// ```
type UpgradeInfo struct {
	// Id of the upgraded packages
	UpgradedId *ObjectId
	// Version of the upgraded package
	UpgradedVersion uint64
}

func (r *UpgradeInfo) Destroy() {
		FfiDestroyerObjectId{}.Destroy(r.UpgradedId);
		FfiDestroyerUint64{}.Destroy(r.UpgradedVersion);
}

type FfiConverterUpgradeInfo struct {}

var FfiConverterUpgradeInfoINSTANCE = FfiConverterUpgradeInfo{}

func (c FfiConverterUpgradeInfo) Lift(rb RustBufferI) UpgradeInfo {
	return LiftFromRustBuffer[UpgradeInfo](c, rb)
}

func (c FfiConverterUpgradeInfo) Read(reader io.Reader) UpgradeInfo {
	return UpgradeInfo {
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterUpgradeInfo) Lower(value UpgradeInfo) C.RustBuffer {
	return LowerIntoRustBuffer[UpgradeInfo](c, value)
}

func (c FfiConverterUpgradeInfo) Write(writer io.Writer, value UpgradeInfo) {
		FfiConverterObjectIdINSTANCE.Write(writer, value.UpgradedId);
		FfiConverterUint64INSTANCE.Write(writer, value.UpgradedVersion);
}

type FfiDestroyerUpgradeInfo struct {}

func (_ FfiDestroyerUpgradeInfo) Destroy(value UpgradeInfo) {
	value.Destroy()
}
// Represents a validator in the system.
type Validator struct {
	// The APY of this validator in basis points.
	// To get the APY in percentage, divide by 100.
	Apy *int32
	// The validator's address.
	Address *Address
	// The fee charged by the validator for staking services.
	CommissionRate *int32
	// Validator's credentials.
	Credentials *ValidatorCredentials
	// Validator's description.
	Description *string
	// Number of exchange rates in the table.
	ExchangeRatesSize *uint64
	// The reference gas price for this epoch.
	GasPrice *uint64
	// Validator's name.
	Name *string
	// Validator's url containing their custom image.
	ImageUrl *string
	// The proposed next epoch fee for the validator's staking services.
	NextEpochCommissionRate *int32
	// Validator's credentials for the next epoch.
	NextEpochCredentials *ValidatorCredentials
	// The validator's gas price quote for the next epoch.
	NextEpochGasPrice *uint64
	// The total number of IOTA tokens in this pool plus
	// the pending stake amount for this epoch.
	NextEpochStake *uint64
	// The validator's current valid `Cap` object. Validators can delegate
	// the operation ability to another address. The address holding this `Cap`
	// object can then update the reference gas price and tallying rule on
	// behalf of the validator.
	OperationCap *[]byte
	// Pending pool token withdrawn during the current epoch, emptied at epoch
	// boundaries. Zero for past epochs.
	PendingPoolTokenWithdraw *uint64
	// Pending stake amount for the current epoch, emptied at epoch boundaries.
	// Zero for past epochs.
	PendingStake *uint64
	// Pending stake withdrawn during the current epoch, emptied at epoch
	// boundaries. Zero for past epochs.
	PendingTotalIotaWithdraw *uint64
	// Total number of pool tokens issued by the pool.
	PoolTokenBalance *uint64
	// Validator's homepage URL.
	ProjectUrl *string
	// The epoch stake rewards will be added here at the end of each epoch.
	RewardsPool *uint64
	// The epoch at which this pool became active.
	StakingPoolActivationEpoch *uint64
	// The ID of this validator's `0x3::staking_pool::StakingPool`.
	StakingPoolId *ObjectId
	// The total number of IOTA tokens in this pool.
	StakingPoolIotaBalance *uint64
	// The voting power of this validator in basis points (e.g., 100 = 1%
	// voting power).
	VotingPower *int32
}

func (r *Validator) Destroy() {
		FfiDestroyerOptionalInt32{}.Destroy(r.Apy);
		FfiDestroyerAddress{}.Destroy(r.Address);
		FfiDestroyerOptionalInt32{}.Destroy(r.CommissionRate);
		FfiDestroyerOptionalValidatorCredentials{}.Destroy(r.Credentials);
		FfiDestroyerOptionalString{}.Destroy(r.Description);
		FfiDestroyerOptionalUint64{}.Destroy(r.ExchangeRatesSize);
		FfiDestroyerOptionalUint64{}.Destroy(r.GasPrice);
		FfiDestroyerOptionalString{}.Destroy(r.Name);
		FfiDestroyerOptionalString{}.Destroy(r.ImageUrl);
		FfiDestroyerOptionalInt32{}.Destroy(r.NextEpochCommissionRate);
		FfiDestroyerOptionalValidatorCredentials{}.Destroy(r.NextEpochCredentials);
		FfiDestroyerOptionalUint64{}.Destroy(r.NextEpochGasPrice);
		FfiDestroyerOptionalUint64{}.Destroy(r.NextEpochStake);
		FfiDestroyerOptionalBytes{}.Destroy(r.OperationCap);
		FfiDestroyerOptionalUint64{}.Destroy(r.PendingPoolTokenWithdraw);
		FfiDestroyerOptionalUint64{}.Destroy(r.PendingStake);
		FfiDestroyerOptionalUint64{}.Destroy(r.PendingTotalIotaWithdraw);
		FfiDestroyerOptionalUint64{}.Destroy(r.PoolTokenBalance);
		FfiDestroyerOptionalString{}.Destroy(r.ProjectUrl);
		FfiDestroyerOptionalUint64{}.Destroy(r.RewardsPool);
		FfiDestroyerOptionalUint64{}.Destroy(r.StakingPoolActivationEpoch);
		FfiDestroyerObjectId{}.Destroy(r.StakingPoolId);
		FfiDestroyerOptionalUint64{}.Destroy(r.StakingPoolIotaBalance);
		FfiDestroyerOptionalInt32{}.Destroy(r.VotingPower);
}

type FfiConverterValidator struct {}

var FfiConverterValidatorINSTANCE = FfiConverterValidator{}

func (c FfiConverterValidator) Lift(rb RustBufferI) Validator {
	return LiftFromRustBuffer[Validator](c, rb)
}

func (c FfiConverterValidator) Read(reader io.Reader) Validator {
	return Validator {
			FfiConverterOptionalInt32INSTANCE.Read(reader),
			FfiConverterAddressINSTANCE.Read(reader),
			FfiConverterOptionalInt32INSTANCE.Read(reader),
			FfiConverterOptionalValidatorCredentialsINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalInt32INSTANCE.Read(reader),
			FfiConverterOptionalValidatorCredentialsINSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalBytesINSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterObjectIdINSTANCE.Read(reader),
			FfiConverterOptionalUint64INSTANCE.Read(reader),
			FfiConverterOptionalInt32INSTANCE.Read(reader),
	}
}

func (c FfiConverterValidator) Lower(value Validator) C.RustBuffer {
	return LowerIntoRustBuffer[Validator](c, value)
}

func (c FfiConverterValidator) Write(writer io.Writer, value Validator) {
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.Apy);
		FfiConverterAddressINSTANCE.Write(writer, value.Address);
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.CommissionRate);
		FfiConverterOptionalValidatorCredentialsINSTANCE.Write(writer, value.Credentials);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.Description);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.ExchangeRatesSize);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.GasPrice);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.Name);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.ImageUrl);
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.NextEpochCommissionRate);
		FfiConverterOptionalValidatorCredentialsINSTANCE.Write(writer, value.NextEpochCredentials);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.NextEpochGasPrice);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.NextEpochStake);
		FfiConverterOptionalBytesINSTANCE.Write(writer, value.OperationCap);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.PendingPoolTokenWithdraw);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.PendingStake);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.PendingTotalIotaWithdraw);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.PoolTokenBalance);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.ProjectUrl);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.RewardsPool);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.StakingPoolActivationEpoch);
		FfiConverterObjectIdINSTANCE.Write(writer, value.StakingPoolId);
		FfiConverterOptionalUint64INSTANCE.Write(writer, value.StakingPoolIotaBalance);
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.VotingPower);
}

type FfiDestroyerValidator struct {}

func (_ FfiDestroyerValidator) Destroy(value Validator) {
	value.Destroy()
}
// The Validator Set for a particular epoch.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// validator-committee = u64 ; epoch
// (vector validator-committee-member)
// ```
type ValidatorCommittee struct {
	Epoch uint64
	Members []ValidatorCommitteeMember
}

func (r *ValidatorCommittee) Destroy() {
		FfiDestroyerUint64{}.Destroy(r.Epoch);
		FfiDestroyerSequenceValidatorCommitteeMember{}.Destroy(r.Members);
}

type FfiConverterValidatorCommittee struct {}

var FfiConverterValidatorCommitteeINSTANCE = FfiConverterValidatorCommittee{}

func (c FfiConverterValidatorCommittee) Lift(rb RustBufferI) ValidatorCommittee {
	return LiftFromRustBuffer[ValidatorCommittee](c, rb)
}

func (c FfiConverterValidatorCommittee) Read(reader io.Reader) ValidatorCommittee {
	return ValidatorCommittee {
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterSequenceValidatorCommitteeMemberINSTANCE.Read(reader),
	}
}

func (c FfiConverterValidatorCommittee) Lower(value ValidatorCommittee) C.RustBuffer {
	return LowerIntoRustBuffer[ValidatorCommittee](c, value)
}

func (c FfiConverterValidatorCommittee) Write(writer io.Writer, value ValidatorCommittee) {
		FfiConverterUint64INSTANCE.Write(writer, value.Epoch);
		FfiConverterSequenceValidatorCommitteeMemberINSTANCE.Write(writer, value.Members);
}

type FfiDestroyerValidatorCommittee struct {}

func (_ FfiDestroyerValidatorCommittee) Destroy(value ValidatorCommittee) {
	value.Destroy()
}
// A member of a Validator Committee
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// validator-committee-member = bls-public-key
// u64 ; stake
// ```
type ValidatorCommitteeMember struct {
	PublicKey *Bls12381PublicKey
	Stake uint64
}

func (r *ValidatorCommitteeMember) Destroy() {
		FfiDestroyerBls12381PublicKey{}.Destroy(r.PublicKey);
		FfiDestroyerUint64{}.Destroy(r.Stake);
}

type FfiConverterValidatorCommitteeMember struct {}

var FfiConverterValidatorCommitteeMemberINSTANCE = FfiConverterValidatorCommitteeMember{}

func (c FfiConverterValidatorCommitteeMember) Lift(rb RustBufferI) ValidatorCommitteeMember {
	return LiftFromRustBuffer[ValidatorCommitteeMember](c, rb)
}

func (c FfiConverterValidatorCommitteeMember) Read(reader io.Reader) ValidatorCommitteeMember {
	return ValidatorCommitteeMember {
			FfiConverterBls12381PublicKeyINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterValidatorCommitteeMember) Lower(value ValidatorCommitteeMember) C.RustBuffer {
	return LowerIntoRustBuffer[ValidatorCommitteeMember](c, value)
}

func (c FfiConverterValidatorCommitteeMember) Write(writer io.Writer, value ValidatorCommitteeMember) {
		FfiConverterBls12381PublicKeyINSTANCE.Write(writer, value.PublicKey);
		FfiConverterUint64INSTANCE.Write(writer, value.Stake);
}

type FfiDestroyerValidatorCommitteeMember struct {}

func (_ FfiDestroyerValidatorCommitteeMember) Destroy(value ValidatorCommitteeMember) {
	value.Destroy()
}
type ValidatorConnection struct {
	PageInfo PageInfo
	Nodes []Validator
}

func (r *ValidatorConnection) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceValidator{}.Destroy(r.Nodes);
}

type FfiConverterValidatorConnection struct {}

var FfiConverterValidatorConnectionINSTANCE = FfiConverterValidatorConnection{}

func (c FfiConverterValidatorConnection) Lift(rb RustBufferI) ValidatorConnection {
	return LiftFromRustBuffer[ValidatorConnection](c, rb)
}

func (c FfiConverterValidatorConnection) Read(reader io.Reader) ValidatorConnection {
	return ValidatorConnection {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceValidatorINSTANCE.Read(reader),
	}
}

func (c FfiConverterValidatorConnection) Lower(value ValidatorConnection) C.RustBuffer {
	return LowerIntoRustBuffer[ValidatorConnection](c, value)
}

func (c FfiConverterValidatorConnection) Write(writer io.Writer, value ValidatorConnection) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceValidatorINSTANCE.Write(writer, value.Nodes);
}

type FfiDestroyerValidatorConnection struct {}

func (_ FfiDestroyerValidatorConnection) Destroy(value ValidatorConnection) {
	value.Destroy()
}
// The credentials related fields associated with a validator.
type ValidatorCredentials struct {
	AuthorityPubKey *Base64
	NetworkPubKey *Base64
	ProtocolPubKey *Base64
	ProofOfPossession *Base64
	NetAddress *string
	P2pAddress *string
	PrimaryAddress *string
}

func (r *ValidatorCredentials) Destroy() {
		FfiDestroyerOptionalTypeBase64{}.Destroy(r.AuthorityPubKey);
		FfiDestroyerOptionalTypeBase64{}.Destroy(r.NetworkPubKey);
		FfiDestroyerOptionalTypeBase64{}.Destroy(r.ProtocolPubKey);
		FfiDestroyerOptionalTypeBase64{}.Destroy(r.ProofOfPossession);
		FfiDestroyerOptionalString{}.Destroy(r.NetAddress);
		FfiDestroyerOptionalString{}.Destroy(r.P2pAddress);
		FfiDestroyerOptionalString{}.Destroy(r.PrimaryAddress);
}

type FfiConverterValidatorCredentials struct {}

var FfiConverterValidatorCredentialsINSTANCE = FfiConverterValidatorCredentials{}

func (c FfiConverterValidatorCredentials) Lift(rb RustBufferI) ValidatorCredentials {
	return LiftFromRustBuffer[ValidatorCredentials](c, rb)
}

func (c FfiConverterValidatorCredentials) Read(reader io.Reader) ValidatorCredentials {
	return ValidatorCredentials {
			FfiConverterOptionalTypeBase64INSTANCE.Read(reader),
			FfiConverterOptionalTypeBase64INSTANCE.Read(reader),
			FfiConverterOptionalTypeBase64INSTANCE.Read(reader),
			FfiConverterOptionalTypeBase64INSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterValidatorCredentials) Lower(value ValidatorCredentials) C.RustBuffer {
	return LowerIntoRustBuffer[ValidatorCredentials](c, value)
}

func (c FfiConverterValidatorCredentials) Write(writer io.Writer, value ValidatorCredentials) {
		FfiConverterOptionalTypeBase64INSTANCE.Write(writer, value.AuthorityPubKey);
		FfiConverterOptionalTypeBase64INSTANCE.Write(writer, value.NetworkPubKey);
		FfiConverterOptionalTypeBase64INSTANCE.Write(writer, value.ProtocolPubKey);
		FfiConverterOptionalTypeBase64INSTANCE.Write(writer, value.ProofOfPossession);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.NetAddress);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.P2pAddress);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.PrimaryAddress);
}

type FfiDestroyerValidatorCredentials struct {}

func (_ FfiDestroyerValidatorCredentials) Destroy(value ValidatorCredentials) {
	value.Destroy()
}
// A page of items returned by the GraphQL server.
type ValidatorPage struct {
	// Information about the page, such as the cursor and whether there are
	// more pages.
	PageInfo PageInfo
	// The data returned by the server.
	Data []Validator
}

func (r *ValidatorPage) Destroy() {
		FfiDestroyerPageInfo{}.Destroy(r.PageInfo);
		FfiDestroyerSequenceValidator{}.Destroy(r.Data);
}

type FfiConverterValidatorPage struct {}

var FfiConverterValidatorPageINSTANCE = FfiConverterValidatorPage{}

func (c FfiConverterValidatorPage) Lift(rb RustBufferI) ValidatorPage {
	return LiftFromRustBuffer[ValidatorPage](c, rb)
}

func (c FfiConverterValidatorPage) Read(reader io.Reader) ValidatorPage {
	return ValidatorPage {
			FfiConverterPageInfoINSTANCE.Read(reader),
			FfiConverterSequenceValidatorINSTANCE.Read(reader),
	}
}

func (c FfiConverterValidatorPage) Lower(value ValidatorPage) C.RustBuffer {
	return LowerIntoRustBuffer[ValidatorPage](c, value)
}

func (c FfiConverterValidatorPage) Write(writer io.Writer, value ValidatorPage) {
		FfiConverterPageInfoINSTANCE.Write(writer, value.PageInfo);
		FfiConverterSequenceValidatorINSTANCE.Write(writer, value.Data);
}

type FfiDestroyerValidatorPage struct {}

func (_ FfiDestroyerValidatorPage) Destroy(value ValidatorPage) {
	value.Destroy()
}
type ValidatorSet struct {
	// Object ID of the `Table` storing the inactive staking pools.
	InactivePoolsId **ObjectId
	// Size of the inactive pools `Table`.
	InactivePoolsSize *int32
	// Object ID of the wrapped object `TableVec` storing the pending active
	// validators.
	PendingActiveValidatorsId **ObjectId
	// Size of the pending active validators table.
	PendingActiveValidatorsSize *int32
	// Validators that are pending removal from the active validator set,
	// expressed as indices in to `activeValidators`.
	PendingRemovals *[]int32
	// Object ID of the `Table` storing the mapping from staking pool ids to
	// the addresses of the corresponding validators. This is needed
	// because a validator's address can potentially change but the object
	// ID of its pool will not.
	StakingPoolMappingsId **ObjectId
	// Size of the stake pool mappings `Table`.
	StakingPoolMappingsSize *int32
	// Total amount of stake for all active validators at the beginning of the
	// epoch.
	TotalStake *string
	// Size of the validator candidates `Table`.
	ValidatorCandidatesSize *int32
	// Object ID of the `Table` storing the validator candidates.
	ValidatorCandidatesId **ObjectId
}

func (r *ValidatorSet) Destroy() {
		FfiDestroyerOptionalObjectId{}.Destroy(r.InactivePoolsId);
		FfiDestroyerOptionalInt32{}.Destroy(r.InactivePoolsSize);
		FfiDestroyerOptionalObjectId{}.Destroy(r.PendingActiveValidatorsId);
		FfiDestroyerOptionalInt32{}.Destroy(r.PendingActiveValidatorsSize);
		FfiDestroyerOptionalSequenceInt32{}.Destroy(r.PendingRemovals);
		FfiDestroyerOptionalObjectId{}.Destroy(r.StakingPoolMappingsId);
		FfiDestroyerOptionalInt32{}.Destroy(r.StakingPoolMappingsSize);
		FfiDestroyerOptionalString{}.Destroy(r.TotalStake);
		FfiDestroyerOptionalInt32{}.Destroy(r.ValidatorCandidatesSize);
		FfiDestroyerOptionalObjectId{}.Destroy(r.ValidatorCandidatesId);
}

type FfiConverterValidatorSet struct {}

var FfiConverterValidatorSetINSTANCE = FfiConverterValidatorSet{}

func (c FfiConverterValidatorSet) Lift(rb RustBufferI) ValidatorSet {
	return LiftFromRustBuffer[ValidatorSet](c, rb)
}

func (c FfiConverterValidatorSet) Read(reader io.Reader) ValidatorSet {
	return ValidatorSet {
			FfiConverterOptionalObjectIdINSTANCE.Read(reader),
			FfiConverterOptionalInt32INSTANCE.Read(reader),
			FfiConverterOptionalObjectIdINSTANCE.Read(reader),
			FfiConverterOptionalInt32INSTANCE.Read(reader),
			FfiConverterOptionalSequenceInt32INSTANCE.Read(reader),
			FfiConverterOptionalObjectIdINSTANCE.Read(reader),
			FfiConverterOptionalInt32INSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalInt32INSTANCE.Read(reader),
			FfiConverterOptionalObjectIdINSTANCE.Read(reader),
	}
}

func (c FfiConverterValidatorSet) Lower(value ValidatorSet) C.RustBuffer {
	return LowerIntoRustBuffer[ValidatorSet](c, value)
}

func (c FfiConverterValidatorSet) Write(writer io.Writer, value ValidatorSet) {
		FfiConverterOptionalObjectIdINSTANCE.Write(writer, value.InactivePoolsId);
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.InactivePoolsSize);
		FfiConverterOptionalObjectIdINSTANCE.Write(writer, value.PendingActiveValidatorsId);
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.PendingActiveValidatorsSize);
		FfiConverterOptionalSequenceInt32INSTANCE.Write(writer, value.PendingRemovals);
		FfiConverterOptionalObjectIdINSTANCE.Write(writer, value.StakingPoolMappingsId);
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.StakingPoolMappingsSize);
		FfiConverterOptionalStringINSTANCE.Write(writer, value.TotalStake);
		FfiConverterOptionalInt32INSTANCE.Write(writer, value.ValidatorCandidatesSize);
		FfiConverterOptionalObjectIdINSTANCE.Write(writer, value.ValidatorCandidatesId);
}

type FfiDestroyerValidatorSet struct {}

func (_ FfiDestroyerValidatorSet) Destroy(value ValidatorSet) {
	value.Destroy()
}
// A claim of the iss in a zklogin proof
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// zklogin-claim = string u8
// ```
type ZkLoginClaim struct {
	Value string
	IndexMod4 uint8
}

func (r *ZkLoginClaim) Destroy() {
		FfiDestroyerString{}.Destroy(r.Value);
		FfiDestroyerUint8{}.Destroy(r.IndexMod4);
}

type FfiConverterZkLoginClaim struct {}

var FfiConverterZkLoginClaimINSTANCE = FfiConverterZkLoginClaim{}

func (c FfiConverterZkLoginClaim) Lift(rb RustBufferI) ZkLoginClaim {
	return LiftFromRustBuffer[ZkLoginClaim](c, rb)
}

func (c FfiConverterZkLoginClaim) Read(reader io.Reader) ZkLoginClaim {
	return ZkLoginClaim {
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterUint8INSTANCE.Read(reader),
	}
}

func (c FfiConverterZkLoginClaim) Lower(value ZkLoginClaim) C.RustBuffer {
	return LowerIntoRustBuffer[ZkLoginClaim](c, value)
}

func (c FfiConverterZkLoginClaim) Write(writer io.Writer, value ZkLoginClaim) {
		FfiConverterStringINSTANCE.Write(writer, value.Value);
		FfiConverterUint8INSTANCE.Write(writer, value.IndexMod4);
}

type FfiDestroyerZkLoginClaim struct {}

func (_ FfiDestroyerZkLoginClaim) Destroy(value ZkLoginClaim) {
	value.Destroy()
}


type BatchSendStatusType uint

const (
	BatchSendStatusTypeInProgress BatchSendStatusType = 1
	BatchSendStatusTypeSucceeded BatchSendStatusType = 2
	BatchSendStatusTypeDiscarded BatchSendStatusType = 3
)

type FfiConverterBatchSendStatusType struct {}

var FfiConverterBatchSendStatusTypeINSTANCE = FfiConverterBatchSendStatusType{}

func (c FfiConverterBatchSendStatusType) Lift(rb RustBufferI) BatchSendStatusType {
	return LiftFromRustBuffer[BatchSendStatusType](c, rb)
}

func (c FfiConverterBatchSendStatusType) Lower(value BatchSendStatusType) C.RustBuffer {
	return LowerIntoRustBuffer[BatchSendStatusType](c, value)
}
func (FfiConverterBatchSendStatusType) Read(reader io.Reader) BatchSendStatusType {
	id := readInt32(reader)
	return BatchSendStatusType(id)
}

func (FfiConverterBatchSendStatusType) Write(writer io.Writer, value BatchSendStatusType) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerBatchSendStatusType struct {}

func (_ FfiDestroyerBatchSendStatusType) Destroy(value BatchSendStatusType) {
}


// An error with an argument to a command
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// command-argument-error =  type-mismatch
// =/ invalid-bcs-bytes
// =/ invalid-usage-of-pure-argument
// =/ invalid-argument-to-private-entry-function
// =/ index-out-of-bounds
// =/ secondary-index-out-of-bound
// =/ invalid-result-arity
// =/ invalid-gas-coin-usage
// =/ invalid-value-usage
// =/ invalid-object-by-value
// =/ invalid-object-by-mut-ref
// =/ shared-object-operation-not-allowed
//
// type-mismatch                               = %x00
// invalid-bcs-bytes                           = %x01
// invalid-usage-of-pure-argument              = %x02
// invalid-argument-to-private-entry-function  = %x03
// index-out-of-bounds                         = %x04 u16
// secondary-index-out-of-bound                = %x05 u16 u16
// invalid-result-arity                        = %x06 u16
// invalid-gas-coin-usage                      = %x07
// invalid-value-usage                         = %x08
// invalid-object-by-value                     = %x09
// invalid-object-by-mut-ref                   = %x0a
// shared-object-operation-not-allowed         = %x0b
// ```
type CommandArgumentError interface {
	Destroy()
}
// The type of the value does not match the expected type
type CommandArgumentErrorTypeMismatch struct {
}

func (e CommandArgumentErrorTypeMismatch) Destroy() {
}
// The argument cannot be deserialized into a value of the specified type
type CommandArgumentErrorInvalidBcsBytes struct {
}

func (e CommandArgumentErrorInvalidBcsBytes) Destroy() {
}
// The argument cannot be instantiated from raw bytes
type CommandArgumentErrorInvalidUsageOfPureArgument struct {
}

func (e CommandArgumentErrorInvalidUsageOfPureArgument) Destroy() {
}
// Invalid argument to private entry function.
// Private entry functions cannot take arguments from other Move functions.
type CommandArgumentErrorInvalidArgumentToPrivateEntryFunction struct {
}

func (e CommandArgumentErrorInvalidArgumentToPrivateEntryFunction) Destroy() {
}
// Out of bounds access to input or results
type CommandArgumentErrorIndexOutOfBounds struct {
	Index uint16
}

func (e CommandArgumentErrorIndexOutOfBounds) Destroy() {
		FfiDestroyerUint16{}.Destroy(e.Index);
}
// Out of bounds access to subresult
type CommandArgumentErrorSecondaryIndexOutOfBounds struct {
	Result uint16
	Subresult uint16
}

func (e CommandArgumentErrorSecondaryIndexOutOfBounds) Destroy() {
		FfiDestroyerUint16{}.Destroy(e.Result);
		FfiDestroyerUint16{}.Destroy(e.Subresult);
}
// Invalid usage of result.
// Expected a single result but found either no return value or multiple.
type CommandArgumentErrorInvalidResultArity struct {
	Result uint16
}

func (e CommandArgumentErrorInvalidResultArity) Destroy() {
		FfiDestroyerUint16{}.Destroy(e.Result);
}
// Invalid usage of Gas coin.
// The Gas coin can only be used by-value with a TransferObjects command.
type CommandArgumentErrorInvalidGasCoinUsage struct {
}

func (e CommandArgumentErrorInvalidGasCoinUsage) Destroy() {
}
// Invalid usage of move value.
type CommandArgumentErrorInvalidValueUsage struct {
}

func (e CommandArgumentErrorInvalidValueUsage) Destroy() {
}
// Immutable objects cannot be passed by-value.
type CommandArgumentErrorInvalidObjectByValue struct {
}

func (e CommandArgumentErrorInvalidObjectByValue) Destroy() {
}
// Immutable objects cannot be passed by mutable reference, &mut.
type CommandArgumentErrorInvalidObjectByMutRef struct {
}

func (e CommandArgumentErrorInvalidObjectByMutRef) Destroy() {
}
// Shared object operations such a wrapping, freezing, or converting to
// owned are not allowed.
type CommandArgumentErrorSharedObjectOperationNotAllowed struct {
}

func (e CommandArgumentErrorSharedObjectOperationNotAllowed) Destroy() {
}
// Invalid argument arity. Expected a single argument but found a result
// that expanded to multiple arguments.
type CommandArgumentErrorInvalidArgumentArity struct {
}

func (e CommandArgumentErrorInvalidArgumentArity) Destroy() {
}

type FfiConverterCommandArgumentError struct {}

var FfiConverterCommandArgumentErrorINSTANCE = FfiConverterCommandArgumentError{}

func (c FfiConverterCommandArgumentError) Lift(rb RustBufferI) CommandArgumentError {
	return LiftFromRustBuffer[CommandArgumentError](c, rb)
}

func (c FfiConverterCommandArgumentError) Lower(value CommandArgumentError) C.RustBuffer {
	return LowerIntoRustBuffer[CommandArgumentError](c, value)
}
func (FfiConverterCommandArgumentError) Read(reader io.Reader) CommandArgumentError {
	id := readInt32(reader)
	switch (id) {
		case 1:
			return CommandArgumentErrorTypeMismatch{
			};
		case 2:
			return CommandArgumentErrorInvalidBcsBytes{
			};
		case 3:
			return CommandArgumentErrorInvalidUsageOfPureArgument{
			};
		case 4:
			return CommandArgumentErrorInvalidArgumentToPrivateEntryFunction{
			};
		case 5:
			return CommandArgumentErrorIndexOutOfBounds{
				FfiConverterUint16INSTANCE.Read(reader),
			};
		case 6:
			return CommandArgumentErrorSecondaryIndexOutOfBounds{
				FfiConverterUint16INSTANCE.Read(reader),
				FfiConverterUint16INSTANCE.Read(reader),
			};
		case 7:
			return CommandArgumentErrorInvalidResultArity{
				FfiConverterUint16INSTANCE.Read(reader),
			};
		case 8:
			return CommandArgumentErrorInvalidGasCoinUsage{
			};
		case 9:
			return CommandArgumentErrorInvalidValueUsage{
			};
		case 10:
			return CommandArgumentErrorInvalidObjectByValue{
			};
		case 11:
			return CommandArgumentErrorInvalidObjectByMutRef{
			};
		case 12:
			return CommandArgumentErrorSharedObjectOperationNotAllowed{
			};
		case 13:
			return CommandArgumentErrorInvalidArgumentArity{
			};
		default:
			panic(fmt.Sprintf("invalid enum value %v in FfiConverterCommandArgumentError.Read()", id));
	}
}

func (FfiConverterCommandArgumentError) Write(writer io.Writer, value CommandArgumentError) {
	switch variant_value := value.(type) {
		case CommandArgumentErrorTypeMismatch:
			writeInt32(writer, 1)
		case CommandArgumentErrorInvalidBcsBytes:
			writeInt32(writer, 2)
		case CommandArgumentErrorInvalidUsageOfPureArgument:
			writeInt32(writer, 3)
		case CommandArgumentErrorInvalidArgumentToPrivateEntryFunction:
			writeInt32(writer, 4)
		case CommandArgumentErrorIndexOutOfBounds:
			writeInt32(writer, 5)
			FfiConverterUint16INSTANCE.Write(writer, variant_value.Index)
		case CommandArgumentErrorSecondaryIndexOutOfBounds:
			writeInt32(writer, 6)
			FfiConverterUint16INSTANCE.Write(writer, variant_value.Result)
			FfiConverterUint16INSTANCE.Write(writer, variant_value.Subresult)
		case CommandArgumentErrorInvalidResultArity:
			writeInt32(writer, 7)
			FfiConverterUint16INSTANCE.Write(writer, variant_value.Result)
		case CommandArgumentErrorInvalidGasCoinUsage:
			writeInt32(writer, 8)
		case CommandArgumentErrorInvalidValueUsage:
			writeInt32(writer, 9)
		case CommandArgumentErrorInvalidObjectByValue:
			writeInt32(writer, 10)
		case CommandArgumentErrorInvalidObjectByMutRef:
			writeInt32(writer, 11)
		case CommandArgumentErrorSharedObjectOperationNotAllowed:
			writeInt32(writer, 12)
		case CommandArgumentErrorInvalidArgumentArity:
			writeInt32(writer, 13)
		default:
			_ = variant_value
			panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterCommandArgumentError.Write", value))
	}
}

type FfiDestroyerCommandArgumentError struct {}

func (_ FfiDestroyerCommandArgumentError) Destroy(value CommandArgumentError) {
	value.Destroy()
}


// Pagination direction.
type Direction uint

const (
	DirectionForward Direction = 1
	DirectionBackward Direction = 2
)

type FfiConverterDirection struct {}

var FfiConverterDirectionINSTANCE = FfiConverterDirection{}

func (c FfiConverterDirection) Lift(rb RustBufferI) Direction {
	return LiftFromRustBuffer[Direction](c, rb)
}

func (c FfiConverterDirection) Lower(value Direction) C.RustBuffer {
	return LowerIntoRustBuffer[Direction](c, value)
}
func (FfiConverterDirection) Read(reader io.Reader) Direction {
	id := readInt32(reader)
	return Direction(id)
}

func (FfiConverterDirection) Write(writer io.Writer, value Direction) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerDirection struct {}

func (_ FfiDestroyerDirection) Destroy(value Direction) {
}


// An error that can occur during the execution of a transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
//
// execution-error =  insufficient-gas
// =/ invalid-gas-object
// =/ invariant-violation
// =/ feature-not-yet-supported
// =/ object-too-big
// =/ package-too-big
// =/ circular-object-ownership
// =/ insufficient-coin-balance
// =/ coin-balance-overflow
// =/ publish-error-non-zero-address
// =/ iota-move-verification-error
// =/ move-primitive-runtime-error
// =/ move-abort
// =/ vm-verification-or-deserialization-error
// =/ vm-invariant-violation
// =/ function-not-found
// =/ arity-mismatch
// =/ type-arity-mismatch
// =/ non-entry-function-invoked
// =/ command-argument-error
// =/ type-argument-error
// =/ unused-value-without-drop
// =/ invalid-public-function-return-type
// =/ invalid-transfer-object
// =/ effects-too-large
// =/ publish-upgrade-missing-dependency
// =/ publish-upgrade-dependency-downgrade
// =/ package-upgrade-error
// =/ written-objects-too-large
// =/ certificate-denied
// =/ iota-move-verification-timeout
// =/ shared-object-operation-not-allowed
// =/ input-object-deleted
// =/ execution-cancelled-due-to-shared-object-congestion
// =/ address-denied-for-coin
// =/ coin-type-global-pause
// =/ execution-cancelled-due-to-randomness-unavailable
//
// insufficient-gas                                    = %x00
// invalid-gas-object                                  = %x01
// invariant-violation                                 = %x02
// feature-not-yet-supported                           = %x03
// object-too-big                                      = %x04 u64 u64
// package-too-big                                     = %x05 u64 u64
// circular-object-ownership                           = %x06 object-id
// insufficient-coin-balance                           = %x07
// coin-balance-overflow                               = %x08
// publish-error-non-zero-address                      = %x09
// iota-move-verification-error                        = %x0a
// move-primitive-runtime-error                        = %x0b (option move-location)
// move-abort                                          = %x0c move-location u64
// vm-verification-or-deserialization-error            = %x0d
// vm-invariant-violation                              = %x0e
// function-not-found                                  = %x0f
// arity-mismatch                                      = %x10
// type-arity-mismatch                                 = %x11
// non-entry-function-invoked                          = %x12
// command-argument-error                              = %x13 u16 command-argument-error
// type-argument-error                                 = %x14 u16 type-argument-error
// unused-value-without-drop                           = %x15 u16 u16
// invalid-public-function-return-type                 = %x16 u16
// invalid-transfer-object                             = %x17
// effects-too-large                                   = %x18 u64 u64
// publish-upgrade-missing-dependency                  = %x19
// publish-upgrade-dependency-downgrade                = %x1a
// package-upgrade-error                               = %x1b package-upgrade-error
// written-objects-too-large                           = %x1c u64 u64
// certificate-denied                                  = %x1d
// iota-move-verification-timeout                      = %x1e
// shared-object-operation-not-allowed                 = %x1f
// input-object-deleted                                = %x20
// execution-cancelled-due-to-shared-object-congestion = %x21 (vector object-id)
// address-denied-for-coin                             = %x22 address string
// coin-type-global-pause                              = %x23 string
// execution-cancelled-due-to-randomness-unavailable   = %x24
// ```
type ExecutionError interface {
	Destroy()
}
// Insufficient Gas
type ExecutionErrorInsufficientGas struct {
}

func (e ExecutionErrorInsufficientGas) Destroy() {
}
// Invalid Gas Object.
type ExecutionErrorInvalidGasObject struct {
}

func (e ExecutionErrorInvalidGasObject) Destroy() {
}
// Invariant Violation
type ExecutionErrorInvariantViolation struct {
}

func (e ExecutionErrorInvariantViolation) Destroy() {
}
// Attempted to used feature that is not supported yet
type ExecutionErrorFeatureNotYetSupported struct {
}

func (e ExecutionErrorFeatureNotYetSupported) Destroy() {
}
// Move object is larger than the maximum allowed size
type ExecutionErrorObjectTooBig struct {
	ObjectSize uint64
	MaxObjectSize uint64
}

func (e ExecutionErrorObjectTooBig) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.ObjectSize);
		FfiDestroyerUint64{}.Destroy(e.MaxObjectSize);
}
// Package is larger than the maximum allowed size
type ExecutionErrorPackageTooBig struct {
	ObjectSize uint64
	MaxObjectSize uint64
}

func (e ExecutionErrorPackageTooBig) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.ObjectSize);
		FfiDestroyerUint64{}.Destroy(e.MaxObjectSize);
}
// Circular Object Ownership
type ExecutionErrorCircularObjectOwnership struct {
	Object *ObjectId
}

func (e ExecutionErrorCircularObjectOwnership) Destroy() {
		FfiDestroyerObjectId{}.Destroy(e.Object);
}
// Insufficient coin balance for requested operation
type ExecutionErrorInsufficientCoinBalance struct {
}

func (e ExecutionErrorInsufficientCoinBalance) Destroy() {
}
// Coin balance overflowed an u64
type ExecutionErrorCoinBalanceOverflow struct {
}

func (e ExecutionErrorCoinBalanceOverflow) Destroy() {
}
// Publish Error, Non-zero Address.
// The modules in the package must have their self-addresses set to zero.
type ExecutionErrorPublishErrorNonZeroAddress struct {
}

func (e ExecutionErrorPublishErrorNonZeroAddress) Destroy() {
}
// IOTA Move Bytecode Verification Error.
type ExecutionErrorIotaMoveVerification struct {
}

func (e ExecutionErrorIotaMoveVerification) Destroy() {
}
// Error from a non-abort instruction.
// Possible causes:
// Arithmetic error, stack overflow, max value depth, etc."
type ExecutionErrorMovePrimitiveRuntime struct {
	Location *MoveLocation
}

func (e ExecutionErrorMovePrimitiveRuntime) Destroy() {
		FfiDestroyerOptionalMoveLocation{}.Destroy(e.Location);
}
// Move runtime abort
type ExecutionErrorMoveAbort struct {
	Location MoveLocation
	Code uint64
}

func (e ExecutionErrorMoveAbort) Destroy() {
		FfiDestroyerMoveLocation{}.Destroy(e.Location);
		FfiDestroyerUint64{}.Destroy(e.Code);
}
// Bytecode verification error.
type ExecutionErrorVmVerificationOrDeserialization struct {
}

func (e ExecutionErrorVmVerificationOrDeserialization) Destroy() {
}
// MoveVm invariant violation
type ExecutionErrorVmInvariantViolation struct {
}

func (e ExecutionErrorVmInvariantViolation) Destroy() {
}
// Function not found
type ExecutionErrorFunctionNotFound struct {
}

func (e ExecutionErrorFunctionNotFound) Destroy() {
}
// Arity mismatch for Move function.
// The number of arguments does not match the number of parameters
type ExecutionErrorArityMismatch struct {
}

func (e ExecutionErrorArityMismatch) Destroy() {
}
// Type arity mismatch for Move function.
// Mismatch between the number of actual versus expected type arguments.
type ExecutionErrorTypeArityMismatch struct {
}

func (e ExecutionErrorTypeArityMismatch) Destroy() {
}
// Non Entry Function Invoked. Move Call must start with an entry function.
type ExecutionErrorNonEntryFunctionInvoked struct {
}

func (e ExecutionErrorNonEntryFunctionInvoked) Destroy() {
}
// Invalid command argument
type ExecutionErrorCommandArgument struct {
	Argument uint16
	Kind CommandArgumentError
}

func (e ExecutionErrorCommandArgument) Destroy() {
		FfiDestroyerUint16{}.Destroy(e.Argument);
		FfiDestroyerCommandArgumentError{}.Destroy(e.Kind);
}
// Type argument error
type ExecutionErrorTypeArgument struct {
	TypeArgument uint16
	Kind TypeArgumentError
}

func (e ExecutionErrorTypeArgument) Destroy() {
		FfiDestroyerUint16{}.Destroy(e.TypeArgument);
		FfiDestroyerTypeArgumentError{}.Destroy(e.Kind);
}
// Unused result without the drop ability.
type ExecutionErrorUnusedValueWithoutDrop struct {
	Result uint16
	Subresult uint16
}

func (e ExecutionErrorUnusedValueWithoutDrop) Destroy() {
		FfiDestroyerUint16{}.Destroy(e.Result);
		FfiDestroyerUint16{}.Destroy(e.Subresult);
}
// Invalid public Move function signature.
// Unsupported return type for return value
type ExecutionErrorInvalidPublicFunctionReturnType struct {
	Index uint16
}

func (e ExecutionErrorInvalidPublicFunctionReturnType) Destroy() {
		FfiDestroyerUint16{}.Destroy(e.Index);
}
// Invalid Transfer Object, object does not have public transfer.
type ExecutionErrorInvalidTransferObject struct {
}

func (e ExecutionErrorInvalidTransferObject) Destroy() {
}
// Effects from the transaction are too large
type ExecutionErrorEffectsTooLarge struct {
	CurrentSize uint64
	MaxSize uint64
}

func (e ExecutionErrorEffectsTooLarge) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.CurrentSize);
		FfiDestroyerUint64{}.Destroy(e.MaxSize);
}
// Publish or Upgrade is missing dependency
type ExecutionErrorPublishUpgradeMissingDependency struct {
}

func (e ExecutionErrorPublishUpgradeMissingDependency) Destroy() {
}
// Publish or Upgrade dependency downgrade.
//
// Indirect (transitive) dependency of published or upgraded package has
// been assigned an on-chain version that is less than the version
// required by one of the package's transitive dependencies.
type ExecutionErrorPublishUpgradeDependencyDowngrade struct {
}

func (e ExecutionErrorPublishUpgradeDependencyDowngrade) Destroy() {
}
// Invalid package upgrade
type ExecutionErrorPackageUpgrade struct {
	Kind PackageUpgradeError
}

func (e ExecutionErrorPackageUpgrade) Destroy() {
		FfiDestroyerPackageUpgradeError{}.Destroy(e.Kind);
}
// Indicates the transaction tried to write objects too large to storage
type ExecutionErrorWrittenObjectsTooLarge struct {
	ObjectSize uint64
	MaxObjectSize uint64
}

func (e ExecutionErrorWrittenObjectsTooLarge) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.ObjectSize);
		FfiDestroyerUint64{}.Destroy(e.MaxObjectSize);
}
// Certificate is on the deny list
type ExecutionErrorCertificateDenied struct {
}

func (e ExecutionErrorCertificateDenied) Destroy() {
}
// IOTA Move Bytecode verification timed out.
type ExecutionErrorIotaMoveVerificationTimeout struct {
}

func (e ExecutionErrorIotaMoveVerificationTimeout) Destroy() {
}
// The requested shared object operation is not allowed
type ExecutionErrorSharedObjectOperationNotAllowed struct {
}

func (e ExecutionErrorSharedObjectOperationNotAllowed) Destroy() {
}
// Requested shared object has been deleted
type ExecutionErrorInputObjectDeleted struct {
}

func (e ExecutionErrorInputObjectDeleted) Destroy() {
}
// Certificate is cancelled due to congestion on shared objects
type ExecutionErrorExecutionCancelledDueToSharedObjectCongestion struct {
	CongestedObjects []*ObjectId
}

func (e ExecutionErrorExecutionCancelledDueToSharedObjectCongestion) Destroy() {
		FfiDestroyerSequenceObjectId{}.Destroy(e.CongestedObjects);
}
// Certificate is cancelled due to congestion on shared objects;
// suggested gas price can be used to give this certificate more priority.
type ExecutionErrorExecutionCancelledDueToSharedObjectCongestionV2 struct {
	CongestedObjects []*ObjectId
	SuggestedGasPrice uint64
}

func (e ExecutionErrorExecutionCancelledDueToSharedObjectCongestionV2) Destroy() {
		FfiDestroyerSequenceObjectId{}.Destroy(e.CongestedObjects);
		FfiDestroyerUint64{}.Destroy(e.SuggestedGasPrice);
}
// Address is denied for this coin type
type ExecutionErrorAddressDeniedForCoin struct {
	Address *Address
	CoinType string
}

func (e ExecutionErrorAddressDeniedForCoin) Destroy() {
		FfiDestroyerAddress{}.Destroy(e.Address);
		FfiDestroyerString{}.Destroy(e.CoinType);
}
// Coin type is globally paused for use
type ExecutionErrorCoinTypeGlobalPause struct {
	CoinType string
}

func (e ExecutionErrorCoinTypeGlobalPause) Destroy() {
		FfiDestroyerString{}.Destroy(e.CoinType);
}
// Certificate is cancelled because randomness could not be generated this
// epoch
type ExecutionErrorExecutionCancelledDueToRandomnessUnavailable struct {
}

func (e ExecutionErrorExecutionCancelledDueToRandomnessUnavailable) Destroy() {
}
// A valid linkage was unable to be determined for the transaction or one
// of its commands.
type ExecutionErrorInvalidLinkage struct {
}

func (e ExecutionErrorInvalidLinkage) Destroy() {
}

type FfiConverterExecutionError struct {}

var FfiConverterExecutionErrorINSTANCE = FfiConverterExecutionError{}

func (c FfiConverterExecutionError) Lift(rb RustBufferI) ExecutionError {
	return LiftFromRustBuffer[ExecutionError](c, rb)
}

func (c FfiConverterExecutionError) Lower(value ExecutionError) C.RustBuffer {
	return LowerIntoRustBuffer[ExecutionError](c, value)
}
func (FfiConverterExecutionError) Read(reader io.Reader) ExecutionError {
	id := readInt32(reader)
	switch (id) {
		case 1:
			return ExecutionErrorInsufficientGas{
			};
		case 2:
			return ExecutionErrorInvalidGasObject{
			};
		case 3:
			return ExecutionErrorInvariantViolation{
			};
		case 4:
			return ExecutionErrorFeatureNotYetSupported{
			};
		case 5:
			return ExecutionErrorObjectTooBig{
				FfiConverterUint64INSTANCE.Read(reader),
				FfiConverterUint64INSTANCE.Read(reader),
			};
		case 6:
			return ExecutionErrorPackageTooBig{
				FfiConverterUint64INSTANCE.Read(reader),
				FfiConverterUint64INSTANCE.Read(reader),
			};
		case 7:
			return ExecutionErrorCircularObjectOwnership{
				FfiConverterObjectIdINSTANCE.Read(reader),
			};
		case 8:
			return ExecutionErrorInsufficientCoinBalance{
			};
		case 9:
			return ExecutionErrorCoinBalanceOverflow{
			};
		case 10:
			return ExecutionErrorPublishErrorNonZeroAddress{
			};
		case 11:
			return ExecutionErrorIotaMoveVerification{
			};
		case 12:
			return ExecutionErrorMovePrimitiveRuntime{
				FfiConverterOptionalMoveLocationINSTANCE.Read(reader),
			};
		case 13:
			return ExecutionErrorMoveAbort{
				FfiConverterMoveLocationINSTANCE.Read(reader),
				FfiConverterUint64INSTANCE.Read(reader),
			};
		case 14:
			return ExecutionErrorVmVerificationOrDeserialization{
			};
		case 15:
			return ExecutionErrorVmInvariantViolation{
			};
		case 16:
			return ExecutionErrorFunctionNotFound{
			};
		case 17:
			return ExecutionErrorArityMismatch{
			};
		case 18:
			return ExecutionErrorTypeArityMismatch{
			};
		case 19:
			return ExecutionErrorNonEntryFunctionInvoked{
			};
		case 20:
			return ExecutionErrorCommandArgument{
				FfiConverterUint16INSTANCE.Read(reader),
				FfiConverterCommandArgumentErrorINSTANCE.Read(reader),
			};
		case 21:
			return ExecutionErrorTypeArgument{
				FfiConverterUint16INSTANCE.Read(reader),
				FfiConverterTypeArgumentErrorINSTANCE.Read(reader),
			};
		case 22:
			return ExecutionErrorUnusedValueWithoutDrop{
				FfiConverterUint16INSTANCE.Read(reader),
				FfiConverterUint16INSTANCE.Read(reader),
			};
		case 23:
			return ExecutionErrorInvalidPublicFunctionReturnType{
				FfiConverterUint16INSTANCE.Read(reader),
			};
		case 24:
			return ExecutionErrorInvalidTransferObject{
			};
		case 25:
			return ExecutionErrorEffectsTooLarge{
				FfiConverterUint64INSTANCE.Read(reader),
				FfiConverterUint64INSTANCE.Read(reader),
			};
		case 26:
			return ExecutionErrorPublishUpgradeMissingDependency{
			};
		case 27:
			return ExecutionErrorPublishUpgradeDependencyDowngrade{
			};
		case 28:
			return ExecutionErrorPackageUpgrade{
				FfiConverterPackageUpgradeErrorINSTANCE.Read(reader),
			};
		case 29:
			return ExecutionErrorWrittenObjectsTooLarge{
				FfiConverterUint64INSTANCE.Read(reader),
				FfiConverterUint64INSTANCE.Read(reader),
			};
		case 30:
			return ExecutionErrorCertificateDenied{
			};
		case 31:
			return ExecutionErrorIotaMoveVerificationTimeout{
			};
		case 32:
			return ExecutionErrorSharedObjectOperationNotAllowed{
			};
		case 33:
			return ExecutionErrorInputObjectDeleted{
			};
		case 34:
			return ExecutionErrorExecutionCancelledDueToSharedObjectCongestion{
				FfiConverterSequenceObjectIdINSTANCE.Read(reader),
			};
		case 35:
			return ExecutionErrorExecutionCancelledDueToSharedObjectCongestionV2{
				FfiConverterSequenceObjectIdINSTANCE.Read(reader),
				FfiConverterUint64INSTANCE.Read(reader),
			};
		case 36:
			return ExecutionErrorAddressDeniedForCoin{
				FfiConverterAddressINSTANCE.Read(reader),
				FfiConverterStringINSTANCE.Read(reader),
			};
		case 37:
			return ExecutionErrorCoinTypeGlobalPause{
				FfiConverterStringINSTANCE.Read(reader),
			};
		case 38:
			return ExecutionErrorExecutionCancelledDueToRandomnessUnavailable{
			};
		case 39:
			return ExecutionErrorInvalidLinkage{
			};
		default:
			panic(fmt.Sprintf("invalid enum value %v in FfiConverterExecutionError.Read()", id));
	}
}

func (FfiConverterExecutionError) Write(writer io.Writer, value ExecutionError) {
	switch variant_value := value.(type) {
		case ExecutionErrorInsufficientGas:
			writeInt32(writer, 1)
		case ExecutionErrorInvalidGasObject:
			writeInt32(writer, 2)
		case ExecutionErrorInvariantViolation:
			writeInt32(writer, 3)
		case ExecutionErrorFeatureNotYetSupported:
			writeInt32(writer, 4)
		case ExecutionErrorObjectTooBig:
			writeInt32(writer, 5)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.ObjectSize)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.MaxObjectSize)
		case ExecutionErrorPackageTooBig:
			writeInt32(writer, 6)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.ObjectSize)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.MaxObjectSize)
		case ExecutionErrorCircularObjectOwnership:
			writeInt32(writer, 7)
			FfiConverterObjectIdINSTANCE.Write(writer, variant_value.Object)
		case ExecutionErrorInsufficientCoinBalance:
			writeInt32(writer, 8)
		case ExecutionErrorCoinBalanceOverflow:
			writeInt32(writer, 9)
		case ExecutionErrorPublishErrorNonZeroAddress:
			writeInt32(writer, 10)
		case ExecutionErrorIotaMoveVerification:
			writeInt32(writer, 11)
		case ExecutionErrorMovePrimitiveRuntime:
			writeInt32(writer, 12)
			FfiConverterOptionalMoveLocationINSTANCE.Write(writer, variant_value.Location)
		case ExecutionErrorMoveAbort:
			writeInt32(writer, 13)
			FfiConverterMoveLocationINSTANCE.Write(writer, variant_value.Location)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.Code)
		case ExecutionErrorVmVerificationOrDeserialization:
			writeInt32(writer, 14)
		case ExecutionErrorVmInvariantViolation:
			writeInt32(writer, 15)
		case ExecutionErrorFunctionNotFound:
			writeInt32(writer, 16)
		case ExecutionErrorArityMismatch:
			writeInt32(writer, 17)
		case ExecutionErrorTypeArityMismatch:
			writeInt32(writer, 18)
		case ExecutionErrorNonEntryFunctionInvoked:
			writeInt32(writer, 19)
		case ExecutionErrorCommandArgument:
			writeInt32(writer, 20)
			FfiConverterUint16INSTANCE.Write(writer, variant_value.Argument)
			FfiConverterCommandArgumentErrorINSTANCE.Write(writer, variant_value.Kind)
		case ExecutionErrorTypeArgument:
			writeInt32(writer, 21)
			FfiConverterUint16INSTANCE.Write(writer, variant_value.TypeArgument)
			FfiConverterTypeArgumentErrorINSTANCE.Write(writer, variant_value.Kind)
		case ExecutionErrorUnusedValueWithoutDrop:
			writeInt32(writer, 22)
			FfiConverterUint16INSTANCE.Write(writer, variant_value.Result)
			FfiConverterUint16INSTANCE.Write(writer, variant_value.Subresult)
		case ExecutionErrorInvalidPublicFunctionReturnType:
			writeInt32(writer, 23)
			FfiConverterUint16INSTANCE.Write(writer, variant_value.Index)
		case ExecutionErrorInvalidTransferObject:
			writeInt32(writer, 24)
		case ExecutionErrorEffectsTooLarge:
			writeInt32(writer, 25)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.CurrentSize)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.MaxSize)
		case ExecutionErrorPublishUpgradeMissingDependency:
			writeInt32(writer, 26)
		case ExecutionErrorPublishUpgradeDependencyDowngrade:
			writeInt32(writer, 27)
		case ExecutionErrorPackageUpgrade:
			writeInt32(writer, 28)
			FfiConverterPackageUpgradeErrorINSTANCE.Write(writer, variant_value.Kind)
		case ExecutionErrorWrittenObjectsTooLarge:
			writeInt32(writer, 29)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.ObjectSize)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.MaxObjectSize)
		case ExecutionErrorCertificateDenied:
			writeInt32(writer, 30)
		case ExecutionErrorIotaMoveVerificationTimeout:
			writeInt32(writer, 31)
		case ExecutionErrorSharedObjectOperationNotAllowed:
			writeInt32(writer, 32)
		case ExecutionErrorInputObjectDeleted:
			writeInt32(writer, 33)
		case ExecutionErrorExecutionCancelledDueToSharedObjectCongestion:
			writeInt32(writer, 34)
			FfiConverterSequenceObjectIdINSTANCE.Write(writer, variant_value.CongestedObjects)
		case ExecutionErrorExecutionCancelledDueToSharedObjectCongestionV2:
			writeInt32(writer, 35)
			FfiConverterSequenceObjectIdINSTANCE.Write(writer, variant_value.CongestedObjects)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.SuggestedGasPrice)
		case ExecutionErrorAddressDeniedForCoin:
			writeInt32(writer, 36)
			FfiConverterAddressINSTANCE.Write(writer, variant_value.Address)
			FfiConverterStringINSTANCE.Write(writer, variant_value.CoinType)
		case ExecutionErrorCoinTypeGlobalPause:
			writeInt32(writer, 37)
			FfiConverterStringINSTANCE.Write(writer, variant_value.CoinType)
		case ExecutionErrorExecutionCancelledDueToRandomnessUnavailable:
			writeInt32(writer, 38)
		case ExecutionErrorInvalidLinkage:
			writeInt32(writer, 39)
		default:
			_ = variant_value
			panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterExecutionError.Write", value))
	}
}

type FfiDestroyerExecutionError struct {}

func (_ FfiDestroyerExecutionError) Destroy(value ExecutionError) {
	value.Destroy()
}


// The status of an executed Transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// execution-status = success / failure
// success = %x00
// failure = %x01 execution-error (option u64)
// ```
type ExecutionStatus interface {
	Destroy()
}
// The Transaction successfully executed.
type ExecutionStatusSuccess struct {
}

func (e ExecutionStatusSuccess) Destroy() {
}
// The Transaction didn't execute successfully.
//
// Failed transactions are still committed to the blockchain but any
// intended effects are rolled back to prior to this transaction
// executing with the caveat that gas objects are still smashed and gas
// usage is still charged.
type ExecutionStatusFailure struct {
	Error ExecutionError
	Command *uint64
}

func (e ExecutionStatusFailure) Destroy() {
		FfiDestroyerExecutionError{}.Destroy(e.Error);
		FfiDestroyerOptionalUint64{}.Destroy(e.Command);
}

type FfiConverterExecutionStatus struct {}

var FfiConverterExecutionStatusINSTANCE = FfiConverterExecutionStatus{}

func (c FfiConverterExecutionStatus) Lift(rb RustBufferI) ExecutionStatus {
	return LiftFromRustBuffer[ExecutionStatus](c, rb)
}

func (c FfiConverterExecutionStatus) Lower(value ExecutionStatus) C.RustBuffer {
	return LowerIntoRustBuffer[ExecutionStatus](c, value)
}
func (FfiConverterExecutionStatus) Read(reader io.Reader) ExecutionStatus {
	id := readInt32(reader)
	switch (id) {
		case 1:
			return ExecutionStatusSuccess{
			};
		case 2:
			return ExecutionStatusFailure{
				FfiConverterExecutionErrorINSTANCE.Read(reader),
				FfiConverterOptionalUint64INSTANCE.Read(reader),
			};
		default:
			panic(fmt.Sprintf("invalid enum value %v in FfiConverterExecutionStatus.Read()", id));
	}
}

func (FfiConverterExecutionStatus) Write(writer io.Writer, value ExecutionStatus) {
	switch variant_value := value.(type) {
		case ExecutionStatusSuccess:
			writeInt32(writer, 1)
		case ExecutionStatusFailure:
			writeInt32(writer, 2)
			FfiConverterExecutionErrorINSTANCE.Write(writer, variant_value.Error)
			FfiConverterOptionalUint64INSTANCE.Write(writer, variant_value.Command)
		default:
			_ = variant_value
			panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterExecutionStatus.Write", value))
	}
}

type FfiDestroyerExecutionStatus struct {}

func (_ FfiDestroyerExecutionStatus) Destroy(value ExecutionStatus) {
	value.Destroy()
}


type Feature uint

const (
	FeatureAnalytics Feature = 1
	FeatureCoins Feature = 2
	FeatureDynamicFields Feature = 3
	FeatureSubscriptions Feature = 4
	FeatureSystemState Feature = 5
)

type FfiConverterFeature struct {}

var FfiConverterFeatureINSTANCE = FfiConverterFeature{}

func (c FfiConverterFeature) Lift(rb RustBufferI) Feature {
	return LiftFromRustBuffer[Feature](c, rb)
}

func (c FfiConverterFeature) Lower(value Feature) C.RustBuffer {
	return LowerIntoRustBuffer[Feature](c, value)
}
func (FfiConverterFeature) Read(reader io.Reader) Feature {
	id := readInt32(reader)
	return Feature(id)
}

func (FfiConverterFeature) Write(writer io.Writer, value Feature) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerFeature struct {}

func (_ FfiDestroyerFeature) Destroy(value Feature) {
}


// Defines what happened to an ObjectId during execution
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// id-operation =  id-operation-none
// =/ id-operation-created
// =/ id-operation-deleted
//
// id-operation-none       = %x00
// id-operation-created    = %x01
// id-operation-deleted    = %x02
// ```
type IdOperation uint8

const (
	IdOperationNone IdOperation = 0
	IdOperationCreated IdOperation = 1
	IdOperationDeleted IdOperation = 2
)

type FfiConverterIdOperation struct {}

var FfiConverterIdOperationINSTANCE = FfiConverterIdOperation{}

func (c FfiConverterIdOperation) Lift(rb RustBufferI) IdOperation {
	return LiftFromRustBuffer[IdOperation](c, rb)
}

func (c FfiConverterIdOperation) Lower(value IdOperation) C.RustBuffer {
	return LowerIntoRustBuffer[IdOperation](c, value)
}
func (FfiConverterIdOperation) Read(reader io.Reader) IdOperation {
	id := readInt32(reader)
	return IdOperation(id)
}

func (FfiConverterIdOperation) Write(writer io.Writer, value IdOperation) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerIdOperation struct {}

func (_ FfiDestroyerIdOperation) Destroy(value IdOperation) {
}


type MnemonicLength uint

const (
	MnemonicLengthWords12 MnemonicLength = 1
	MnemonicLengthWords24 MnemonicLength = 2
)

type FfiConverterMnemonicLength struct {}

var FfiConverterMnemonicLengthINSTANCE = FfiConverterMnemonicLength{}

func (c FfiConverterMnemonicLength) Lift(rb RustBufferI) MnemonicLength {
	return LiftFromRustBuffer[MnemonicLength](c, rb)
}

func (c FfiConverterMnemonicLength) Lower(value MnemonicLength) C.RustBuffer {
	return LowerIntoRustBuffer[MnemonicLength](c, value)
}
func (FfiConverterMnemonicLength) Read(reader io.Reader) MnemonicLength {
	id := readInt32(reader)
	return MnemonicLength(id)
}

func (FfiConverterMnemonicLength) Write(writer io.Writer, value MnemonicLength) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerMnemonicLength struct {}

func (_ FfiDestroyerMnemonicLength) Destroy(value MnemonicLength) {
}


type MoveAbility uint

const (
	MoveAbilityCopy MoveAbility = 1
	MoveAbilityDrop MoveAbility = 2
	MoveAbilityKey MoveAbility = 3
	MoveAbilityStore MoveAbility = 4
)

type FfiConverterMoveAbility struct {}

var FfiConverterMoveAbilityINSTANCE = FfiConverterMoveAbility{}

func (c FfiConverterMoveAbility) Lift(rb RustBufferI) MoveAbility {
	return LiftFromRustBuffer[MoveAbility](c, rb)
}

func (c FfiConverterMoveAbility) Lower(value MoveAbility) C.RustBuffer {
	return LowerIntoRustBuffer[MoveAbility](c, value)
}
func (FfiConverterMoveAbility) Read(reader io.Reader) MoveAbility {
	id := readInt32(reader)
	return MoveAbility(id)
}

func (FfiConverterMoveAbility) Write(writer io.Writer, value MoveAbility) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerMoveAbility struct {}

func (_ FfiDestroyerMoveAbility) Destroy(value MoveAbility) {
}


type MoveVisibility uint

const (
	MoveVisibilityPublic MoveVisibility = 1
	MoveVisibilityPrivate MoveVisibility = 2
	MoveVisibilityFriend MoveVisibility = 3
)

type FfiConverterMoveVisibility struct {}

var FfiConverterMoveVisibilityINSTANCE = FfiConverterMoveVisibility{}

func (c FfiConverterMoveVisibility) Lift(rb RustBufferI) MoveVisibility {
	return LiftFromRustBuffer[MoveVisibility](c, rb)
}

func (c FfiConverterMoveVisibility) Lower(value MoveVisibility) C.RustBuffer {
	return LowerIntoRustBuffer[MoveVisibility](c, value)
}
func (FfiConverterMoveVisibility) Read(reader io.Reader) MoveVisibility {
	id := readInt32(reader)
	return MoveVisibility(id)
}

func (FfiConverterMoveVisibility) Write(writer io.Writer, value MoveVisibility) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerMoveVisibility struct {}

func (_ FfiDestroyerMoveVisibility) Destroy(value MoveVisibility) {
}


// Two different view options for a name.
// `At` -> `test@example` | `Dot` -> `test.example.iota`
type NameFormat uint

const (
	NameFormatAt NameFormat = 1
	NameFormatDot NameFormat = 2
)

type FfiConverterNameFormat struct {}

var FfiConverterNameFormatINSTANCE = FfiConverterNameFormat{}

func (c FfiConverterNameFormat) Lift(rb RustBufferI) NameFormat {
	return LiftFromRustBuffer[NameFormat](c, rb)
}

func (c FfiConverterNameFormat) Lower(value NameFormat) C.RustBuffer {
	return LowerIntoRustBuffer[NameFormat](c, value)
}
func (FfiConverterNameFormat) Read(reader io.Reader) NameFormat {
	id := readInt32(reader)
	return NameFormat(id)
}

func (FfiConverterNameFormat) Write(writer io.Writer, value NameFormat) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerNameFormat struct {}

func (_ FfiDestroyerNameFormat) Destroy(value NameFormat) {
}


// State of an object prior to execution
//
// If an object exists (at root-level) in the store prior to this transaction,
// it should be Data, otherwise it's Missing, e.g. wrapped objects should be
// Missing.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object-in = object-in-missing / object-in-data
//
// object-in-missing = %x00
// object-in-data    = %x01 u64 digest owner
// ```
type ObjectIn interface {
	Destroy()
}
type ObjectInMissing struct {
}

func (e ObjectInMissing) Destroy() {
}
// The old version, digest and owner.
type ObjectInData struct {
	Version uint64
	Digest *Digest
	Owner *Owner
}

func (e ObjectInData) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.Version);
		FfiDestroyerDigest{}.Destroy(e.Digest);
		FfiDestroyerOwner{}.Destroy(e.Owner);
}

type FfiConverterObjectIn struct {}

var FfiConverterObjectInINSTANCE = FfiConverterObjectIn{}

func (c FfiConverterObjectIn) Lift(rb RustBufferI) ObjectIn {
	return LiftFromRustBuffer[ObjectIn](c, rb)
}

func (c FfiConverterObjectIn) Lower(value ObjectIn) C.RustBuffer {
	return LowerIntoRustBuffer[ObjectIn](c, value)
}
func (FfiConverterObjectIn) Read(reader io.Reader) ObjectIn {
	id := readInt32(reader)
	switch (id) {
		case 1:
			return ObjectInMissing{
			};
		case 2:
			return ObjectInData{
				FfiConverterUint64INSTANCE.Read(reader),
				FfiConverterDigestINSTANCE.Read(reader),
				FfiConverterOwnerINSTANCE.Read(reader),
			};
		default:
			panic(fmt.Sprintf("invalid enum value %v in FfiConverterObjectIn.Read()", id));
	}
}

func (FfiConverterObjectIn) Write(writer io.Writer, value ObjectIn) {
	switch variant_value := value.(type) {
		case ObjectInMissing:
			writeInt32(writer, 1)
		case ObjectInData:
			writeInt32(writer, 2)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.Version)
			FfiConverterDigestINSTANCE.Write(writer, variant_value.Digest)
			FfiConverterOwnerINSTANCE.Write(writer, variant_value.Owner)
		default:
			_ = variant_value
			panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterObjectIn.Write", value))
	}
}

type FfiDestroyerObjectIn struct {}

func (_ FfiDestroyerObjectIn) Destroy(value ObjectIn) {
	value.Destroy()
}


// State of an object after execution
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// object-out  =  object-out-missing
// =/ object-out-object-write
// =/ object-out-package-write
//
//
// object-out-missing        = %x00
// object-out-object-write   = %x01 digest owner
// object-out-package-write  = %x02 version digest
// ```
type ObjectOut interface {
	Destroy()
}
// Same definition as in ObjectIn.
type ObjectOutMissing struct {
}

func (e ObjectOutMissing) Destroy() {
}
// Any written object, including all of mutated, created, unwrapped today.
type ObjectOutObjectWrite struct {
	Digest *Digest
	Owner *Owner
}

func (e ObjectOutObjectWrite) Destroy() {
		FfiDestroyerDigest{}.Destroy(e.Digest);
		FfiDestroyerOwner{}.Destroy(e.Owner);
}
// Packages writes need to be tracked separately with version because
// we don't use lamport version for package publish and upgrades.
type ObjectOutPackageWrite struct {
	Version uint64
	Digest *Digest
}

func (e ObjectOutPackageWrite) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.Version);
		FfiDestroyerDigest{}.Destroy(e.Digest);
}

type FfiConverterObjectOut struct {}

var FfiConverterObjectOutINSTANCE = FfiConverterObjectOut{}

func (c FfiConverterObjectOut) Lift(rb RustBufferI) ObjectOut {
	return LiftFromRustBuffer[ObjectOut](c, rb)
}

func (c FfiConverterObjectOut) Lower(value ObjectOut) C.RustBuffer {
	return LowerIntoRustBuffer[ObjectOut](c, value)
}
func (FfiConverterObjectOut) Read(reader io.Reader) ObjectOut {
	id := readInt32(reader)
	switch (id) {
		case 1:
			return ObjectOutMissing{
			};
		case 2:
			return ObjectOutObjectWrite{
				FfiConverterDigestINSTANCE.Read(reader),
				FfiConverterOwnerINSTANCE.Read(reader),
			};
		case 3:
			return ObjectOutPackageWrite{
				FfiConverterUint64INSTANCE.Read(reader),
				FfiConverterDigestINSTANCE.Read(reader),
			};
		default:
			panic(fmt.Sprintf("invalid enum value %v in FfiConverterObjectOut.Read()", id));
	}
}

func (FfiConverterObjectOut) Write(writer io.Writer, value ObjectOut) {
	switch variant_value := value.(type) {
		case ObjectOutMissing:
			writeInt32(writer, 1)
		case ObjectOutObjectWrite:
			writeInt32(writer, 2)
			FfiConverterDigestINSTANCE.Write(writer, variant_value.Digest)
			FfiConverterOwnerINSTANCE.Write(writer, variant_value.Owner)
		case ObjectOutPackageWrite:
			writeInt32(writer, 3)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.Version)
			FfiConverterDigestINSTANCE.Write(writer, variant_value.Digest)
		default:
			_ = variant_value
			panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterObjectOut.Write", value))
	}
}

type FfiDestroyerObjectOut struct {}

func (_ FfiDestroyerObjectOut) Destroy(value ObjectOut) {
	value.Destroy()
}


// An error with a upgrading a package
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// package-upgrade-error = unable-to-fetch-package /
// not-a-package           /
// incompatible-upgrade    /
// digest-does-not-match   /
// unknown-upgrade-policy  /
// package-id-does-not-match
//
// unable-to-fetch-package     = %x00 object-id
// not-a-package               = %x01 object-id
// incompatible-upgrade        = %x02
// digest-does-not-match       = %x03 digest
// unknown-upgrade-policy      = %x04 u8
// package-id-does-not-match   = %x05 object-id object-id
// ```
type PackageUpgradeError interface {
	Destroy()
}
// Unable to fetch package
type PackageUpgradeErrorUnableToFetchPackage struct {
	PackageId *ObjectId
}

func (e PackageUpgradeErrorUnableToFetchPackage) Destroy() {
		FfiDestroyerObjectId{}.Destroy(e.PackageId);
}
// Object is not a package
type PackageUpgradeErrorNotAPackage struct {
	ObjectId *ObjectId
}

func (e PackageUpgradeErrorNotAPackage) Destroy() {
		FfiDestroyerObjectId{}.Destroy(e.ObjectId);
}
// Package upgrade is incompatible with previous version
type PackageUpgradeErrorIncompatibleUpgrade struct {
}

func (e PackageUpgradeErrorIncompatibleUpgrade) Destroy() {
}
// Digest in upgrade ticket and computed digest differ
type PackageUpgradeErrorDigestDoesNotMatch struct {
	Digest *Digest
}

func (e PackageUpgradeErrorDigestDoesNotMatch) Destroy() {
		FfiDestroyerDigest{}.Destroy(e.Digest);
}
// Upgrade policy is not valid
type PackageUpgradeErrorUnknownUpgradePolicy struct {
	Policy uint8
}

func (e PackageUpgradeErrorUnknownUpgradePolicy) Destroy() {
		FfiDestroyerUint8{}.Destroy(e.Policy);
}
// PackageId does not matach PackageId in upgrade ticket
type PackageUpgradeErrorPackageIdDoesNotMatch struct {
	PackageId *ObjectId
	TicketId *ObjectId
}

func (e PackageUpgradeErrorPackageIdDoesNotMatch) Destroy() {
		FfiDestroyerObjectId{}.Destroy(e.PackageId);
		FfiDestroyerObjectId{}.Destroy(e.TicketId);
}

type FfiConverterPackageUpgradeError struct {}

var FfiConverterPackageUpgradeErrorINSTANCE = FfiConverterPackageUpgradeError{}

func (c FfiConverterPackageUpgradeError) Lift(rb RustBufferI) PackageUpgradeError {
	return LiftFromRustBuffer[PackageUpgradeError](c, rb)
}

func (c FfiConverterPackageUpgradeError) Lower(value PackageUpgradeError) C.RustBuffer {
	return LowerIntoRustBuffer[PackageUpgradeError](c, value)
}
func (FfiConverterPackageUpgradeError) Read(reader io.Reader) PackageUpgradeError {
	id := readInt32(reader)
	switch (id) {
		case 1:
			return PackageUpgradeErrorUnableToFetchPackage{
				FfiConverterObjectIdINSTANCE.Read(reader),
			};
		case 2:
			return PackageUpgradeErrorNotAPackage{
				FfiConverterObjectIdINSTANCE.Read(reader),
			};
		case 3:
			return PackageUpgradeErrorIncompatibleUpgrade{
			};
		case 4:
			return PackageUpgradeErrorDigestDoesNotMatch{
				FfiConverterDigestINSTANCE.Read(reader),
			};
		case 5:
			return PackageUpgradeErrorUnknownUpgradePolicy{
				FfiConverterUint8INSTANCE.Read(reader),
			};
		case 6:
			return PackageUpgradeErrorPackageIdDoesNotMatch{
				FfiConverterObjectIdINSTANCE.Read(reader),
				FfiConverterObjectIdINSTANCE.Read(reader),
			};
		default:
			panic(fmt.Sprintf("invalid enum value %v in FfiConverterPackageUpgradeError.Read()", id));
	}
}

func (FfiConverterPackageUpgradeError) Write(writer io.Writer, value PackageUpgradeError) {
	switch variant_value := value.(type) {
		case PackageUpgradeErrorUnableToFetchPackage:
			writeInt32(writer, 1)
			FfiConverterObjectIdINSTANCE.Write(writer, variant_value.PackageId)
		case PackageUpgradeErrorNotAPackage:
			writeInt32(writer, 2)
			FfiConverterObjectIdINSTANCE.Write(writer, variant_value.ObjectId)
		case PackageUpgradeErrorIncompatibleUpgrade:
			writeInt32(writer, 3)
		case PackageUpgradeErrorDigestDoesNotMatch:
			writeInt32(writer, 4)
			FfiConverterDigestINSTANCE.Write(writer, variant_value.Digest)
		case PackageUpgradeErrorUnknownUpgradePolicy:
			writeInt32(writer, 5)
			FfiConverterUint8INSTANCE.Write(writer, variant_value.Policy)
		case PackageUpgradeErrorPackageIdDoesNotMatch:
			writeInt32(writer, 6)
			FfiConverterObjectIdINSTANCE.Write(writer, variant_value.PackageId)
			FfiConverterObjectIdINSTANCE.Write(writer, variant_value.TicketId)
		default:
			_ = variant_value
			panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterPackageUpgradeError.Write", value))
	}
}

type FfiDestroyerPackageUpgradeError struct {}

func (_ FfiDestroyerPackageUpgradeError) Destroy(value PackageUpgradeError) {
	value.Destroy()
}
type SdkFfiError struct {
	err error
}

// Convience method to turn *SdkFfiError into error
// Avoiding treating nil pointer as non nil error interface
func (err *SdkFfiError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err SdkFfiError) Error() string {
	return fmt.Sprintf("SdkFfiError: %s", err.err.Error())
}

func (err SdkFfiError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrSdkFfiErrorGeneric = fmt.Errorf("SdkFfiErrorGeneric")

// Variant structs
type SdkFfiErrorGeneric struct {
	message string
}
func NewSdkFfiErrorGeneric(
) *SdkFfiError {
	return &SdkFfiError { err: &SdkFfiErrorGeneric {} }
}

func (e SdkFfiErrorGeneric) destroy() {
}


func (err SdkFfiErrorGeneric) Error() string {
	return fmt.Sprintf("Generic: %s", err.message)
}

func (self SdkFfiErrorGeneric) Is(target error) bool {
	return target == ErrSdkFfiErrorGeneric
}

type FfiConverterSdkFfiError struct{}

var FfiConverterSdkFfiErrorINSTANCE = FfiConverterSdkFfiError{}

func (c FfiConverterSdkFfiError) Lift(eb RustBufferI) *SdkFfiError {
	return LiftFromRustBuffer[*SdkFfiError](c, eb)
}

func (c FfiConverterSdkFfiError) Lower(value *SdkFfiError) C.RustBuffer {
	return LowerIntoRustBuffer[*SdkFfiError](c, value)
}

func (c FfiConverterSdkFfiError) Read(reader io.Reader) *SdkFfiError {
	errorID := readUint32(reader)

	message := FfiConverterStringINSTANCE.Read(reader)
	switch errorID {
	case 1:
		return &SdkFfiError{ &SdkFfiErrorGeneric{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterSdkFfiError.Read()", errorID))
	}

	
}

func (c FfiConverterSdkFfiError) Write(writer io.Writer, value *SdkFfiError) {
	switch variantValue := value.err.(type) {
		case *SdkFfiErrorGeneric:
			writeInt32(writer, 1)
		default:
			_ = variantValue
			panic(fmt.Sprintf("invalid error value `%v` in FfiConverterSdkFfiError.Write", value))
	}
}

type FfiDestroyerSdkFfiError struct {}

func (_ FfiDestroyerSdkFfiError) Destroy(value *SdkFfiError) {
	switch variantValue := value.err.(type) {
		case SdkFfiErrorGeneric:
			variantValue.destroy()
		default:
			_ = variantValue
			panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerSdkFfiError.Destroy", value))
	}
}



// Flag use to disambiguate the signature schemes supported by IOTA.
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// signature-scheme = ed25519-flag / secp256k1-flag / secp256r1-flag /
// multisig-flag / bls-flag / zklogin-flag / passkey-flag
// ed25519-flag     = %x00
// secp256k1-flag   = %x01
// secp256r1-flag   = %x02
// multisig-flag    = %x03
// bls-flag         = %x04
// zklogin-flag     = %x05
// passkey-flag     = %x06
// ```
type SignatureScheme uint8

const (
	SignatureSchemeEd25519 SignatureScheme = 0
	SignatureSchemeSecp256k1 SignatureScheme = 1
	SignatureSchemeSecp256r1 SignatureScheme = 2
	SignatureSchemeMultisig SignatureScheme = 3
	SignatureSchemeBls12381 SignatureScheme = 4
	SignatureSchemeZkLogin SignatureScheme = 5
	SignatureSchemePasskey SignatureScheme = 6
)

type FfiConverterSignatureScheme struct {}

var FfiConverterSignatureSchemeINSTANCE = FfiConverterSignatureScheme{}

func (c FfiConverterSignatureScheme) Lift(rb RustBufferI) SignatureScheme {
	return LiftFromRustBuffer[SignatureScheme](c, rb)
}

func (c FfiConverterSignatureScheme) Lower(value SignatureScheme) C.RustBuffer {
	return LowerIntoRustBuffer[SignatureScheme](c, value)
}
func (FfiConverterSignatureScheme) Read(reader io.Reader) SignatureScheme {
	id := readInt32(reader)
	return SignatureScheme(id)
}

func (FfiConverterSignatureScheme) Write(writer io.Writer, value SignatureScheme) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerSignatureScheme struct {}

func (_ FfiDestroyerSignatureScheme) Destroy(value SignatureScheme) {
}


// A transaction argument used in programmable transactions.
type TransactionArgument interface {
	Destroy()
}
// Reference to the gas coin.
type TransactionArgumentGasCoin struct {
}

func (e TransactionArgumentGasCoin) Destroy() {
}
// An input to the programmable transaction block.
type TransactionArgumentInput struct {
	Ix uint32
}

func (e TransactionArgumentInput) Destroy() {
		FfiDestroyerUint32{}.Destroy(e.Ix);
}
// The result of another transaction command.
type TransactionArgumentResult struct {
	Cmd uint32
	Ix *uint32
}

func (e TransactionArgumentResult) Destroy() {
		FfiDestroyerUint32{}.Destroy(e.Cmd);
		FfiDestroyerOptionalUint32{}.Destroy(e.Ix);
}

type FfiConverterTransactionArgument struct {}

var FfiConverterTransactionArgumentINSTANCE = FfiConverterTransactionArgument{}

func (c FfiConverterTransactionArgument) Lift(rb RustBufferI) TransactionArgument {
	return LiftFromRustBuffer[TransactionArgument](c, rb)
}

func (c FfiConverterTransactionArgument) Lower(value TransactionArgument) C.RustBuffer {
	return LowerIntoRustBuffer[TransactionArgument](c, value)
}
func (FfiConverterTransactionArgument) Read(reader io.Reader) TransactionArgument {
	id := readInt32(reader)
	switch (id) {
		case 1:
			return TransactionArgumentGasCoin{
			};
		case 2:
			return TransactionArgumentInput{
				FfiConverterUint32INSTANCE.Read(reader),
			};
		case 3:
			return TransactionArgumentResult{
				FfiConverterUint32INSTANCE.Read(reader),
				FfiConverterOptionalUint32INSTANCE.Read(reader),
			};
		default:
			panic(fmt.Sprintf("invalid enum value %v in FfiConverterTransactionArgument.Read()", id));
	}
}

func (FfiConverterTransactionArgument) Write(writer io.Writer, value TransactionArgument) {
	switch variant_value := value.(type) {
		case TransactionArgumentGasCoin:
			writeInt32(writer, 1)
		case TransactionArgumentInput:
			writeInt32(writer, 2)
			FfiConverterUint32INSTANCE.Write(writer, variant_value.Ix)
		case TransactionArgumentResult:
			writeInt32(writer, 3)
			FfiConverterUint32INSTANCE.Write(writer, variant_value.Cmd)
			FfiConverterOptionalUint32INSTANCE.Write(writer, variant_value.Ix)
		default:
			_ = variant_value
			panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterTransactionArgument.Write", value))
	}
}

type FfiDestroyerTransactionArgument struct {}

func (_ FfiDestroyerTransactionArgument) Destroy(value TransactionArgument) {
	value.Destroy()
}


type TransactionBlockKindInput uint

const (
	TransactionBlockKindInputSystemTx TransactionBlockKindInput = 1
	TransactionBlockKindInputProgrammableTx TransactionBlockKindInput = 2
	TransactionBlockKindInputGenesis TransactionBlockKindInput = 3
	TransactionBlockKindInputConsensusCommitPrologueV1 TransactionBlockKindInput = 4
	TransactionBlockKindInputAuthenticatorStateUpdateV1 TransactionBlockKindInput = 5
	TransactionBlockKindInputRandomnessStateUpdate TransactionBlockKindInput = 6
	TransactionBlockKindInputEndOfEpochTx TransactionBlockKindInput = 7
)

type FfiConverterTransactionBlockKindInput struct {}

var FfiConverterTransactionBlockKindInputINSTANCE = FfiConverterTransactionBlockKindInput{}

func (c FfiConverterTransactionBlockKindInput) Lift(rb RustBufferI) TransactionBlockKindInput {
	return LiftFromRustBuffer[TransactionBlockKindInput](c, rb)
}

func (c FfiConverterTransactionBlockKindInput) Lower(value TransactionBlockKindInput) C.RustBuffer {
	return LowerIntoRustBuffer[TransactionBlockKindInput](c, value)
}
func (FfiConverterTransactionBlockKindInput) Read(reader io.Reader) TransactionBlockKindInput {
	id := readInt32(reader)
	return TransactionBlockKindInput(id)
}

func (FfiConverterTransactionBlockKindInput) Write(writer io.Writer, value TransactionBlockKindInput) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerTransactionBlockKindInput struct {}

func (_ FfiDestroyerTransactionBlockKindInput) Destroy(value TransactionBlockKindInput) {
}


// A TTL for a transaction
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// transaction-expiration =  %x00      ; none
// =/ %x01 u64  ; epoch
// ```
type TransactionExpiration interface {
	Destroy()
}
// The transaction has no expiration
type TransactionExpirationNone struct {
}

func (e TransactionExpirationNone) Destroy() {
}
// Validators wont sign a transaction unless the expiration Epoch
// is greater than or equal to the current epoch
type TransactionExpirationEpoch struct {
	Field0 uint64
}

func (e TransactionExpirationEpoch) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.Field0);
}

type FfiConverterTransactionExpiration struct {}

var FfiConverterTransactionExpirationINSTANCE = FfiConverterTransactionExpiration{}

func (c FfiConverterTransactionExpiration) Lift(rb RustBufferI) TransactionExpiration {
	return LiftFromRustBuffer[TransactionExpiration](c, rb)
}

func (c FfiConverterTransactionExpiration) Lower(value TransactionExpiration) C.RustBuffer {
	return LowerIntoRustBuffer[TransactionExpiration](c, value)
}
func (FfiConverterTransactionExpiration) Read(reader io.Reader) TransactionExpiration {
	id := readInt32(reader)
	switch (id) {
		case 1:
			return TransactionExpirationNone{
			};
		case 2:
			return TransactionExpirationEpoch{
				FfiConverterUint64INSTANCE.Read(reader),
			};
		default:
			panic(fmt.Sprintf("invalid enum value %v in FfiConverterTransactionExpiration.Read()", id));
	}
}

func (FfiConverterTransactionExpiration) Write(writer io.Writer, value TransactionExpiration) {
	switch variant_value := value.(type) {
		case TransactionExpirationNone:
			writeInt32(writer, 1)
		case TransactionExpirationEpoch:
			writeInt32(writer, 2)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.Field0)
		default:
			_ = variant_value
			panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterTransactionExpiration.Write", value))
	}
}

type FfiDestroyerTransactionExpiration struct {}

func (_ FfiDestroyerTransactionExpiration) Destroy(value TransactionExpiration) {
	value.Destroy()
}


// An error with a type argument
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// type-argument-error = type-not-found / constraint-not-satisfied
// type-not-found = %x00
// constraint-not-satisfied = %x01
// ```
type TypeArgumentError uint8

const (
	// A type was not found in the module specified
	TypeArgumentErrorTypeNotFound TypeArgumentError = 0
	// A type provided did not match the specified constraint
	TypeArgumentErrorConstraintNotSatisfied TypeArgumentError = 1
)

type FfiConverterTypeArgumentError struct {}

var FfiConverterTypeArgumentErrorINSTANCE = FfiConverterTypeArgumentError{}

func (c FfiConverterTypeArgumentError) Lift(rb RustBufferI) TypeArgumentError {
	return LiftFromRustBuffer[TypeArgumentError](c, rb)
}

func (c FfiConverterTypeArgumentError) Lower(value TypeArgumentError) C.RustBuffer {
	return LowerIntoRustBuffer[TypeArgumentError](c, value)
}
func (FfiConverterTypeArgumentError) Read(reader io.Reader) TypeArgumentError {
	id := readInt32(reader)
	return TypeArgumentError(id)
}

func (FfiConverterTypeArgumentError) Write(writer io.Writer, value TypeArgumentError) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerTypeArgumentError struct {}

func (_ FfiDestroyerTypeArgumentError) Destroy(value TypeArgumentError) {
}


// Type of unchanged shared object
//
// # BCS
//
// The BCS serialized form for this type is defined by the following ABNF:
//
// ```text
// unchanged-shared-object-kind =  read-only-root
// =/ mutate-deleted
// =/ read-deleted
// =/ cancelled
// =/ per-epoch-config
//
// read-only-root      = %x00 u64 digest
// mutate-deleted      = %x01 u64
// read-deleted        = %x02 u64
// cancelled           = %x03 u64
// per-epoch-config    = %x04
// ```
type UnchangedSharedKind interface {
	Destroy()
}
// Read-only shared objects from the input. We don't really need
// ObjectDigest for protocol correctness, but it will make it easier to
// verify untrusted read.
type UnchangedSharedKindReadOnlyRoot struct {
	Version uint64
	Digest *Digest
}

func (e UnchangedSharedKindReadOnlyRoot) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.Version);
		FfiDestroyerDigest{}.Destroy(e.Digest);
}
// Deleted shared objects that appear mutably/owned in the input.
type UnchangedSharedKindMutateDeleted struct {
	Version uint64
}

func (e UnchangedSharedKindMutateDeleted) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.Version);
}
// Deleted shared objects that appear as read-only in the input.
type UnchangedSharedKindReadDeleted struct {
	Version uint64
}

func (e UnchangedSharedKindReadDeleted) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.Version);
}
// Shared objects in cancelled transaction. The sequence number embed
// cancellation reason.
type UnchangedSharedKindCancelled struct {
	Version uint64
}

func (e UnchangedSharedKindCancelled) Destroy() {
		FfiDestroyerUint64{}.Destroy(e.Version);
}
// Read of a per-epoch config object that should remain the same during an
// epoch.
type UnchangedSharedKindPerEpochConfig struct {
}

func (e UnchangedSharedKindPerEpochConfig) Destroy() {
}

type FfiConverterUnchangedSharedKind struct {}

var FfiConverterUnchangedSharedKindINSTANCE = FfiConverterUnchangedSharedKind{}

func (c FfiConverterUnchangedSharedKind) Lift(rb RustBufferI) UnchangedSharedKind {
	return LiftFromRustBuffer[UnchangedSharedKind](c, rb)
}

func (c FfiConverterUnchangedSharedKind) Lower(value UnchangedSharedKind) C.RustBuffer {
	return LowerIntoRustBuffer[UnchangedSharedKind](c, value)
}
func (FfiConverterUnchangedSharedKind) Read(reader io.Reader) UnchangedSharedKind {
	id := readInt32(reader)
	switch (id) {
		case 1:
			return UnchangedSharedKindReadOnlyRoot{
				FfiConverterUint64INSTANCE.Read(reader),
				FfiConverterDigestINSTANCE.Read(reader),
			};
		case 2:
			return UnchangedSharedKindMutateDeleted{
				FfiConverterUint64INSTANCE.Read(reader),
			};
		case 3:
			return UnchangedSharedKindReadDeleted{
				FfiConverterUint64INSTANCE.Read(reader),
			};
		case 4:
			return UnchangedSharedKindCancelled{
				FfiConverterUint64INSTANCE.Read(reader),
			};
		case 5:
			return UnchangedSharedKindPerEpochConfig{
			};
		default:
			panic(fmt.Sprintf("invalid enum value %v in FfiConverterUnchangedSharedKind.Read()", id));
	}
}

func (FfiConverterUnchangedSharedKind) Write(writer io.Writer, value UnchangedSharedKind) {
	switch variant_value := value.(type) {
		case UnchangedSharedKindReadOnlyRoot:
			writeInt32(writer, 1)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.Version)
			FfiConverterDigestINSTANCE.Write(writer, variant_value.Digest)
		case UnchangedSharedKindMutateDeleted:
			writeInt32(writer, 2)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.Version)
		case UnchangedSharedKindReadDeleted:
			writeInt32(writer, 3)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.Version)
		case UnchangedSharedKindCancelled:
			writeInt32(writer, 4)
			FfiConverterUint64INSTANCE.Write(writer, variant_value.Version)
		case UnchangedSharedKindPerEpochConfig:
			writeInt32(writer, 5)
		default:
			_ = variant_value
			panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterUnchangedSharedKind.Write", value))
	}
}

type FfiDestroyerUnchangedSharedKind struct {}

func (_ FfiDestroyerUnchangedSharedKind) Destroy(value UnchangedSharedKind) {
	value.Destroy()
}


// Determines what to wait for after executing a transaction.
type WaitForTx uint

const (
	// Indicates that the transaction effects will be usable in subsequent
	// transactions, and that the transaction itself is indexed on the node.
	WaitForTxIndexed WaitForTx = 1
	// Indicates that the transaction has been included in a checkpoint, and
	// all queries may include it.
	WaitForTxFinalized WaitForTx = 2
)

type FfiConverterWaitForTx struct {}

var FfiConverterWaitForTxINSTANCE = FfiConverterWaitForTx{}

func (c FfiConverterWaitForTx) Lift(rb RustBufferI) WaitForTx {
	return LiftFromRustBuffer[WaitForTx](c, rb)
}

func (c FfiConverterWaitForTx) Lower(value WaitForTx) C.RustBuffer {
	return LowerIntoRustBuffer[WaitForTx](c, value)
}
func (FfiConverterWaitForTx) Read(reader io.Reader) WaitForTx {
	id := readInt32(reader)
	return WaitForTx(id)
}

func (FfiConverterWaitForTx) Write(writer io.Writer, value WaitForTx) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerWaitForTx struct {}

func (_ FfiDestroyerWaitForTx) Destroy(value WaitForTx) {
}

type FfiConverterOptionalUint32 struct{}

var FfiConverterOptionalUint32INSTANCE = FfiConverterOptionalUint32{}

func (c FfiConverterOptionalUint32) Lift(rb RustBufferI) *uint32 {
	return LiftFromRustBuffer[*uint32](c, rb)
}

func (_ FfiConverterOptionalUint32) Read(reader io.Reader) *uint32 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterUint32INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalUint32) Lower(value *uint32) C.RustBuffer {
	return LowerIntoRustBuffer[*uint32](c, value)
}

func (_ FfiConverterOptionalUint32) Write(writer io.Writer, value *uint32) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterUint32INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalUint32 struct {}

func (_ FfiDestroyerOptionalUint32) Destroy(value *uint32) {
	if value != nil {
		FfiDestroyerUint32{}.Destroy(*value)
	}
}

type FfiConverterOptionalInt32 struct{}

var FfiConverterOptionalInt32INSTANCE = FfiConverterOptionalInt32{}

func (c FfiConverterOptionalInt32) Lift(rb RustBufferI) *int32 {
	return LiftFromRustBuffer[*int32](c, rb)
}

func (_ FfiConverterOptionalInt32) Read(reader io.Reader) *int32 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterInt32INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalInt32) Lower(value *int32) C.RustBuffer {
	return LowerIntoRustBuffer[*int32](c, value)
}

func (_ FfiConverterOptionalInt32) Write(writer io.Writer, value *int32) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterInt32INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalInt32 struct {}

func (_ FfiDestroyerOptionalInt32) Destroy(value *int32) {
	if value != nil {
		FfiDestroyerInt32{}.Destroy(*value)
	}
}

type FfiConverterOptionalUint64 struct{}

var FfiConverterOptionalUint64INSTANCE = FfiConverterOptionalUint64{}

func (c FfiConverterOptionalUint64) Lift(rb RustBufferI) *uint64 {
	return LiftFromRustBuffer[*uint64](c, rb)
}

func (_ FfiConverterOptionalUint64) Read(reader io.Reader) *uint64 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterUint64INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalUint64) Lower(value *uint64) C.RustBuffer {
	return LowerIntoRustBuffer[*uint64](c, value)
}

func (_ FfiConverterOptionalUint64) Write(writer io.Writer, value *uint64) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterUint64INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalUint64 struct {}

func (_ FfiDestroyerOptionalUint64) Destroy(value *uint64) {
	if value != nil {
		FfiDestroyerUint64{}.Destroy(*value)
	}
}

type FfiConverterOptionalString struct{}

var FfiConverterOptionalStringINSTANCE = FfiConverterOptionalString{}

func (c FfiConverterOptionalString) Lift(rb RustBufferI) *string {
	return LiftFromRustBuffer[*string](c, rb)
}

func (_ FfiConverterOptionalString) Read(reader io.Reader) *string {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterStringINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalString) Lower(value *string) C.RustBuffer {
	return LowerIntoRustBuffer[*string](c, value)
}

func (_ FfiConverterOptionalString) Write(writer io.Writer, value *string) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalString struct {}

func (_ FfiDestroyerOptionalString) Destroy(value *string) {
	if value != nil {
		FfiDestroyerString{}.Destroy(*value)
	}
}

type FfiConverterOptionalBytes struct{}

var FfiConverterOptionalBytesINSTANCE = FfiConverterOptionalBytes{}

func (c FfiConverterOptionalBytes) Lift(rb RustBufferI) *[]byte {
	return LiftFromRustBuffer[*[]byte](c, rb)
}

func (_ FfiConverterOptionalBytes) Read(reader io.Reader) *[]byte {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterBytesINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalBytes) Lower(value *[]byte) C.RustBuffer {
	return LowerIntoRustBuffer[*[]byte](c, value)
}

func (_ FfiConverterOptionalBytes) Write(writer io.Writer, value *[]byte) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterBytesINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalBytes struct {}

func (_ FfiDestroyerOptionalBytes) Destroy(value *[]byte) {
	if value != nil {
		FfiDestroyerBytes{}.Destroy(*value)
	}
}

type FfiConverterOptionalDuration struct{}

var FfiConverterOptionalDurationINSTANCE = FfiConverterOptionalDuration{}

func (c FfiConverterOptionalDuration) Lift(rb RustBufferI) *time.Duration {
	return LiftFromRustBuffer[*time.Duration](c, rb)
}

func (_ FfiConverterOptionalDuration) Read(reader io.Reader) *time.Duration {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterDurationINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalDuration) Lower(value *time.Duration) C.RustBuffer {
	return LowerIntoRustBuffer[*time.Duration](c, value)
}

func (_ FfiConverterOptionalDuration) Write(writer io.Writer, value *time.Duration) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterDurationINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalDuration struct {}

func (_ FfiDestroyerOptionalDuration) Destroy(value *time.Duration) {
	if value != nil {
		FfiDestroyerDuration{}.Destroy(*value)
	}
}

type FfiConverterOptionalAddress struct{}

var FfiConverterOptionalAddressINSTANCE = FfiConverterOptionalAddress{}

func (c FfiConverterOptionalAddress) Lift(rb RustBufferI) **Address {
	return LiftFromRustBuffer[**Address](c, rb)
}

func (_ FfiConverterOptionalAddress) Read(reader io.Reader) **Address {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterAddressINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalAddress) Lower(value **Address) C.RustBuffer {
	return LowerIntoRustBuffer[**Address](c, value)
}

func (_ FfiConverterOptionalAddress) Write(writer io.Writer, value **Address) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterAddressINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalAddress struct {}

func (_ FfiDestroyerOptionalAddress) Destroy(value **Address) {
	if value != nil {
		FfiDestroyerAddress{}.Destroy(*value)
	}
}

type FfiConverterOptionalArgument struct{}

var FfiConverterOptionalArgumentINSTANCE = FfiConverterOptionalArgument{}

func (c FfiConverterOptionalArgument) Lift(rb RustBufferI) **Argument {
	return LiftFromRustBuffer[**Argument](c, rb)
}

func (_ FfiConverterOptionalArgument) Read(reader io.Reader) **Argument {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterArgumentINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalArgument) Lower(value **Argument) C.RustBuffer {
	return LowerIntoRustBuffer[**Argument](c, value)
}

func (_ FfiConverterOptionalArgument) Write(writer io.Writer, value **Argument) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterArgumentINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalArgument struct {}

func (_ FfiDestroyerOptionalArgument) Destroy(value **Argument) {
	if value != nil {
		FfiDestroyerArgument{}.Destroy(*value)
	}
}

type FfiConverterOptionalCheckpointSummary struct{}

var FfiConverterOptionalCheckpointSummaryINSTANCE = FfiConverterOptionalCheckpointSummary{}

func (c FfiConverterOptionalCheckpointSummary) Lift(rb RustBufferI) **CheckpointSummary {
	return LiftFromRustBuffer[**CheckpointSummary](c, rb)
}

func (_ FfiConverterOptionalCheckpointSummary) Read(reader io.Reader) **CheckpointSummary {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterCheckpointSummaryINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalCheckpointSummary) Lower(value **CheckpointSummary) C.RustBuffer {
	return LowerIntoRustBuffer[**CheckpointSummary](c, value)
}

func (_ FfiConverterOptionalCheckpointSummary) Write(writer io.Writer, value **CheckpointSummary) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterCheckpointSummaryINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalCheckpointSummary struct {}

func (_ FfiDestroyerOptionalCheckpointSummary) Destroy(value **CheckpointSummary) {
	if value != nil {
		FfiDestroyerCheckpointSummary{}.Destroy(*value)
	}
}

type FfiConverterOptionalDigest struct{}

var FfiConverterOptionalDigestINSTANCE = FfiConverterOptionalDigest{}

func (c FfiConverterOptionalDigest) Lift(rb RustBufferI) **Digest {
	return LiftFromRustBuffer[**Digest](c, rb)
}

func (_ FfiConverterOptionalDigest) Read(reader io.Reader) **Digest {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterDigestINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalDigest) Lower(value **Digest) C.RustBuffer {
	return LowerIntoRustBuffer[**Digest](c, value)
}

func (_ FfiConverterOptionalDigest) Write(writer io.Writer, value **Digest) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterDigestINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalDigest struct {}

func (_ FfiDestroyerOptionalDigest) Destroy(value **Digest) {
	if value != nil {
		FfiDestroyerDigest{}.Destroy(*value)
	}
}

type FfiConverterOptionalEd25519PublicKey struct{}

var FfiConverterOptionalEd25519PublicKeyINSTANCE = FfiConverterOptionalEd25519PublicKey{}

func (c FfiConverterOptionalEd25519PublicKey) Lift(rb RustBufferI) **Ed25519PublicKey {
	return LiftFromRustBuffer[**Ed25519PublicKey](c, rb)
}

func (_ FfiConverterOptionalEd25519PublicKey) Read(reader io.Reader) **Ed25519PublicKey {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterEd25519PublicKeyINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalEd25519PublicKey) Lower(value **Ed25519PublicKey) C.RustBuffer {
	return LowerIntoRustBuffer[**Ed25519PublicKey](c, value)
}

func (_ FfiConverterOptionalEd25519PublicKey) Write(writer io.Writer, value **Ed25519PublicKey) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterEd25519PublicKeyINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalEd25519PublicKey struct {}

func (_ FfiDestroyerOptionalEd25519PublicKey) Destroy(value **Ed25519PublicKey) {
	if value != nil {
		FfiDestroyerEd25519PublicKey{}.Destroy(*value)
	}
}

type FfiConverterOptionalEd25519Signature struct{}

var FfiConverterOptionalEd25519SignatureINSTANCE = FfiConverterOptionalEd25519Signature{}

func (c FfiConverterOptionalEd25519Signature) Lift(rb RustBufferI) **Ed25519Signature {
	return LiftFromRustBuffer[**Ed25519Signature](c, rb)
}

func (_ FfiConverterOptionalEd25519Signature) Read(reader io.Reader) **Ed25519Signature {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterEd25519SignatureINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalEd25519Signature) Lower(value **Ed25519Signature) C.RustBuffer {
	return LowerIntoRustBuffer[**Ed25519Signature](c, value)
}

func (_ FfiConverterOptionalEd25519Signature) Write(writer io.Writer, value **Ed25519Signature) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterEd25519SignatureINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalEd25519Signature struct {}

func (_ FfiDestroyerOptionalEd25519Signature) Destroy(value **Ed25519Signature) {
	if value != nil {
		FfiDestroyerEd25519Signature{}.Destroy(*value)
	}
}

type FfiConverterOptionalMoveArg struct{}

var FfiConverterOptionalMoveArgINSTANCE = FfiConverterOptionalMoveArg{}

func (c FfiConverterOptionalMoveArg) Lift(rb RustBufferI) **MoveArg {
	return LiftFromRustBuffer[**MoveArg](c, rb)
}

func (_ FfiConverterOptionalMoveArg) Read(reader io.Reader) **MoveArg {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMoveArgINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMoveArg) Lower(value **MoveArg) C.RustBuffer {
	return LowerIntoRustBuffer[**MoveArg](c, value)
}

func (_ FfiConverterOptionalMoveArg) Write(writer io.Writer, value **MoveArg) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMoveArgINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMoveArg struct {}

func (_ FfiDestroyerOptionalMoveArg) Destroy(value **MoveArg) {
	if value != nil {
		FfiDestroyerMoveArg{}.Destroy(*value)
	}
}

type FfiConverterOptionalMoveFunction struct{}

var FfiConverterOptionalMoveFunctionINSTANCE = FfiConverterOptionalMoveFunction{}

func (c FfiConverterOptionalMoveFunction) Lift(rb RustBufferI) **MoveFunction {
	return LiftFromRustBuffer[**MoveFunction](c, rb)
}

func (_ FfiConverterOptionalMoveFunction) Read(reader io.Reader) **MoveFunction {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMoveFunctionINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMoveFunction) Lower(value **MoveFunction) C.RustBuffer {
	return LowerIntoRustBuffer[**MoveFunction](c, value)
}

func (_ FfiConverterOptionalMoveFunction) Write(writer io.Writer, value **MoveFunction) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMoveFunctionINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMoveFunction struct {}

func (_ FfiDestroyerOptionalMoveFunction) Destroy(value **MoveFunction) {
	if value != nil {
		FfiDestroyerMoveFunction{}.Destroy(*value)
	}
}

type FfiConverterOptionalMovePackage struct{}

var FfiConverterOptionalMovePackageINSTANCE = FfiConverterOptionalMovePackage{}

func (c FfiConverterOptionalMovePackage) Lift(rb RustBufferI) **MovePackage {
	return LiftFromRustBuffer[**MovePackage](c, rb)
}

func (_ FfiConverterOptionalMovePackage) Read(reader io.Reader) **MovePackage {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMovePackageINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMovePackage) Lower(value **MovePackage) C.RustBuffer {
	return LowerIntoRustBuffer[**MovePackage](c, value)
}

func (_ FfiConverterOptionalMovePackage) Write(writer io.Writer, value **MovePackage) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMovePackageINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMovePackage struct {}

func (_ FfiDestroyerOptionalMovePackage) Destroy(value **MovePackage) {
	if value != nil {
		FfiDestroyerMovePackage{}.Destroy(*value)
	}
}

type FfiConverterOptionalMultisigAggregatedSignature struct{}

var FfiConverterOptionalMultisigAggregatedSignatureINSTANCE = FfiConverterOptionalMultisigAggregatedSignature{}

func (c FfiConverterOptionalMultisigAggregatedSignature) Lift(rb RustBufferI) **MultisigAggregatedSignature {
	return LiftFromRustBuffer[**MultisigAggregatedSignature](c, rb)
}

func (_ FfiConverterOptionalMultisigAggregatedSignature) Read(reader io.Reader) **MultisigAggregatedSignature {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMultisigAggregatedSignatureINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMultisigAggregatedSignature) Lower(value **MultisigAggregatedSignature) C.RustBuffer {
	return LowerIntoRustBuffer[**MultisigAggregatedSignature](c, value)
}

func (_ FfiConverterOptionalMultisigAggregatedSignature) Write(writer io.Writer, value **MultisigAggregatedSignature) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMultisigAggregatedSignatureINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMultisigAggregatedSignature struct {}

func (_ FfiDestroyerOptionalMultisigAggregatedSignature) Destroy(value **MultisigAggregatedSignature) {
	if value != nil {
		FfiDestroyerMultisigAggregatedSignature{}.Destroy(*value)
	}
}

type FfiConverterOptionalName struct{}

var FfiConverterOptionalNameINSTANCE = FfiConverterOptionalName{}

func (c FfiConverterOptionalName) Lift(rb RustBufferI) **Name {
	return LiftFromRustBuffer[**Name](c, rb)
}

func (_ FfiConverterOptionalName) Read(reader io.Reader) **Name {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterNameINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalName) Lower(value **Name) C.RustBuffer {
	return LowerIntoRustBuffer[**Name](c, value)
}

func (_ FfiConverterOptionalName) Write(writer io.Writer, value **Name) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterNameINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalName struct {}

func (_ FfiDestroyerOptionalName) Destroy(value **Name) {
	if value != nil {
		FfiDestroyerName{}.Destroy(*value)
	}
}

type FfiConverterOptionalObject struct{}

var FfiConverterOptionalObjectINSTANCE = FfiConverterOptionalObject{}

func (c FfiConverterOptionalObject) Lift(rb RustBufferI) **Object {
	return LiftFromRustBuffer[**Object](c, rb)
}

func (_ FfiConverterOptionalObject) Read(reader io.Reader) **Object {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterObjectINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalObject) Lower(value **Object) C.RustBuffer {
	return LowerIntoRustBuffer[**Object](c, value)
}

func (_ FfiConverterOptionalObject) Write(writer io.Writer, value **Object) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterObjectINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalObject struct {}

func (_ FfiDestroyerOptionalObject) Destroy(value **Object) {
	if value != nil {
		FfiDestroyerObject{}.Destroy(*value)
	}
}

type FfiConverterOptionalObjectId struct{}

var FfiConverterOptionalObjectIdINSTANCE = FfiConverterOptionalObjectId{}

func (c FfiConverterOptionalObjectId) Lift(rb RustBufferI) **ObjectId {
	return LiftFromRustBuffer[**ObjectId](c, rb)
}

func (_ FfiConverterOptionalObjectId) Read(reader io.Reader) **ObjectId {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterObjectIdINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalObjectId) Lower(value **ObjectId) C.RustBuffer {
	return LowerIntoRustBuffer[**ObjectId](c, value)
}

func (_ FfiConverterOptionalObjectId) Write(writer io.Writer, value **ObjectId) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterObjectIdINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalObjectId struct {}

func (_ FfiDestroyerOptionalObjectId) Destroy(value **ObjectId) {
	if value != nil {
		FfiDestroyerObjectId{}.Destroy(*value)
	}
}

type FfiConverterOptionalPtbArgument struct{}

var FfiConverterOptionalPtbArgumentINSTANCE = FfiConverterOptionalPtbArgument{}

func (c FfiConverterOptionalPtbArgument) Lift(rb RustBufferI) **PtbArgument {
	return LiftFromRustBuffer[**PtbArgument](c, rb)
}

func (_ FfiConverterOptionalPtbArgument) Read(reader io.Reader) **PtbArgument {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterPtbArgumentINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalPtbArgument) Lower(value **PtbArgument) C.RustBuffer {
	return LowerIntoRustBuffer[**PtbArgument](c, value)
}

func (_ FfiConverterOptionalPtbArgument) Write(writer io.Writer, value **PtbArgument) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterPtbArgumentINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalPtbArgument struct {}

func (_ FfiDestroyerOptionalPtbArgument) Destroy(value **PtbArgument) {
	if value != nil {
		FfiDestroyerPtbArgument{}.Destroy(*value)
	}
}

type FfiConverterOptionalPasskeyAuthenticator struct{}

var FfiConverterOptionalPasskeyAuthenticatorINSTANCE = FfiConverterOptionalPasskeyAuthenticator{}

func (c FfiConverterOptionalPasskeyAuthenticator) Lift(rb RustBufferI) **PasskeyAuthenticator {
	return LiftFromRustBuffer[**PasskeyAuthenticator](c, rb)
}

func (_ FfiConverterOptionalPasskeyAuthenticator) Read(reader io.Reader) **PasskeyAuthenticator {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterPasskeyAuthenticatorINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalPasskeyAuthenticator) Lower(value **PasskeyAuthenticator) C.RustBuffer {
	return LowerIntoRustBuffer[**PasskeyAuthenticator](c, value)
}

func (_ FfiConverterOptionalPasskeyAuthenticator) Write(writer io.Writer, value **PasskeyAuthenticator) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterPasskeyAuthenticatorINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalPasskeyAuthenticator struct {}

func (_ FfiDestroyerOptionalPasskeyAuthenticator) Destroy(value **PasskeyAuthenticator) {
	if value != nil {
		FfiDestroyerPasskeyAuthenticator{}.Destroy(*value)
	}
}

type FfiConverterOptionalSecp256k1PublicKey struct{}

var FfiConverterOptionalSecp256k1PublicKeyINSTANCE = FfiConverterOptionalSecp256k1PublicKey{}

func (c FfiConverterOptionalSecp256k1PublicKey) Lift(rb RustBufferI) **Secp256k1PublicKey {
	return LiftFromRustBuffer[**Secp256k1PublicKey](c, rb)
}

func (_ FfiConverterOptionalSecp256k1PublicKey) Read(reader io.Reader) **Secp256k1PublicKey {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSecp256k1PublicKeyINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSecp256k1PublicKey) Lower(value **Secp256k1PublicKey) C.RustBuffer {
	return LowerIntoRustBuffer[**Secp256k1PublicKey](c, value)
}

func (_ FfiConverterOptionalSecp256k1PublicKey) Write(writer io.Writer, value **Secp256k1PublicKey) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSecp256k1PublicKeyINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSecp256k1PublicKey struct {}

func (_ FfiDestroyerOptionalSecp256k1PublicKey) Destroy(value **Secp256k1PublicKey) {
	if value != nil {
		FfiDestroyerSecp256k1PublicKey{}.Destroy(*value)
	}
}

type FfiConverterOptionalSecp256k1Signature struct{}

var FfiConverterOptionalSecp256k1SignatureINSTANCE = FfiConverterOptionalSecp256k1Signature{}

func (c FfiConverterOptionalSecp256k1Signature) Lift(rb RustBufferI) **Secp256k1Signature {
	return LiftFromRustBuffer[**Secp256k1Signature](c, rb)
}

func (_ FfiConverterOptionalSecp256k1Signature) Read(reader io.Reader) **Secp256k1Signature {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSecp256k1SignatureINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSecp256k1Signature) Lower(value **Secp256k1Signature) C.RustBuffer {
	return LowerIntoRustBuffer[**Secp256k1Signature](c, value)
}

func (_ FfiConverterOptionalSecp256k1Signature) Write(writer io.Writer, value **Secp256k1Signature) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSecp256k1SignatureINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSecp256k1Signature struct {}

func (_ FfiDestroyerOptionalSecp256k1Signature) Destroy(value **Secp256k1Signature) {
	if value != nil {
		FfiDestroyerSecp256k1Signature{}.Destroy(*value)
	}
}

type FfiConverterOptionalSecp256r1PublicKey struct{}

var FfiConverterOptionalSecp256r1PublicKeyINSTANCE = FfiConverterOptionalSecp256r1PublicKey{}

func (c FfiConverterOptionalSecp256r1PublicKey) Lift(rb RustBufferI) **Secp256r1PublicKey {
	return LiftFromRustBuffer[**Secp256r1PublicKey](c, rb)
}

func (_ FfiConverterOptionalSecp256r1PublicKey) Read(reader io.Reader) **Secp256r1PublicKey {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSecp256r1PublicKeyINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSecp256r1PublicKey) Lower(value **Secp256r1PublicKey) C.RustBuffer {
	return LowerIntoRustBuffer[**Secp256r1PublicKey](c, value)
}

func (_ FfiConverterOptionalSecp256r1PublicKey) Write(writer io.Writer, value **Secp256r1PublicKey) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSecp256r1PublicKeyINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSecp256r1PublicKey struct {}

func (_ FfiDestroyerOptionalSecp256r1PublicKey) Destroy(value **Secp256r1PublicKey) {
	if value != nil {
		FfiDestroyerSecp256r1PublicKey{}.Destroy(*value)
	}
}

type FfiConverterOptionalSecp256r1Signature struct{}

var FfiConverterOptionalSecp256r1SignatureINSTANCE = FfiConverterOptionalSecp256r1Signature{}

func (c FfiConverterOptionalSecp256r1Signature) Lift(rb RustBufferI) **Secp256r1Signature {
	return LiftFromRustBuffer[**Secp256r1Signature](c, rb)
}

func (_ FfiConverterOptionalSecp256r1Signature) Read(reader io.Reader) **Secp256r1Signature {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSecp256r1SignatureINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSecp256r1Signature) Lower(value **Secp256r1Signature) C.RustBuffer {
	return LowerIntoRustBuffer[**Secp256r1Signature](c, value)
}

func (_ FfiConverterOptionalSecp256r1Signature) Write(writer io.Writer, value **Secp256r1Signature) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSecp256r1SignatureINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSecp256r1Signature struct {}

func (_ FfiDestroyerOptionalSecp256r1Signature) Destroy(value **Secp256r1Signature) {
	if value != nil {
		FfiDestroyerSecp256r1Signature{}.Destroy(*value)
	}
}

type FfiConverterOptionalSimpleSignature struct{}

var FfiConverterOptionalSimpleSignatureINSTANCE = FfiConverterOptionalSimpleSignature{}

func (c FfiConverterOptionalSimpleSignature) Lift(rb RustBufferI) **SimpleSignature {
	return LiftFromRustBuffer[**SimpleSignature](c, rb)
}

func (_ FfiConverterOptionalSimpleSignature) Read(reader io.Reader) **SimpleSignature {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSimpleSignatureINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSimpleSignature) Lower(value **SimpleSignature) C.RustBuffer {
	return LowerIntoRustBuffer[**SimpleSignature](c, value)
}

func (_ FfiConverterOptionalSimpleSignature) Write(writer io.Writer, value **SimpleSignature) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSimpleSignatureINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSimpleSignature struct {}

func (_ FfiDestroyerOptionalSimpleSignature) Destroy(value **SimpleSignature) {
	if value != nil {
		FfiDestroyerSimpleSignature{}.Destroy(*value)
	}
}

type FfiConverterOptionalStructTag struct{}

var FfiConverterOptionalStructTagINSTANCE = FfiConverterOptionalStructTag{}

func (c FfiConverterOptionalStructTag) Lift(rb RustBufferI) **StructTag {
	return LiftFromRustBuffer[**StructTag](c, rb)
}

func (_ FfiConverterOptionalStructTag) Read(reader io.Reader) **StructTag {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterStructTagINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalStructTag) Lower(value **StructTag) C.RustBuffer {
	return LowerIntoRustBuffer[**StructTag](c, value)
}

func (_ FfiConverterOptionalStructTag) Write(writer io.Writer, value **StructTag) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterStructTagINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalStructTag struct {}

func (_ FfiDestroyerOptionalStructTag) Destroy(value **StructTag) {
	if value != nil {
		FfiDestroyerStructTag{}.Destroy(*value)
	}
}

type FfiConverterOptionalTransactionEffects struct{}

var FfiConverterOptionalTransactionEffectsINSTANCE = FfiConverterOptionalTransactionEffects{}

func (c FfiConverterOptionalTransactionEffects) Lift(rb RustBufferI) **TransactionEffects {
	return LiftFromRustBuffer[**TransactionEffects](c, rb)
}

func (_ FfiConverterOptionalTransactionEffects) Read(reader io.Reader) **TransactionEffects {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTransactionEffectsINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTransactionEffects) Lower(value **TransactionEffects) C.RustBuffer {
	return LowerIntoRustBuffer[**TransactionEffects](c, value)
}

func (_ FfiConverterOptionalTransactionEffects) Write(writer io.Writer, value **TransactionEffects) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTransactionEffectsINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTransactionEffects struct {}

func (_ FfiDestroyerOptionalTransactionEffects) Destroy(value **TransactionEffects) {
	if value != nil {
		FfiDestroyerTransactionEffects{}.Destroy(*value)
	}
}

type FfiConverterOptionalTypeTag struct{}

var FfiConverterOptionalTypeTagINSTANCE = FfiConverterOptionalTypeTag{}

func (c FfiConverterOptionalTypeTag) Lift(rb RustBufferI) **TypeTag {
	return LiftFromRustBuffer[**TypeTag](c, rb)
}

func (_ FfiConverterOptionalTypeTag) Read(reader io.Reader) **TypeTag {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeTagINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeTag) Lower(value **TypeTag) C.RustBuffer {
	return LowerIntoRustBuffer[**TypeTag](c, value)
}

func (_ FfiConverterOptionalTypeTag) Write(writer io.Writer, value **TypeTag) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeTagINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeTag struct {}

func (_ FfiDestroyerOptionalTypeTag) Destroy(value **TypeTag) {
	if value != nil {
		FfiDestroyerTypeTag{}.Destroy(*value)
	}
}

type FfiConverterOptionalZkLoginAuthenticator struct{}

var FfiConverterOptionalZkLoginAuthenticatorINSTANCE = FfiConverterOptionalZkLoginAuthenticator{}

func (c FfiConverterOptionalZkLoginAuthenticator) Lift(rb RustBufferI) **ZkLoginAuthenticator {
	return LiftFromRustBuffer[**ZkLoginAuthenticator](c, rb)
}

func (_ FfiConverterOptionalZkLoginAuthenticator) Read(reader io.Reader) **ZkLoginAuthenticator {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterZkLoginAuthenticatorINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalZkLoginAuthenticator) Lower(value **ZkLoginAuthenticator) C.RustBuffer {
	return LowerIntoRustBuffer[**ZkLoginAuthenticator](c, value)
}

func (_ FfiConverterOptionalZkLoginAuthenticator) Write(writer io.Writer, value **ZkLoginAuthenticator) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterZkLoginAuthenticatorINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalZkLoginAuthenticator struct {}

func (_ FfiDestroyerOptionalZkLoginAuthenticator) Destroy(value **ZkLoginAuthenticator) {
	if value != nil {
		FfiDestroyerZkLoginAuthenticator{}.Destroy(*value)
	}
}

type FfiConverterOptionalZkLoginPublicIdentifier struct{}

var FfiConverterOptionalZkLoginPublicIdentifierINSTANCE = FfiConverterOptionalZkLoginPublicIdentifier{}

func (c FfiConverterOptionalZkLoginPublicIdentifier) Lift(rb RustBufferI) **ZkLoginPublicIdentifier {
	return LiftFromRustBuffer[**ZkLoginPublicIdentifier](c, rb)
}

func (_ FfiConverterOptionalZkLoginPublicIdentifier) Read(reader io.Reader) **ZkLoginPublicIdentifier {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterZkLoginPublicIdentifierINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalZkLoginPublicIdentifier) Lower(value **ZkLoginPublicIdentifier) C.RustBuffer {
	return LowerIntoRustBuffer[**ZkLoginPublicIdentifier](c, value)
}

func (_ FfiConverterOptionalZkLoginPublicIdentifier) Write(writer io.Writer, value **ZkLoginPublicIdentifier) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterZkLoginPublicIdentifierINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalZkLoginPublicIdentifier struct {}

func (_ FfiDestroyerOptionalZkLoginPublicIdentifier) Destroy(value **ZkLoginPublicIdentifier) {
	if value != nil {
		FfiDestroyerZkLoginPublicIdentifier{}.Destroy(*value)
	}
}

type FfiConverterOptionalZkloginVerifier struct{}

var FfiConverterOptionalZkloginVerifierINSTANCE = FfiConverterOptionalZkloginVerifier{}

func (c FfiConverterOptionalZkloginVerifier) Lift(rb RustBufferI) **ZkloginVerifier {
	return LiftFromRustBuffer[**ZkloginVerifier](c, rb)
}

func (_ FfiConverterOptionalZkloginVerifier) Read(reader io.Reader) **ZkloginVerifier {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterZkloginVerifierINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalZkloginVerifier) Lower(value **ZkloginVerifier) C.RustBuffer {
	return LowerIntoRustBuffer[**ZkloginVerifier](c, value)
}

func (_ FfiConverterOptionalZkloginVerifier) Write(writer io.Writer, value **ZkloginVerifier) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterZkloginVerifierINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalZkloginVerifier struct {}

func (_ FfiDestroyerOptionalZkloginVerifier) Destroy(value **ZkloginVerifier) {
	if value != nil {
		FfiDestroyerZkloginVerifier{}.Destroy(*value)
	}
}

type FfiConverterOptionalBatchSendStatus struct{}

var FfiConverterOptionalBatchSendStatusINSTANCE = FfiConverterOptionalBatchSendStatus{}

func (c FfiConverterOptionalBatchSendStatus) Lift(rb RustBufferI) *BatchSendStatus {
	return LiftFromRustBuffer[*BatchSendStatus](c, rb)
}

func (_ FfiConverterOptionalBatchSendStatus) Read(reader io.Reader) *BatchSendStatus {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterBatchSendStatusINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalBatchSendStatus) Lower(value *BatchSendStatus) C.RustBuffer {
	return LowerIntoRustBuffer[*BatchSendStatus](c, value)
}

func (_ FfiConverterOptionalBatchSendStatus) Write(writer io.Writer, value *BatchSendStatus) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterBatchSendStatusINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalBatchSendStatus struct {}

func (_ FfiDestroyerOptionalBatchSendStatus) Destroy(value *BatchSendStatus) {
	if value != nil {
		FfiDestroyerBatchSendStatus{}.Destroy(*value)
	}
}

type FfiConverterOptionalCoinMetadata struct{}

var FfiConverterOptionalCoinMetadataINSTANCE = FfiConverterOptionalCoinMetadata{}

func (c FfiConverterOptionalCoinMetadata) Lift(rb RustBufferI) *CoinMetadata {
	return LiftFromRustBuffer[*CoinMetadata](c, rb)
}

func (_ FfiConverterOptionalCoinMetadata) Read(reader io.Reader) *CoinMetadata {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterCoinMetadataINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalCoinMetadata) Lower(value *CoinMetadata) C.RustBuffer {
	return LowerIntoRustBuffer[*CoinMetadata](c, value)
}

func (_ FfiConverterOptionalCoinMetadata) Write(writer io.Writer, value *CoinMetadata) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterCoinMetadataINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalCoinMetadata struct {}

func (_ FfiDestroyerOptionalCoinMetadata) Destroy(value *CoinMetadata) {
	if value != nil {
		FfiDestroyerCoinMetadata{}.Destroy(*value)
	}
}

type FfiConverterOptionalDynamicFieldOutput struct{}

var FfiConverterOptionalDynamicFieldOutputINSTANCE = FfiConverterOptionalDynamicFieldOutput{}

func (c FfiConverterOptionalDynamicFieldOutput) Lift(rb RustBufferI) *DynamicFieldOutput {
	return LiftFromRustBuffer[*DynamicFieldOutput](c, rb)
}

func (_ FfiConverterOptionalDynamicFieldOutput) Read(reader io.Reader) *DynamicFieldOutput {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterDynamicFieldOutputINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalDynamicFieldOutput) Lower(value *DynamicFieldOutput) C.RustBuffer {
	return LowerIntoRustBuffer[*DynamicFieldOutput](c, value)
}

func (_ FfiConverterOptionalDynamicFieldOutput) Write(writer io.Writer, value *DynamicFieldOutput) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterDynamicFieldOutputINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalDynamicFieldOutput struct {}

func (_ FfiDestroyerOptionalDynamicFieldOutput) Destroy(value *DynamicFieldOutput) {
	if value != nil {
		FfiDestroyerDynamicFieldOutput{}.Destroy(*value)
	}
}

type FfiConverterOptionalDynamicFieldValue struct{}

var FfiConverterOptionalDynamicFieldValueINSTANCE = FfiConverterOptionalDynamicFieldValue{}

func (c FfiConverterOptionalDynamicFieldValue) Lift(rb RustBufferI) *DynamicFieldValue {
	return LiftFromRustBuffer[*DynamicFieldValue](c, rb)
}

func (_ FfiConverterOptionalDynamicFieldValue) Read(reader io.Reader) *DynamicFieldValue {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterDynamicFieldValueINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalDynamicFieldValue) Lower(value *DynamicFieldValue) C.RustBuffer {
	return LowerIntoRustBuffer[*DynamicFieldValue](c, value)
}

func (_ FfiConverterOptionalDynamicFieldValue) Write(writer io.Writer, value *DynamicFieldValue) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterDynamicFieldValueINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalDynamicFieldValue struct {}

func (_ FfiDestroyerOptionalDynamicFieldValue) Destroy(value *DynamicFieldValue) {
	if value != nil {
		FfiDestroyerDynamicFieldValue{}.Destroy(*value)
	}
}

type FfiConverterOptionalEndOfEpochData struct{}

var FfiConverterOptionalEndOfEpochDataINSTANCE = FfiConverterOptionalEndOfEpochData{}

func (c FfiConverterOptionalEndOfEpochData) Lift(rb RustBufferI) *EndOfEpochData {
	return LiftFromRustBuffer[*EndOfEpochData](c, rb)
}

func (_ FfiConverterOptionalEndOfEpochData) Read(reader io.Reader) *EndOfEpochData {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterEndOfEpochDataINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalEndOfEpochData) Lower(value *EndOfEpochData) C.RustBuffer {
	return LowerIntoRustBuffer[*EndOfEpochData](c, value)
}

func (_ FfiConverterOptionalEndOfEpochData) Write(writer io.Writer, value *EndOfEpochData) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterEndOfEpochDataINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalEndOfEpochData struct {}

func (_ FfiDestroyerOptionalEndOfEpochData) Destroy(value *EndOfEpochData) {
	if value != nil {
		FfiDestroyerEndOfEpochData{}.Destroy(*value)
	}
}

type FfiConverterOptionalEpoch struct{}

var FfiConverterOptionalEpochINSTANCE = FfiConverterOptionalEpoch{}

func (c FfiConverterOptionalEpoch) Lift(rb RustBufferI) *Epoch {
	return LiftFromRustBuffer[*Epoch](c, rb)
}

func (_ FfiConverterOptionalEpoch) Read(reader io.Reader) *Epoch {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterEpochINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalEpoch) Lower(value *Epoch) C.RustBuffer {
	return LowerIntoRustBuffer[*Epoch](c, value)
}

func (_ FfiConverterOptionalEpoch) Write(writer io.Writer, value *Epoch) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterEpochINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalEpoch struct {}

func (_ FfiDestroyerOptionalEpoch) Destroy(value *Epoch) {
	if value != nil {
		FfiDestroyerEpoch{}.Destroy(*value)
	}
}

type FfiConverterOptionalEventFilter struct{}

var FfiConverterOptionalEventFilterINSTANCE = FfiConverterOptionalEventFilter{}

func (c FfiConverterOptionalEventFilter) Lift(rb RustBufferI) *EventFilter {
	return LiftFromRustBuffer[*EventFilter](c, rb)
}

func (_ FfiConverterOptionalEventFilter) Read(reader io.Reader) *EventFilter {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterEventFilterINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalEventFilter) Lower(value *EventFilter) C.RustBuffer {
	return LowerIntoRustBuffer[*EventFilter](c, value)
}

func (_ FfiConverterOptionalEventFilter) Write(writer io.Writer, value *EventFilter) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterEventFilterINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalEventFilter struct {}

func (_ FfiDestroyerOptionalEventFilter) Destroy(value *EventFilter) {
	if value != nil {
		FfiDestroyerEventFilter{}.Destroy(*value)
	}
}

type FfiConverterOptionalFaucetReceipt struct{}

var FfiConverterOptionalFaucetReceiptINSTANCE = FfiConverterOptionalFaucetReceipt{}

func (c FfiConverterOptionalFaucetReceipt) Lift(rb RustBufferI) *FaucetReceipt {
	return LiftFromRustBuffer[*FaucetReceipt](c, rb)
}

func (_ FfiConverterOptionalFaucetReceipt) Read(reader io.Reader) *FaucetReceipt {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterFaucetReceiptINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalFaucetReceipt) Lower(value *FaucetReceipt) C.RustBuffer {
	return LowerIntoRustBuffer[*FaucetReceipt](c, value)
}

func (_ FfiConverterOptionalFaucetReceipt) Write(writer io.Writer, value *FaucetReceipt) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterFaucetReceiptINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalFaucetReceipt struct {}

func (_ FfiDestroyerOptionalFaucetReceipt) Destroy(value *FaucetReceipt) {
	if value != nil {
		FfiDestroyerFaucetReceipt{}.Destroy(*value)
	}
}

type FfiConverterOptionalMoveEnumConnection struct{}

var FfiConverterOptionalMoveEnumConnectionINSTANCE = FfiConverterOptionalMoveEnumConnection{}

func (c FfiConverterOptionalMoveEnumConnection) Lift(rb RustBufferI) *MoveEnumConnection {
	return LiftFromRustBuffer[*MoveEnumConnection](c, rb)
}

func (_ FfiConverterOptionalMoveEnumConnection) Read(reader io.Reader) *MoveEnumConnection {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMoveEnumConnectionINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMoveEnumConnection) Lower(value *MoveEnumConnection) C.RustBuffer {
	return LowerIntoRustBuffer[*MoveEnumConnection](c, value)
}

func (_ FfiConverterOptionalMoveEnumConnection) Write(writer io.Writer, value *MoveEnumConnection) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMoveEnumConnectionINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMoveEnumConnection struct {}

func (_ FfiDestroyerOptionalMoveEnumConnection) Destroy(value *MoveEnumConnection) {
	if value != nil {
		FfiDestroyerMoveEnumConnection{}.Destroy(*value)
	}
}

type FfiConverterOptionalMoveFunctionConnection struct{}

var FfiConverterOptionalMoveFunctionConnectionINSTANCE = FfiConverterOptionalMoveFunctionConnection{}

func (c FfiConverterOptionalMoveFunctionConnection) Lift(rb RustBufferI) *MoveFunctionConnection {
	return LiftFromRustBuffer[*MoveFunctionConnection](c, rb)
}

func (_ FfiConverterOptionalMoveFunctionConnection) Read(reader io.Reader) *MoveFunctionConnection {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMoveFunctionConnectionINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMoveFunctionConnection) Lower(value *MoveFunctionConnection) C.RustBuffer {
	return LowerIntoRustBuffer[*MoveFunctionConnection](c, value)
}

func (_ FfiConverterOptionalMoveFunctionConnection) Write(writer io.Writer, value *MoveFunctionConnection) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMoveFunctionConnectionINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMoveFunctionConnection struct {}

func (_ FfiDestroyerOptionalMoveFunctionConnection) Destroy(value *MoveFunctionConnection) {
	if value != nil {
		FfiDestroyerMoveFunctionConnection{}.Destroy(*value)
	}
}

type FfiConverterOptionalMoveLocation struct{}

var FfiConverterOptionalMoveLocationINSTANCE = FfiConverterOptionalMoveLocation{}

func (c FfiConverterOptionalMoveLocation) Lift(rb RustBufferI) *MoveLocation {
	return LiftFromRustBuffer[*MoveLocation](c, rb)
}

func (_ FfiConverterOptionalMoveLocation) Read(reader io.Reader) *MoveLocation {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMoveLocationINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMoveLocation) Lower(value *MoveLocation) C.RustBuffer {
	return LowerIntoRustBuffer[*MoveLocation](c, value)
}

func (_ FfiConverterOptionalMoveLocation) Write(writer io.Writer, value *MoveLocation) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMoveLocationINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMoveLocation struct {}

func (_ FfiDestroyerOptionalMoveLocation) Destroy(value *MoveLocation) {
	if value != nil {
		FfiDestroyerMoveLocation{}.Destroy(*value)
	}
}

type FfiConverterOptionalMoveModule struct{}

var FfiConverterOptionalMoveModuleINSTANCE = FfiConverterOptionalMoveModule{}

func (c FfiConverterOptionalMoveModule) Lift(rb RustBufferI) *MoveModule {
	return LiftFromRustBuffer[*MoveModule](c, rb)
}

func (_ FfiConverterOptionalMoveModule) Read(reader io.Reader) *MoveModule {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMoveModuleINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMoveModule) Lower(value *MoveModule) C.RustBuffer {
	return LowerIntoRustBuffer[*MoveModule](c, value)
}

func (_ FfiConverterOptionalMoveModule) Write(writer io.Writer, value *MoveModule) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMoveModuleINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMoveModule struct {}

func (_ FfiDestroyerOptionalMoveModule) Destroy(value *MoveModule) {
	if value != nil {
		FfiDestroyerMoveModule{}.Destroy(*value)
	}
}

type FfiConverterOptionalMoveStruct struct{}

var FfiConverterOptionalMoveStructINSTANCE = FfiConverterOptionalMoveStruct{}

func (c FfiConverterOptionalMoveStruct) Lift(rb RustBufferI) *MoveStruct {
	return LiftFromRustBuffer[*MoveStruct](c, rb)
}

func (_ FfiConverterOptionalMoveStruct) Read(reader io.Reader) *MoveStruct {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMoveStructINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMoveStruct) Lower(value *MoveStruct) C.RustBuffer {
	return LowerIntoRustBuffer[*MoveStruct](c, value)
}

func (_ FfiConverterOptionalMoveStruct) Write(writer io.Writer, value *MoveStruct) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMoveStructINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMoveStruct struct {}

func (_ FfiDestroyerOptionalMoveStruct) Destroy(value *MoveStruct) {
	if value != nil {
		FfiDestroyerMoveStruct{}.Destroy(*value)
	}
}

type FfiConverterOptionalMoveStructConnection struct{}

var FfiConverterOptionalMoveStructConnectionINSTANCE = FfiConverterOptionalMoveStructConnection{}

func (c FfiConverterOptionalMoveStructConnection) Lift(rb RustBufferI) *MoveStructConnection {
	return LiftFromRustBuffer[*MoveStructConnection](c, rb)
}

func (_ FfiConverterOptionalMoveStructConnection) Read(reader io.Reader) *MoveStructConnection {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMoveStructConnectionINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMoveStructConnection) Lower(value *MoveStructConnection) C.RustBuffer {
	return LowerIntoRustBuffer[*MoveStructConnection](c, value)
}

func (_ FfiConverterOptionalMoveStructConnection) Write(writer io.Writer, value *MoveStructConnection) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMoveStructConnectionINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMoveStructConnection struct {}

func (_ FfiDestroyerOptionalMoveStructConnection) Destroy(value *MoveStructConnection) {
	if value != nil {
		FfiDestroyerMoveStructConnection{}.Destroy(*value)
	}
}

type FfiConverterOptionalObjectFilter struct{}

var FfiConverterOptionalObjectFilterINSTANCE = FfiConverterOptionalObjectFilter{}

func (c FfiConverterOptionalObjectFilter) Lift(rb RustBufferI) *ObjectFilter {
	return LiftFromRustBuffer[*ObjectFilter](c, rb)
}

func (_ FfiConverterOptionalObjectFilter) Read(reader io.Reader) *ObjectFilter {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterObjectFilterINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalObjectFilter) Lower(value *ObjectFilter) C.RustBuffer {
	return LowerIntoRustBuffer[*ObjectFilter](c, value)
}

func (_ FfiConverterOptionalObjectFilter) Write(writer io.Writer, value *ObjectFilter) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterObjectFilterINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalObjectFilter struct {}

func (_ FfiDestroyerOptionalObjectFilter) Destroy(value *ObjectFilter) {
	if value != nil {
		FfiDestroyerObjectFilter{}.Destroy(*value)
	}
}

type FfiConverterOptionalOpenMoveType struct{}

var FfiConverterOptionalOpenMoveTypeINSTANCE = FfiConverterOptionalOpenMoveType{}

func (c FfiConverterOptionalOpenMoveType) Lift(rb RustBufferI) *OpenMoveType {
	return LiftFromRustBuffer[*OpenMoveType](c, rb)
}

func (_ FfiConverterOptionalOpenMoveType) Read(reader io.Reader) *OpenMoveType {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterOpenMoveTypeINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalOpenMoveType) Lower(value *OpenMoveType) C.RustBuffer {
	return LowerIntoRustBuffer[*OpenMoveType](c, value)
}

func (_ FfiConverterOptionalOpenMoveType) Write(writer io.Writer, value *OpenMoveType) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterOpenMoveTypeINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalOpenMoveType struct {}

func (_ FfiDestroyerOptionalOpenMoveType) Destroy(value *OpenMoveType) {
	if value != nil {
		FfiDestroyerOpenMoveType{}.Destroy(*value)
	}
}

type FfiConverterOptionalPaginationFilter struct{}

var FfiConverterOptionalPaginationFilterINSTANCE = FfiConverterOptionalPaginationFilter{}

func (c FfiConverterOptionalPaginationFilter) Lift(rb RustBufferI) *PaginationFilter {
	return LiftFromRustBuffer[*PaginationFilter](c, rb)
}

func (_ FfiConverterOptionalPaginationFilter) Read(reader io.Reader) *PaginationFilter {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterPaginationFilterINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalPaginationFilter) Lower(value *PaginationFilter) C.RustBuffer {
	return LowerIntoRustBuffer[*PaginationFilter](c, value)
}

func (_ FfiConverterOptionalPaginationFilter) Write(writer io.Writer, value *PaginationFilter) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterPaginationFilterINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalPaginationFilter struct {}

func (_ FfiDestroyerOptionalPaginationFilter) Destroy(value *PaginationFilter) {
	if value != nil {
		FfiDestroyerPaginationFilter{}.Destroy(*value)
	}
}

type FfiConverterOptionalProtocolConfigs struct{}

var FfiConverterOptionalProtocolConfigsINSTANCE = FfiConverterOptionalProtocolConfigs{}

func (c FfiConverterOptionalProtocolConfigs) Lift(rb RustBufferI) *ProtocolConfigs {
	return LiftFromRustBuffer[*ProtocolConfigs](c, rb)
}

func (_ FfiConverterOptionalProtocolConfigs) Read(reader io.Reader) *ProtocolConfigs {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterProtocolConfigsINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalProtocolConfigs) Lower(value *ProtocolConfigs) C.RustBuffer {
	return LowerIntoRustBuffer[*ProtocolConfigs](c, value)
}

func (_ FfiConverterOptionalProtocolConfigs) Write(writer io.Writer, value *ProtocolConfigs) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterProtocolConfigsINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalProtocolConfigs struct {}

func (_ FfiDestroyerOptionalProtocolConfigs) Destroy(value *ProtocolConfigs) {
	if value != nil {
		FfiDestroyerProtocolConfigs{}.Destroy(*value)
	}
}

type FfiConverterOptionalSignedTransaction struct{}

var FfiConverterOptionalSignedTransactionINSTANCE = FfiConverterOptionalSignedTransaction{}

func (c FfiConverterOptionalSignedTransaction) Lift(rb RustBufferI) *SignedTransaction {
	return LiftFromRustBuffer[*SignedTransaction](c, rb)
}

func (_ FfiConverterOptionalSignedTransaction) Read(reader io.Reader) *SignedTransaction {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSignedTransactionINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSignedTransaction) Lower(value *SignedTransaction) C.RustBuffer {
	return LowerIntoRustBuffer[*SignedTransaction](c, value)
}

func (_ FfiConverterOptionalSignedTransaction) Write(writer io.Writer, value *SignedTransaction) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSignedTransactionINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSignedTransaction struct {}

func (_ FfiDestroyerOptionalSignedTransaction) Destroy(value *SignedTransaction) {
	if value != nil {
		FfiDestroyerSignedTransaction{}.Destroy(*value)
	}
}

type FfiConverterOptionalTransactionDataEffects struct{}

var FfiConverterOptionalTransactionDataEffectsINSTANCE = FfiConverterOptionalTransactionDataEffects{}

func (c FfiConverterOptionalTransactionDataEffects) Lift(rb RustBufferI) *TransactionDataEffects {
	return LiftFromRustBuffer[*TransactionDataEffects](c, rb)
}

func (_ FfiConverterOptionalTransactionDataEffects) Read(reader io.Reader) *TransactionDataEffects {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTransactionDataEffectsINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTransactionDataEffects) Lower(value *TransactionDataEffects) C.RustBuffer {
	return LowerIntoRustBuffer[*TransactionDataEffects](c, value)
}

func (_ FfiConverterOptionalTransactionDataEffects) Write(writer io.Writer, value *TransactionDataEffects) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTransactionDataEffectsINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTransactionDataEffects struct {}

func (_ FfiDestroyerOptionalTransactionDataEffects) Destroy(value *TransactionDataEffects) {
	if value != nil {
		FfiDestroyerTransactionDataEffects{}.Destroy(*value)
	}
}

type FfiConverterOptionalTransactionsFilter struct{}

var FfiConverterOptionalTransactionsFilterINSTANCE = FfiConverterOptionalTransactionsFilter{}

func (c FfiConverterOptionalTransactionsFilter) Lift(rb RustBufferI) *TransactionsFilter {
	return LiftFromRustBuffer[*TransactionsFilter](c, rb)
}

func (_ FfiConverterOptionalTransactionsFilter) Read(reader io.Reader) *TransactionsFilter {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTransactionsFilterINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTransactionsFilter) Lower(value *TransactionsFilter) C.RustBuffer {
	return LowerIntoRustBuffer[*TransactionsFilter](c, value)
}

func (_ FfiConverterOptionalTransactionsFilter) Write(writer io.Writer, value *TransactionsFilter) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTransactionsFilterINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTransactionsFilter struct {}

func (_ FfiDestroyerOptionalTransactionsFilter) Destroy(value *TransactionsFilter) {
	if value != nil {
		FfiDestroyerTransactionsFilter{}.Destroy(*value)
	}
}

type FfiConverterOptionalValidatorCredentials struct{}

var FfiConverterOptionalValidatorCredentialsINSTANCE = FfiConverterOptionalValidatorCredentials{}

func (c FfiConverterOptionalValidatorCredentials) Lift(rb RustBufferI) *ValidatorCredentials {
	return LiftFromRustBuffer[*ValidatorCredentials](c, rb)
}

func (_ FfiConverterOptionalValidatorCredentials) Read(reader io.Reader) *ValidatorCredentials {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterValidatorCredentialsINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalValidatorCredentials) Lower(value *ValidatorCredentials) C.RustBuffer {
	return LowerIntoRustBuffer[*ValidatorCredentials](c, value)
}

func (_ FfiConverterOptionalValidatorCredentials) Write(writer io.Writer, value *ValidatorCredentials) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterValidatorCredentialsINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalValidatorCredentials struct {}

func (_ FfiDestroyerOptionalValidatorCredentials) Destroy(value *ValidatorCredentials) {
	if value != nil {
		FfiDestroyerValidatorCredentials{}.Destroy(*value)
	}
}

type FfiConverterOptionalValidatorSet struct{}

var FfiConverterOptionalValidatorSetINSTANCE = FfiConverterOptionalValidatorSet{}

func (c FfiConverterOptionalValidatorSet) Lift(rb RustBufferI) *ValidatorSet {
	return LiftFromRustBuffer[*ValidatorSet](c, rb)
}

func (_ FfiConverterOptionalValidatorSet) Read(reader io.Reader) *ValidatorSet {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterValidatorSetINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalValidatorSet) Lower(value *ValidatorSet) C.RustBuffer {
	return LowerIntoRustBuffer[*ValidatorSet](c, value)
}

func (_ FfiConverterOptionalValidatorSet) Write(writer io.Writer, value *ValidatorSet) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterValidatorSetINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalValidatorSet struct {}

func (_ FfiDestroyerOptionalValidatorSet) Destroy(value *ValidatorSet) {
	if value != nil {
		FfiDestroyerValidatorSet{}.Destroy(*value)
	}
}

type FfiConverterOptionalMnemonicLength struct{}

var FfiConverterOptionalMnemonicLengthINSTANCE = FfiConverterOptionalMnemonicLength{}

func (c FfiConverterOptionalMnemonicLength) Lift(rb RustBufferI) *MnemonicLength {
	return LiftFromRustBuffer[*MnemonicLength](c, rb)
}

func (_ FfiConverterOptionalMnemonicLength) Read(reader io.Reader) *MnemonicLength {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMnemonicLengthINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMnemonicLength) Lower(value *MnemonicLength) C.RustBuffer {
	return LowerIntoRustBuffer[*MnemonicLength](c, value)
}

func (_ FfiConverterOptionalMnemonicLength) Write(writer io.Writer, value *MnemonicLength) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMnemonicLengthINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMnemonicLength struct {}

func (_ FfiDestroyerOptionalMnemonicLength) Destroy(value *MnemonicLength) {
	if value != nil {
		FfiDestroyerMnemonicLength{}.Destroy(*value)
	}
}

type FfiConverterOptionalMoveVisibility struct{}

var FfiConverterOptionalMoveVisibilityINSTANCE = FfiConverterOptionalMoveVisibility{}

func (c FfiConverterOptionalMoveVisibility) Lift(rb RustBufferI) *MoveVisibility {
	return LiftFromRustBuffer[*MoveVisibility](c, rb)
}

func (_ FfiConverterOptionalMoveVisibility) Read(reader io.Reader) *MoveVisibility {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMoveVisibilityINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMoveVisibility) Lower(value *MoveVisibility) C.RustBuffer {
	return LowerIntoRustBuffer[*MoveVisibility](c, value)
}

func (_ FfiConverterOptionalMoveVisibility) Write(writer io.Writer, value *MoveVisibility) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMoveVisibilityINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMoveVisibility struct {}

func (_ FfiDestroyerOptionalMoveVisibility) Destroy(value *MoveVisibility) {
	if value != nil {
		FfiDestroyerMoveVisibility{}.Destroy(*value)
	}
}

type FfiConverterOptionalNameFormat struct{}

var FfiConverterOptionalNameFormatINSTANCE = FfiConverterOptionalNameFormat{}

func (c FfiConverterOptionalNameFormat) Lift(rb RustBufferI) *NameFormat {
	return LiftFromRustBuffer[*NameFormat](c, rb)
}

func (_ FfiConverterOptionalNameFormat) Read(reader io.Reader) *NameFormat {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterNameFormatINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalNameFormat) Lower(value *NameFormat) C.RustBuffer {
	return LowerIntoRustBuffer[*NameFormat](c, value)
}

func (_ FfiConverterOptionalNameFormat) Write(writer io.Writer, value *NameFormat) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterNameFormatINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalNameFormat struct {}

func (_ FfiDestroyerOptionalNameFormat) Destroy(value *NameFormat) {
	if value != nil {
		FfiDestroyerNameFormat{}.Destroy(*value)
	}
}

type FfiConverterOptionalTransactionBlockKindInput struct{}

var FfiConverterOptionalTransactionBlockKindInputINSTANCE = FfiConverterOptionalTransactionBlockKindInput{}

func (c FfiConverterOptionalTransactionBlockKindInput) Lift(rb RustBufferI) *TransactionBlockKindInput {
	return LiftFromRustBuffer[*TransactionBlockKindInput](c, rb)
}

func (_ FfiConverterOptionalTransactionBlockKindInput) Read(reader io.Reader) *TransactionBlockKindInput {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTransactionBlockKindInputINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTransactionBlockKindInput) Lower(value *TransactionBlockKindInput) C.RustBuffer {
	return LowerIntoRustBuffer[*TransactionBlockKindInput](c, value)
}

func (_ FfiConverterOptionalTransactionBlockKindInput) Write(writer io.Writer, value *TransactionBlockKindInput) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTransactionBlockKindInputINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTransactionBlockKindInput struct {}

func (_ FfiDestroyerOptionalTransactionBlockKindInput) Destroy(value *TransactionBlockKindInput) {
	if value != nil {
		FfiDestroyerTransactionBlockKindInput{}.Destroy(*value)
	}
}

type FfiConverterOptionalWaitForTx struct{}

var FfiConverterOptionalWaitForTxINSTANCE = FfiConverterOptionalWaitForTx{}

func (c FfiConverterOptionalWaitForTx) Lift(rb RustBufferI) *WaitForTx {
	return LiftFromRustBuffer[*WaitForTx](c, rb)
}

func (_ FfiConverterOptionalWaitForTx) Read(reader io.Reader) *WaitForTx {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterWaitForTxINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalWaitForTx) Lower(value *WaitForTx) C.RustBuffer {
	return LowerIntoRustBuffer[*WaitForTx](c, value)
}

func (_ FfiConverterOptionalWaitForTx) Write(writer io.Writer, value *WaitForTx) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterWaitForTxINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalWaitForTx struct {}

func (_ FfiDestroyerOptionalWaitForTx) Destroy(value *WaitForTx) {
	if value != nil {
		FfiDestroyerWaitForTx{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceInt32 struct{}

var FfiConverterOptionalSequenceInt32INSTANCE = FfiConverterOptionalSequenceInt32{}

func (c FfiConverterOptionalSequenceInt32) Lift(rb RustBufferI) *[]int32 {
	return LiftFromRustBuffer[*[]int32](c, rb)
}

func (_ FfiConverterOptionalSequenceInt32) Read(reader io.Reader) *[]int32 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceInt32INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceInt32) Lower(value *[]int32) C.RustBuffer {
	return LowerIntoRustBuffer[*[]int32](c, value)
}

func (_ FfiConverterOptionalSequenceInt32) Write(writer io.Writer, value *[]int32) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceInt32INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceInt32 struct {}

func (_ FfiDestroyerOptionalSequenceInt32) Destroy(value *[]int32) {
	if value != nil {
		FfiDestroyerSequenceInt32{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceString struct{}

var FfiConverterOptionalSequenceStringINSTANCE = FfiConverterOptionalSequenceString{}

func (c FfiConverterOptionalSequenceString) Lift(rb RustBufferI) *[]string {
	return LiftFromRustBuffer[*[]string](c, rb)
}

func (_ FfiConverterOptionalSequenceString) Read(reader io.Reader) *[]string {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceStringINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceString) Lower(value *[]string) C.RustBuffer {
	return LowerIntoRustBuffer[*[]string](c, value)
}

func (_ FfiConverterOptionalSequenceString) Write(writer io.Writer, value *[]string) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceStringINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceString struct {}

func (_ FfiDestroyerOptionalSequenceString) Destroy(value *[]string) {
	if value != nil {
		FfiDestroyerSequenceString{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceObjectId struct{}

var FfiConverterOptionalSequenceObjectIdINSTANCE = FfiConverterOptionalSequenceObjectId{}

func (c FfiConverterOptionalSequenceObjectId) Lift(rb RustBufferI) *[]*ObjectId {
	return LiftFromRustBuffer[*[]*ObjectId](c, rb)
}

func (_ FfiConverterOptionalSequenceObjectId) Read(reader io.Reader) *[]*ObjectId {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceObjectIdINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceObjectId) Lower(value *[]*ObjectId) C.RustBuffer {
	return LowerIntoRustBuffer[*[]*ObjectId](c, value)
}

func (_ FfiConverterOptionalSequenceObjectId) Write(writer io.Writer, value *[]*ObjectId) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceObjectIdINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceObjectId struct {}

func (_ FfiDestroyerOptionalSequenceObjectId) Destroy(value *[]*ObjectId) {
	if value != nil {
		FfiDestroyerSequenceObjectId{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceMoveEnumVariant struct{}

var FfiConverterOptionalSequenceMoveEnumVariantINSTANCE = FfiConverterOptionalSequenceMoveEnumVariant{}

func (c FfiConverterOptionalSequenceMoveEnumVariant) Lift(rb RustBufferI) *[]MoveEnumVariant {
	return LiftFromRustBuffer[*[]MoveEnumVariant](c, rb)
}

func (_ FfiConverterOptionalSequenceMoveEnumVariant) Read(reader io.Reader) *[]MoveEnumVariant {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceMoveEnumVariantINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceMoveEnumVariant) Lower(value *[]MoveEnumVariant) C.RustBuffer {
	return LowerIntoRustBuffer[*[]MoveEnumVariant](c, value)
}

func (_ FfiConverterOptionalSequenceMoveEnumVariant) Write(writer io.Writer, value *[]MoveEnumVariant) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceMoveEnumVariantINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceMoveEnumVariant struct {}

func (_ FfiDestroyerOptionalSequenceMoveEnumVariant) Destroy(value *[]MoveEnumVariant) {
	if value != nil {
		FfiDestroyerSequenceMoveEnumVariant{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceMoveField struct{}

var FfiConverterOptionalSequenceMoveFieldINSTANCE = FfiConverterOptionalSequenceMoveField{}

func (c FfiConverterOptionalSequenceMoveField) Lift(rb RustBufferI) *[]MoveField {
	return LiftFromRustBuffer[*[]MoveField](c, rb)
}

func (_ FfiConverterOptionalSequenceMoveField) Read(reader io.Reader) *[]MoveField {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceMoveFieldINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceMoveField) Lower(value *[]MoveField) C.RustBuffer {
	return LowerIntoRustBuffer[*[]MoveField](c, value)
}

func (_ FfiConverterOptionalSequenceMoveField) Write(writer io.Writer, value *[]MoveField) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceMoveFieldINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceMoveField struct {}

func (_ FfiDestroyerOptionalSequenceMoveField) Destroy(value *[]MoveField) {
	if value != nil {
		FfiDestroyerSequenceMoveField{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceMoveFunctionTypeParameter struct{}

var FfiConverterOptionalSequenceMoveFunctionTypeParameterINSTANCE = FfiConverterOptionalSequenceMoveFunctionTypeParameter{}

func (c FfiConverterOptionalSequenceMoveFunctionTypeParameter) Lift(rb RustBufferI) *[]MoveFunctionTypeParameter {
	return LiftFromRustBuffer[*[]MoveFunctionTypeParameter](c, rb)
}

func (_ FfiConverterOptionalSequenceMoveFunctionTypeParameter) Read(reader io.Reader) *[]MoveFunctionTypeParameter {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceMoveFunctionTypeParameterINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceMoveFunctionTypeParameter) Lower(value *[]MoveFunctionTypeParameter) C.RustBuffer {
	return LowerIntoRustBuffer[*[]MoveFunctionTypeParameter](c, value)
}

func (_ FfiConverterOptionalSequenceMoveFunctionTypeParameter) Write(writer io.Writer, value *[]MoveFunctionTypeParameter) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceMoveFunctionTypeParameterINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceMoveFunctionTypeParameter struct {}

func (_ FfiDestroyerOptionalSequenceMoveFunctionTypeParameter) Destroy(value *[]MoveFunctionTypeParameter) {
	if value != nil {
		FfiDestroyerSequenceMoveFunctionTypeParameter{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceMoveStructTypeParameter struct{}

var FfiConverterOptionalSequenceMoveStructTypeParameterINSTANCE = FfiConverterOptionalSequenceMoveStructTypeParameter{}

func (c FfiConverterOptionalSequenceMoveStructTypeParameter) Lift(rb RustBufferI) *[]MoveStructTypeParameter {
	return LiftFromRustBuffer[*[]MoveStructTypeParameter](c, rb)
}

func (_ FfiConverterOptionalSequenceMoveStructTypeParameter) Read(reader io.Reader) *[]MoveStructTypeParameter {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceMoveStructTypeParameterINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceMoveStructTypeParameter) Lower(value *[]MoveStructTypeParameter) C.RustBuffer {
	return LowerIntoRustBuffer[*[]MoveStructTypeParameter](c, value)
}

func (_ FfiConverterOptionalSequenceMoveStructTypeParameter) Write(writer io.Writer, value *[]MoveStructTypeParameter) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceMoveStructTypeParameterINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceMoveStructTypeParameter struct {}

func (_ FfiDestroyerOptionalSequenceMoveStructTypeParameter) Destroy(value *[]MoveStructTypeParameter) {
	if value != nil {
		FfiDestroyerSequenceMoveStructTypeParameter{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceObjectRef struct{}

var FfiConverterOptionalSequenceObjectRefINSTANCE = FfiConverterOptionalSequenceObjectRef{}

func (c FfiConverterOptionalSequenceObjectRef) Lift(rb RustBufferI) *[]ObjectRef {
	return LiftFromRustBuffer[*[]ObjectRef](c, rb)
}

func (_ FfiConverterOptionalSequenceObjectRef) Read(reader io.Reader) *[]ObjectRef {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceObjectRefINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceObjectRef) Lower(value *[]ObjectRef) C.RustBuffer {
	return LowerIntoRustBuffer[*[]ObjectRef](c, value)
}

func (_ FfiConverterOptionalSequenceObjectRef) Write(writer io.Writer, value *[]ObjectRef) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceObjectRefINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceObjectRef struct {}

func (_ FfiDestroyerOptionalSequenceObjectRef) Destroy(value *[]ObjectRef) {
	if value != nil {
		FfiDestroyerSequenceObjectRef{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceOpenMoveType struct{}

var FfiConverterOptionalSequenceOpenMoveTypeINSTANCE = FfiConverterOptionalSequenceOpenMoveType{}

func (c FfiConverterOptionalSequenceOpenMoveType) Lift(rb RustBufferI) *[]OpenMoveType {
	return LiftFromRustBuffer[*[]OpenMoveType](c, rb)
}

func (_ FfiConverterOptionalSequenceOpenMoveType) Read(reader io.Reader) *[]OpenMoveType {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceOpenMoveTypeINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceOpenMoveType) Lower(value *[]OpenMoveType) C.RustBuffer {
	return LowerIntoRustBuffer[*[]OpenMoveType](c, value)
}

func (_ FfiConverterOptionalSequenceOpenMoveType) Write(writer io.Writer, value *[]OpenMoveType) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceOpenMoveTypeINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceOpenMoveType struct {}

func (_ FfiDestroyerOptionalSequenceOpenMoveType) Destroy(value *[]OpenMoveType) {
	if value != nil {
		FfiDestroyerSequenceOpenMoveType{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceMoveAbility struct{}

var FfiConverterOptionalSequenceMoveAbilityINSTANCE = FfiConverterOptionalSequenceMoveAbility{}

func (c FfiConverterOptionalSequenceMoveAbility) Lift(rb RustBufferI) *[]MoveAbility {
	return LiftFromRustBuffer[*[]MoveAbility](c, rb)
}

func (_ FfiConverterOptionalSequenceMoveAbility) Read(reader io.Reader) *[]MoveAbility {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceMoveAbilityINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceMoveAbility) Lower(value *[]MoveAbility) C.RustBuffer {
	return LowerIntoRustBuffer[*[]MoveAbility](c, value)
}

func (_ FfiConverterOptionalSequenceMoveAbility) Write(writer io.Writer, value *[]MoveAbility) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceMoveAbilityINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceMoveAbility struct {}

func (_ FfiDestroyerOptionalSequenceMoveAbility) Destroy(value *[]MoveAbility) {
	if value != nil {
		FfiDestroyerSequenceMoveAbility{}.Destroy(*value)
	}
}

type FfiConverterOptionalMapStringSequenceString struct{}

var FfiConverterOptionalMapStringSequenceStringINSTANCE = FfiConverterOptionalMapStringSequenceString{}

func (c FfiConverterOptionalMapStringSequenceString) Lift(rb RustBufferI) *map[string][]string {
	return LiftFromRustBuffer[*map[string][]string](c, rb)
}

func (_ FfiConverterOptionalMapStringSequenceString) Read(reader io.Reader) *map[string][]string {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMapStringSequenceStringINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMapStringSequenceString) Lower(value *map[string][]string) C.RustBuffer {
	return LowerIntoRustBuffer[*map[string][]string](c, value)
}

func (_ FfiConverterOptionalMapStringSequenceString) Write(writer io.Writer, value *map[string][]string) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMapStringSequenceStringINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMapStringSequenceString struct {}

func (_ FfiDestroyerOptionalMapStringSequenceString) Destroy(value *map[string][]string) {
	if value != nil {
		FfiDestroyerMapStringSequenceString{}.Destroy(*value)
	}
}

type FfiConverterOptionalTypeBase64 struct{}

var FfiConverterOptionalTypeBase64INSTANCE = FfiConverterOptionalTypeBase64{}

func (c FfiConverterOptionalTypeBase64) Lift(rb RustBufferI) *Base64 {
	return LiftFromRustBuffer[*Base64](c, rb)
}

func (_ FfiConverterOptionalTypeBase64) Read(reader io.Reader) *Base64 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeBase64INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeBase64) Lower(value *Base64) C.RustBuffer {
	return LowerIntoRustBuffer[*Base64](c, value)
}

func (_ FfiConverterOptionalTypeBase64) Write(writer io.Writer, value *Base64) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeBase64INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeBase64 struct {}

func (_ FfiDestroyerOptionalTypeBase64) Destroy(value *Base64) {
	if value != nil {
		FfiDestroyerTypeBase64{}.Destroy(*value)
	}
}

type FfiConverterOptionalTypeBigInt struct{}

var FfiConverterOptionalTypeBigIntINSTANCE = FfiConverterOptionalTypeBigInt{}

func (c FfiConverterOptionalTypeBigInt) Lift(rb RustBufferI) *BigInt {
	return LiftFromRustBuffer[*BigInt](c, rb)
}

func (_ FfiConverterOptionalTypeBigInt) Read(reader io.Reader) *BigInt {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeBigIntINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeBigInt) Lower(value *BigInt) C.RustBuffer {
	return LowerIntoRustBuffer[*BigInt](c, value)
}

func (_ FfiConverterOptionalTypeBigInt) Write(writer io.Writer, value *BigInt) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeBigIntINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeBigInt struct {}

func (_ FfiDestroyerOptionalTypeBigInt) Destroy(value *BigInt) {
	if value != nil {
		FfiDestroyerTypeBigInt{}.Destroy(*value)
	}
}

type FfiConverterOptionalTypeValue struct{}

var FfiConverterOptionalTypeValueINSTANCE = FfiConverterOptionalTypeValue{}

func (c FfiConverterOptionalTypeValue) Lift(rb RustBufferI) *Value {
	return LiftFromRustBuffer[*Value](c, rb)
}

func (_ FfiConverterOptionalTypeValue) Read(reader io.Reader) *Value {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeValueINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeValue) Lower(value *Value) C.RustBuffer {
	return LowerIntoRustBuffer[*Value](c, value)
}

func (_ FfiConverterOptionalTypeValue) Write(writer io.Writer, value *Value) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeValueINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeValue struct {}

func (_ FfiDestroyerOptionalTypeValue) Destroy(value *Value) {
	if value != nil {
		FfiDestroyerTypeValue{}.Destroy(*value)
	}
}

type FfiConverterSequenceUint16 struct{}

var FfiConverterSequenceUint16INSTANCE = FfiConverterSequenceUint16{}

func (c FfiConverterSequenceUint16) Lift(rb RustBufferI) []uint16 {
	return LiftFromRustBuffer[[]uint16](c, rb)
}

func (c FfiConverterSequenceUint16) Read(reader io.Reader) []uint16 {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]uint16, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterUint16INSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceUint16) Lower(value []uint16) C.RustBuffer {
	return LowerIntoRustBuffer[[]uint16](c, value)
}

func (c FfiConverterSequenceUint16) Write(writer io.Writer, value []uint16) {
	if len(value) > math.MaxInt32 {
		panic("[]uint16 is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterUint16INSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceUint16 struct {}

func (FfiDestroyerSequenceUint16) Destroy(sequence []uint16) {
	for _, value := range sequence {
		FfiDestroyerUint16{}.Destroy(value)
	}
}

type FfiConverterSequenceUint32 struct{}

var FfiConverterSequenceUint32INSTANCE = FfiConverterSequenceUint32{}

func (c FfiConverterSequenceUint32) Lift(rb RustBufferI) []uint32 {
	return LiftFromRustBuffer[[]uint32](c, rb)
}

func (c FfiConverterSequenceUint32) Read(reader io.Reader) []uint32 {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]uint32, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterUint32INSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceUint32) Lower(value []uint32) C.RustBuffer {
	return LowerIntoRustBuffer[[]uint32](c, value)
}

func (c FfiConverterSequenceUint32) Write(writer io.Writer, value []uint32) {
	if len(value) > math.MaxInt32 {
		panic("[]uint32 is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterUint32INSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceUint32 struct {}

func (FfiDestroyerSequenceUint32) Destroy(sequence []uint32) {
	for _, value := range sequence {
		FfiDestroyerUint32{}.Destroy(value)
	}
}

type FfiConverterSequenceInt32 struct{}

var FfiConverterSequenceInt32INSTANCE = FfiConverterSequenceInt32{}

func (c FfiConverterSequenceInt32) Lift(rb RustBufferI) []int32 {
	return LiftFromRustBuffer[[]int32](c, rb)
}

func (c FfiConverterSequenceInt32) Read(reader io.Reader) []int32 {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]int32, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterInt32INSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceInt32) Lower(value []int32) C.RustBuffer {
	return LowerIntoRustBuffer[[]int32](c, value)
}

func (c FfiConverterSequenceInt32) Write(writer io.Writer, value []int32) {
	if len(value) > math.MaxInt32 {
		panic("[]int32 is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterInt32INSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceInt32 struct {}

func (FfiDestroyerSequenceInt32) Destroy(sequence []int32) {
	for _, value := range sequence {
		FfiDestroyerInt32{}.Destroy(value)
	}
}

type FfiConverterSequenceUint64 struct{}

var FfiConverterSequenceUint64INSTANCE = FfiConverterSequenceUint64{}

func (c FfiConverterSequenceUint64) Lift(rb RustBufferI) []uint64 {
	return LiftFromRustBuffer[[]uint64](c, rb)
}

func (c FfiConverterSequenceUint64) Read(reader io.Reader) []uint64 {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]uint64, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterUint64INSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceUint64) Lower(value []uint64) C.RustBuffer {
	return LowerIntoRustBuffer[[]uint64](c, value)
}

func (c FfiConverterSequenceUint64) Write(writer io.Writer, value []uint64) {
	if len(value) > math.MaxInt32 {
		panic("[]uint64 is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterUint64INSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceUint64 struct {}

func (FfiDestroyerSequenceUint64) Destroy(sequence []uint64) {
	for _, value := range sequence {
		FfiDestroyerUint64{}.Destroy(value)
	}
}

type FfiConverterSequenceBool struct{}

var FfiConverterSequenceBoolINSTANCE = FfiConverterSequenceBool{}

func (c FfiConverterSequenceBool) Lift(rb RustBufferI) []bool {
	return LiftFromRustBuffer[[]bool](c, rb)
}

func (c FfiConverterSequenceBool) Read(reader io.Reader) []bool {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]bool, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterBoolINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceBool) Lower(value []bool) C.RustBuffer {
	return LowerIntoRustBuffer[[]bool](c, value)
}

func (c FfiConverterSequenceBool) Write(writer io.Writer, value []bool) {
	if len(value) > math.MaxInt32 {
		panic("[]bool is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterBoolINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceBool struct {}

func (FfiDestroyerSequenceBool) Destroy(sequence []bool) {
	for _, value := range sequence {
		FfiDestroyerBool{}.Destroy(value)
	}
}

type FfiConverterSequenceString struct{}

var FfiConverterSequenceStringINSTANCE = FfiConverterSequenceString{}

func (c FfiConverterSequenceString) Lift(rb RustBufferI) []string {
	return LiftFromRustBuffer[[]string](c, rb)
}

func (c FfiConverterSequenceString) Read(reader io.Reader) []string {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]string, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterStringINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceString) Lower(value []string) C.RustBuffer {
	return LowerIntoRustBuffer[[]string](c, value)
}

func (c FfiConverterSequenceString) Write(writer io.Writer, value []string) {
	if len(value) > math.MaxInt32 {
		panic("[]string is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterStringINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceString struct {}

func (FfiDestroyerSequenceString) Destroy(sequence []string) {
	for _, value := range sequence {
		FfiDestroyerString{}.Destroy(value)
	}
}

type FfiConverterSequenceBytes struct{}

var FfiConverterSequenceBytesINSTANCE = FfiConverterSequenceBytes{}

func (c FfiConverterSequenceBytes) Lift(rb RustBufferI) [][]byte {
	return LiftFromRustBuffer[[][]byte](c, rb)
}

func (c FfiConverterSequenceBytes) Read(reader io.Reader) [][]byte {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([][]byte, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterBytesINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceBytes) Lower(value [][]byte) C.RustBuffer {
	return LowerIntoRustBuffer[[][]byte](c, value)
}

func (c FfiConverterSequenceBytes) Write(writer io.Writer, value [][]byte) {
	if len(value) > math.MaxInt32 {
		panic("[][]byte is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterBytesINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceBytes struct {}

func (FfiDestroyerSequenceBytes) Destroy(sequence [][]byte) {
	for _, value := range sequence {
		FfiDestroyerBytes{}.Destroy(value)
	}
}

type FfiConverterSequenceAddress struct{}

var FfiConverterSequenceAddressINSTANCE = FfiConverterSequenceAddress{}

func (c FfiConverterSequenceAddress) Lift(rb RustBufferI) []*Address {
	return LiftFromRustBuffer[[]*Address](c, rb)
}

func (c FfiConverterSequenceAddress) Read(reader io.Reader) []*Address {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*Address, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterAddressINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceAddress) Lower(value []*Address) C.RustBuffer {
	return LowerIntoRustBuffer[[]*Address](c, value)
}

func (c FfiConverterSequenceAddress) Write(writer io.Writer, value []*Address) {
	if len(value) > math.MaxInt32 {
		panic("[]*Address is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterAddressINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceAddress struct {}

func (FfiDestroyerSequenceAddress) Destroy(sequence []*Address) {
	for _, value := range sequence {
		FfiDestroyerAddress{}.Destroy(value)
	}
}

type FfiConverterSequenceArgument struct{}

var FfiConverterSequenceArgumentINSTANCE = FfiConverterSequenceArgument{}

func (c FfiConverterSequenceArgument) Lift(rb RustBufferI) []*Argument {
	return LiftFromRustBuffer[[]*Argument](c, rb)
}

func (c FfiConverterSequenceArgument) Read(reader io.Reader) []*Argument {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*Argument, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterArgumentINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceArgument) Lower(value []*Argument) C.RustBuffer {
	return LowerIntoRustBuffer[[]*Argument](c, value)
}

func (c FfiConverterSequenceArgument) Write(writer io.Writer, value []*Argument) {
	if len(value) > math.MaxInt32 {
		panic("[]*Argument is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterArgumentINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceArgument struct {}

func (FfiDestroyerSequenceArgument) Destroy(sequence []*Argument) {
	for _, value := range sequence {
		FfiDestroyerArgument{}.Destroy(value)
	}
}

type FfiConverterSequenceCancelledTransaction struct{}

var FfiConverterSequenceCancelledTransactionINSTANCE = FfiConverterSequenceCancelledTransaction{}

func (c FfiConverterSequenceCancelledTransaction) Lift(rb RustBufferI) []*CancelledTransaction {
	return LiftFromRustBuffer[[]*CancelledTransaction](c, rb)
}

func (c FfiConverterSequenceCancelledTransaction) Read(reader io.Reader) []*CancelledTransaction {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*CancelledTransaction, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterCancelledTransactionINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceCancelledTransaction) Lower(value []*CancelledTransaction) C.RustBuffer {
	return LowerIntoRustBuffer[[]*CancelledTransaction](c, value)
}

func (c FfiConverterSequenceCancelledTransaction) Write(writer io.Writer, value []*CancelledTransaction) {
	if len(value) > math.MaxInt32 {
		panic("[]*CancelledTransaction is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterCancelledTransactionINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceCancelledTransaction struct {}

func (FfiDestroyerSequenceCancelledTransaction) Destroy(sequence []*CancelledTransaction) {
	for _, value := range sequence {
		FfiDestroyerCancelledTransaction{}.Destroy(value)
	}
}

type FfiConverterSequenceCheckpointCommitment struct{}

var FfiConverterSequenceCheckpointCommitmentINSTANCE = FfiConverterSequenceCheckpointCommitment{}

func (c FfiConverterSequenceCheckpointCommitment) Lift(rb RustBufferI) []*CheckpointCommitment {
	return LiftFromRustBuffer[[]*CheckpointCommitment](c, rb)
}

func (c FfiConverterSequenceCheckpointCommitment) Read(reader io.Reader) []*CheckpointCommitment {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*CheckpointCommitment, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterCheckpointCommitmentINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceCheckpointCommitment) Lower(value []*CheckpointCommitment) C.RustBuffer {
	return LowerIntoRustBuffer[[]*CheckpointCommitment](c, value)
}

func (c FfiConverterSequenceCheckpointCommitment) Write(writer io.Writer, value []*CheckpointCommitment) {
	if len(value) > math.MaxInt32 {
		panic("[]*CheckpointCommitment is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterCheckpointCommitmentINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceCheckpointCommitment struct {}

func (FfiDestroyerSequenceCheckpointCommitment) Destroy(sequence []*CheckpointCommitment) {
	for _, value := range sequence {
		FfiDestroyerCheckpointCommitment{}.Destroy(value)
	}
}

type FfiConverterSequenceCheckpointSummary struct{}

var FfiConverterSequenceCheckpointSummaryINSTANCE = FfiConverterSequenceCheckpointSummary{}

func (c FfiConverterSequenceCheckpointSummary) Lift(rb RustBufferI) []*CheckpointSummary {
	return LiftFromRustBuffer[[]*CheckpointSummary](c, rb)
}

func (c FfiConverterSequenceCheckpointSummary) Read(reader io.Reader) []*CheckpointSummary {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*CheckpointSummary, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterCheckpointSummaryINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceCheckpointSummary) Lower(value []*CheckpointSummary) C.RustBuffer {
	return LowerIntoRustBuffer[[]*CheckpointSummary](c, value)
}

func (c FfiConverterSequenceCheckpointSummary) Write(writer io.Writer, value []*CheckpointSummary) {
	if len(value) > math.MaxInt32 {
		panic("[]*CheckpointSummary is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterCheckpointSummaryINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceCheckpointSummary struct {}

func (FfiDestroyerSequenceCheckpointSummary) Destroy(sequence []*CheckpointSummary) {
	for _, value := range sequence {
		FfiDestroyerCheckpointSummary{}.Destroy(value)
	}
}

type FfiConverterSequenceCheckpointTransactionInfo struct{}

var FfiConverterSequenceCheckpointTransactionInfoINSTANCE = FfiConverterSequenceCheckpointTransactionInfo{}

func (c FfiConverterSequenceCheckpointTransactionInfo) Lift(rb RustBufferI) []*CheckpointTransactionInfo {
	return LiftFromRustBuffer[[]*CheckpointTransactionInfo](c, rb)
}

func (c FfiConverterSequenceCheckpointTransactionInfo) Read(reader io.Reader) []*CheckpointTransactionInfo {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*CheckpointTransactionInfo, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterCheckpointTransactionInfoINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceCheckpointTransactionInfo) Lower(value []*CheckpointTransactionInfo) C.RustBuffer {
	return LowerIntoRustBuffer[[]*CheckpointTransactionInfo](c, value)
}

func (c FfiConverterSequenceCheckpointTransactionInfo) Write(writer io.Writer, value []*CheckpointTransactionInfo) {
	if len(value) > math.MaxInt32 {
		panic("[]*CheckpointTransactionInfo is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterCheckpointTransactionInfoINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceCheckpointTransactionInfo struct {}

func (FfiDestroyerSequenceCheckpointTransactionInfo) Destroy(sequence []*CheckpointTransactionInfo) {
	for _, value := range sequence {
		FfiDestroyerCheckpointTransactionInfo{}.Destroy(value)
	}
}

type FfiConverterSequenceCoin struct{}

var FfiConverterSequenceCoinINSTANCE = FfiConverterSequenceCoin{}

func (c FfiConverterSequenceCoin) Lift(rb RustBufferI) []*Coin {
	return LiftFromRustBuffer[[]*Coin](c, rb)
}

func (c FfiConverterSequenceCoin) Read(reader io.Reader) []*Coin {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*Coin, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterCoinINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceCoin) Lower(value []*Coin) C.RustBuffer {
	return LowerIntoRustBuffer[[]*Coin](c, value)
}

func (c FfiConverterSequenceCoin) Write(writer io.Writer, value []*Coin) {
	if len(value) > math.MaxInt32 {
		panic("[]*Coin is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterCoinINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceCoin struct {}

func (FfiDestroyerSequenceCoin) Destroy(sequence []*Coin) {
	for _, value := range sequence {
		FfiDestroyerCoin{}.Destroy(value)
	}
}

type FfiConverterSequenceCommand struct{}

var FfiConverterSequenceCommandINSTANCE = FfiConverterSequenceCommand{}

func (c FfiConverterSequenceCommand) Lift(rb RustBufferI) []*Command {
	return LiftFromRustBuffer[[]*Command](c, rb)
}

func (c FfiConverterSequenceCommand) Read(reader io.Reader) []*Command {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*Command, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterCommandINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceCommand) Lower(value []*Command) C.RustBuffer {
	return LowerIntoRustBuffer[[]*Command](c, value)
}

func (c FfiConverterSequenceCommand) Write(writer io.Writer, value []*Command) {
	if len(value) > math.MaxInt32 {
		panic("[]*Command is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterCommandINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceCommand struct {}

func (FfiDestroyerSequenceCommand) Destroy(sequence []*Command) {
	for _, value := range sequence {
		FfiDestroyerCommand{}.Destroy(value)
	}
}

type FfiConverterSequenceDigest struct{}

var FfiConverterSequenceDigestINSTANCE = FfiConverterSequenceDigest{}

func (c FfiConverterSequenceDigest) Lift(rb RustBufferI) []*Digest {
	return LiftFromRustBuffer[[]*Digest](c, rb)
}

func (c FfiConverterSequenceDigest) Read(reader io.Reader) []*Digest {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*Digest, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterDigestINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceDigest) Lower(value []*Digest) C.RustBuffer {
	return LowerIntoRustBuffer[[]*Digest](c, value)
}

func (c FfiConverterSequenceDigest) Write(writer io.Writer, value []*Digest) {
	if len(value) > math.MaxInt32 {
		panic("[]*Digest is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterDigestINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceDigest struct {}

func (FfiDestroyerSequenceDigest) Destroy(sequence []*Digest) {
	for _, value := range sequence {
		FfiDestroyerDigest{}.Destroy(value)
	}
}

type FfiConverterSequenceEndOfEpochTransactionKind struct{}

var FfiConverterSequenceEndOfEpochTransactionKindINSTANCE = FfiConverterSequenceEndOfEpochTransactionKind{}

func (c FfiConverterSequenceEndOfEpochTransactionKind) Lift(rb RustBufferI) []*EndOfEpochTransactionKind {
	return LiftFromRustBuffer[[]*EndOfEpochTransactionKind](c, rb)
}

func (c FfiConverterSequenceEndOfEpochTransactionKind) Read(reader io.Reader) []*EndOfEpochTransactionKind {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*EndOfEpochTransactionKind, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterEndOfEpochTransactionKindINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceEndOfEpochTransactionKind) Lower(value []*EndOfEpochTransactionKind) C.RustBuffer {
	return LowerIntoRustBuffer[[]*EndOfEpochTransactionKind](c, value)
}

func (c FfiConverterSequenceEndOfEpochTransactionKind) Write(writer io.Writer, value []*EndOfEpochTransactionKind) {
	if len(value) > math.MaxInt32 {
		panic("[]*EndOfEpochTransactionKind is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterEndOfEpochTransactionKindINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceEndOfEpochTransactionKind struct {}

func (FfiDestroyerSequenceEndOfEpochTransactionKind) Destroy(sequence []*EndOfEpochTransactionKind) {
	for _, value := range sequence {
		FfiDestroyerEndOfEpochTransactionKind{}.Destroy(value)
	}
}

type FfiConverterSequenceExecutionTimeObservation struct{}

var FfiConverterSequenceExecutionTimeObservationINSTANCE = FfiConverterSequenceExecutionTimeObservation{}

func (c FfiConverterSequenceExecutionTimeObservation) Lift(rb RustBufferI) []*ExecutionTimeObservation {
	return LiftFromRustBuffer[[]*ExecutionTimeObservation](c, rb)
}

func (c FfiConverterSequenceExecutionTimeObservation) Read(reader io.Reader) []*ExecutionTimeObservation {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*ExecutionTimeObservation, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterExecutionTimeObservationINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceExecutionTimeObservation) Lower(value []*ExecutionTimeObservation) C.RustBuffer {
	return LowerIntoRustBuffer[[]*ExecutionTimeObservation](c, value)
}

func (c FfiConverterSequenceExecutionTimeObservation) Write(writer io.Writer, value []*ExecutionTimeObservation) {
	if len(value) > math.MaxInt32 {
		panic("[]*ExecutionTimeObservation is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterExecutionTimeObservationINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceExecutionTimeObservation struct {}

func (FfiDestroyerSequenceExecutionTimeObservation) Destroy(sequence []*ExecutionTimeObservation) {
	for _, value := range sequence {
		FfiDestroyerExecutionTimeObservation{}.Destroy(value)
	}
}

type FfiConverterSequenceGenesisObject struct{}

var FfiConverterSequenceGenesisObjectINSTANCE = FfiConverterSequenceGenesisObject{}

func (c FfiConverterSequenceGenesisObject) Lift(rb RustBufferI) []*GenesisObject {
	return LiftFromRustBuffer[[]*GenesisObject](c, rb)
}

func (c FfiConverterSequenceGenesisObject) Read(reader io.Reader) []*GenesisObject {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*GenesisObject, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterGenesisObjectINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceGenesisObject) Lower(value []*GenesisObject) C.RustBuffer {
	return LowerIntoRustBuffer[[]*GenesisObject](c, value)
}

func (c FfiConverterSequenceGenesisObject) Write(writer io.Writer, value []*GenesisObject) {
	if len(value) > math.MaxInt32 {
		panic("[]*GenesisObject is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterGenesisObjectINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceGenesisObject struct {}

func (FfiDestroyerSequenceGenesisObject) Destroy(sequence []*GenesisObject) {
	for _, value := range sequence {
		FfiDestroyerGenesisObject{}.Destroy(value)
	}
}

type FfiConverterSequenceInput struct{}

var FfiConverterSequenceInputINSTANCE = FfiConverterSequenceInput{}

func (c FfiConverterSequenceInput) Lift(rb RustBufferI) []*Input {
	return LiftFromRustBuffer[[]*Input](c, rb)
}

func (c FfiConverterSequenceInput) Read(reader io.Reader) []*Input {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*Input, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterInputINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceInput) Lower(value []*Input) C.RustBuffer {
	return LowerIntoRustBuffer[[]*Input](c, value)
}

func (c FfiConverterSequenceInput) Write(writer io.Writer, value []*Input) {
	if len(value) > math.MaxInt32 {
		panic("[]*Input is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterInputINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceInput struct {}

func (FfiDestroyerSequenceInput) Destroy(sequence []*Input) {
	for _, value := range sequence {
		FfiDestroyerInput{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveArg struct{}

var FfiConverterSequenceMoveArgINSTANCE = FfiConverterSequenceMoveArg{}

func (c FfiConverterSequenceMoveArg) Lift(rb RustBufferI) []*MoveArg {
	return LiftFromRustBuffer[[]*MoveArg](c, rb)
}

func (c FfiConverterSequenceMoveArg) Read(reader io.Reader) []*MoveArg {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*MoveArg, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveArgINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveArg) Lower(value []*MoveArg) C.RustBuffer {
	return LowerIntoRustBuffer[[]*MoveArg](c, value)
}

func (c FfiConverterSequenceMoveArg) Write(writer io.Writer, value []*MoveArg) {
	if len(value) > math.MaxInt32 {
		panic("[]*MoveArg is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveArgINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveArg struct {}

func (FfiDestroyerSequenceMoveArg) Destroy(sequence []*MoveArg) {
	for _, value := range sequence {
		FfiDestroyerMoveArg{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveFunction struct{}

var FfiConverterSequenceMoveFunctionINSTANCE = FfiConverterSequenceMoveFunction{}

func (c FfiConverterSequenceMoveFunction) Lift(rb RustBufferI) []*MoveFunction {
	return LiftFromRustBuffer[[]*MoveFunction](c, rb)
}

func (c FfiConverterSequenceMoveFunction) Read(reader io.Reader) []*MoveFunction {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*MoveFunction, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveFunctionINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveFunction) Lower(value []*MoveFunction) C.RustBuffer {
	return LowerIntoRustBuffer[[]*MoveFunction](c, value)
}

func (c FfiConverterSequenceMoveFunction) Write(writer io.Writer, value []*MoveFunction) {
	if len(value) > math.MaxInt32 {
		panic("[]*MoveFunction is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveFunctionINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveFunction struct {}

func (FfiDestroyerSequenceMoveFunction) Destroy(sequence []*MoveFunction) {
	for _, value := range sequence {
		FfiDestroyerMoveFunction{}.Destroy(value)
	}
}

type FfiConverterSequenceMovePackage struct{}

var FfiConverterSequenceMovePackageINSTANCE = FfiConverterSequenceMovePackage{}

func (c FfiConverterSequenceMovePackage) Lift(rb RustBufferI) []*MovePackage {
	return LiftFromRustBuffer[[]*MovePackage](c, rb)
}

func (c FfiConverterSequenceMovePackage) Read(reader io.Reader) []*MovePackage {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*MovePackage, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMovePackageINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMovePackage) Lower(value []*MovePackage) C.RustBuffer {
	return LowerIntoRustBuffer[[]*MovePackage](c, value)
}

func (c FfiConverterSequenceMovePackage) Write(writer io.Writer, value []*MovePackage) {
	if len(value) > math.MaxInt32 {
		panic("[]*MovePackage is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMovePackageINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMovePackage struct {}

func (FfiDestroyerSequenceMovePackage) Destroy(sequence []*MovePackage) {
	for _, value := range sequence {
		FfiDestroyerMovePackage{}.Destroy(value)
	}
}

type FfiConverterSequenceMultisigMember struct{}

var FfiConverterSequenceMultisigMemberINSTANCE = FfiConverterSequenceMultisigMember{}

func (c FfiConverterSequenceMultisigMember) Lift(rb RustBufferI) []*MultisigMember {
	return LiftFromRustBuffer[[]*MultisigMember](c, rb)
}

func (c FfiConverterSequenceMultisigMember) Read(reader io.Reader) []*MultisigMember {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*MultisigMember, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMultisigMemberINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMultisigMember) Lower(value []*MultisigMember) C.RustBuffer {
	return LowerIntoRustBuffer[[]*MultisigMember](c, value)
}

func (c FfiConverterSequenceMultisigMember) Write(writer io.Writer, value []*MultisigMember) {
	if len(value) > math.MaxInt32 {
		panic("[]*MultisigMember is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMultisigMemberINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMultisigMember struct {}

func (FfiDestroyerSequenceMultisigMember) Destroy(sequence []*MultisigMember) {
	for _, value := range sequence {
		FfiDestroyerMultisigMember{}.Destroy(value)
	}
}

type FfiConverterSequenceMultisigMemberSignature struct{}

var FfiConverterSequenceMultisigMemberSignatureINSTANCE = FfiConverterSequenceMultisigMemberSignature{}

func (c FfiConverterSequenceMultisigMemberSignature) Lift(rb RustBufferI) []*MultisigMemberSignature {
	return LiftFromRustBuffer[[]*MultisigMemberSignature](c, rb)
}

func (c FfiConverterSequenceMultisigMemberSignature) Read(reader io.Reader) []*MultisigMemberSignature {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*MultisigMemberSignature, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMultisigMemberSignatureINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMultisigMemberSignature) Lower(value []*MultisigMemberSignature) C.RustBuffer {
	return LowerIntoRustBuffer[[]*MultisigMemberSignature](c, value)
}

func (c FfiConverterSequenceMultisigMemberSignature) Write(writer io.Writer, value []*MultisigMemberSignature) {
	if len(value) > math.MaxInt32 {
		panic("[]*MultisigMemberSignature is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMultisigMemberSignatureINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMultisigMemberSignature struct {}

func (FfiDestroyerSequenceMultisigMemberSignature) Destroy(sequence []*MultisigMemberSignature) {
	for _, value := range sequence {
		FfiDestroyerMultisigMemberSignature{}.Destroy(value)
	}
}

type FfiConverterSequenceNameRegistration struct{}

var FfiConverterSequenceNameRegistrationINSTANCE = FfiConverterSequenceNameRegistration{}

func (c FfiConverterSequenceNameRegistration) Lift(rb RustBufferI) []*NameRegistration {
	return LiftFromRustBuffer[[]*NameRegistration](c, rb)
}

func (c FfiConverterSequenceNameRegistration) Read(reader io.Reader) []*NameRegistration {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*NameRegistration, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterNameRegistrationINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceNameRegistration) Lower(value []*NameRegistration) C.RustBuffer {
	return LowerIntoRustBuffer[[]*NameRegistration](c, value)
}

func (c FfiConverterSequenceNameRegistration) Write(writer io.Writer, value []*NameRegistration) {
	if len(value) > math.MaxInt32 {
		panic("[]*NameRegistration is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterNameRegistrationINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceNameRegistration struct {}

func (FfiDestroyerSequenceNameRegistration) Destroy(sequence []*NameRegistration) {
	for _, value := range sequence {
		FfiDestroyerNameRegistration{}.Destroy(value)
	}
}

type FfiConverterSequenceObject struct{}

var FfiConverterSequenceObjectINSTANCE = FfiConverterSequenceObject{}

func (c FfiConverterSequenceObject) Lift(rb RustBufferI) []*Object {
	return LiftFromRustBuffer[[]*Object](c, rb)
}

func (c FfiConverterSequenceObject) Read(reader io.Reader) []*Object {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*Object, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterObjectINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceObject) Lower(value []*Object) C.RustBuffer {
	return LowerIntoRustBuffer[[]*Object](c, value)
}

func (c FfiConverterSequenceObject) Write(writer io.Writer, value []*Object) {
	if len(value) > math.MaxInt32 {
		panic("[]*Object is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterObjectINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceObject struct {}

func (FfiDestroyerSequenceObject) Destroy(sequence []*Object) {
	for _, value := range sequence {
		FfiDestroyerObject{}.Destroy(value)
	}
}

type FfiConverterSequenceObjectId struct{}

var FfiConverterSequenceObjectIdINSTANCE = FfiConverterSequenceObjectId{}

func (c FfiConverterSequenceObjectId) Lift(rb RustBufferI) []*ObjectId {
	return LiftFromRustBuffer[[]*ObjectId](c, rb)
}

func (c FfiConverterSequenceObjectId) Read(reader io.Reader) []*ObjectId {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*ObjectId, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterObjectIdINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceObjectId) Lower(value []*ObjectId) C.RustBuffer {
	return LowerIntoRustBuffer[[]*ObjectId](c, value)
}

func (c FfiConverterSequenceObjectId) Write(writer io.Writer, value []*ObjectId) {
	if len(value) > math.MaxInt32 {
		panic("[]*ObjectId is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterObjectIdINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceObjectId struct {}

func (FfiDestroyerSequenceObjectId) Destroy(sequence []*ObjectId) {
	for _, value := range sequence {
		FfiDestroyerObjectId{}.Destroy(value)
	}
}

type FfiConverterSequencePtbArgument struct{}

var FfiConverterSequencePtbArgumentINSTANCE = FfiConverterSequencePtbArgument{}

func (c FfiConverterSequencePtbArgument) Lift(rb RustBufferI) []*PtbArgument {
	return LiftFromRustBuffer[[]*PtbArgument](c, rb)
}

func (c FfiConverterSequencePtbArgument) Read(reader io.Reader) []*PtbArgument {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*PtbArgument, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterPtbArgumentINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequencePtbArgument) Lower(value []*PtbArgument) C.RustBuffer {
	return LowerIntoRustBuffer[[]*PtbArgument](c, value)
}

func (c FfiConverterSequencePtbArgument) Write(writer io.Writer, value []*PtbArgument) {
	if len(value) > math.MaxInt32 {
		panic("[]*PtbArgument is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterPtbArgumentINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequencePtbArgument struct {}

func (FfiDestroyerSequencePtbArgument) Destroy(sequence []*PtbArgument) {
	for _, value := range sequence {
		FfiDestroyerPtbArgument{}.Destroy(value)
	}
}

type FfiConverterSequenceSystemPackage struct{}

var FfiConverterSequenceSystemPackageINSTANCE = FfiConverterSequenceSystemPackage{}

func (c FfiConverterSequenceSystemPackage) Lift(rb RustBufferI) []*SystemPackage {
	return LiftFromRustBuffer[[]*SystemPackage](c, rb)
}

func (c FfiConverterSequenceSystemPackage) Read(reader io.Reader) []*SystemPackage {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*SystemPackage, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterSystemPackageINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceSystemPackage) Lower(value []*SystemPackage) C.RustBuffer {
	return LowerIntoRustBuffer[[]*SystemPackage](c, value)
}

func (c FfiConverterSequenceSystemPackage) Write(writer io.Writer, value []*SystemPackage) {
	if len(value) > math.MaxInt32 {
		panic("[]*SystemPackage is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterSystemPackageINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceSystemPackage struct {}

func (FfiDestroyerSequenceSystemPackage) Destroy(sequence []*SystemPackage) {
	for _, value := range sequence {
		FfiDestroyerSystemPackage{}.Destroy(value)
	}
}

type FfiConverterSequenceTransactionEffects struct{}

var FfiConverterSequenceTransactionEffectsINSTANCE = FfiConverterSequenceTransactionEffects{}

func (c FfiConverterSequenceTransactionEffects) Lift(rb RustBufferI) []*TransactionEffects {
	return LiftFromRustBuffer[[]*TransactionEffects](c, rb)
}

func (c FfiConverterSequenceTransactionEffects) Read(reader io.Reader) []*TransactionEffects {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*TransactionEffects, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTransactionEffectsINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceTransactionEffects) Lower(value []*TransactionEffects) C.RustBuffer {
	return LowerIntoRustBuffer[[]*TransactionEffects](c, value)
}

func (c FfiConverterSequenceTransactionEffects) Write(writer io.Writer, value []*TransactionEffects) {
	if len(value) > math.MaxInt32 {
		panic("[]*TransactionEffects is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTransactionEffectsINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceTransactionEffects struct {}

func (FfiDestroyerSequenceTransactionEffects) Destroy(sequence []*TransactionEffects) {
	for _, value := range sequence {
		FfiDestroyerTransactionEffects{}.Destroy(value)
	}
}

type FfiConverterSequenceTypeTag struct{}

var FfiConverterSequenceTypeTagINSTANCE = FfiConverterSequenceTypeTag{}

func (c FfiConverterSequenceTypeTag) Lift(rb RustBufferI) []*TypeTag {
	return LiftFromRustBuffer[[]*TypeTag](c, rb)
}

func (c FfiConverterSequenceTypeTag) Read(reader io.Reader) []*TypeTag {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*TypeTag, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTypeTagINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceTypeTag) Lower(value []*TypeTag) C.RustBuffer {
	return LowerIntoRustBuffer[[]*TypeTag](c, value)
}

func (c FfiConverterSequenceTypeTag) Write(writer io.Writer, value []*TypeTag) {
	if len(value) > math.MaxInt32 {
		panic("[]*TypeTag is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTypeTagINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceTypeTag struct {}

func (FfiDestroyerSequenceTypeTag) Destroy(sequence []*TypeTag) {
	for _, value := range sequence {
		FfiDestroyerTypeTag{}.Destroy(value)
	}
}

type FfiConverterSequenceUserSignature struct{}

var FfiConverterSequenceUserSignatureINSTANCE = FfiConverterSequenceUserSignature{}

func (c FfiConverterSequenceUserSignature) Lift(rb RustBufferI) []*UserSignature {
	return LiftFromRustBuffer[[]*UserSignature](c, rb)
}

func (c FfiConverterSequenceUserSignature) Read(reader io.Reader) []*UserSignature {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*UserSignature, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterUserSignatureINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceUserSignature) Lower(value []*UserSignature) C.RustBuffer {
	return LowerIntoRustBuffer[[]*UserSignature](c, value)
}

func (c FfiConverterSequenceUserSignature) Write(writer io.Writer, value []*UserSignature) {
	if len(value) > math.MaxInt32 {
		panic("[]*UserSignature is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterUserSignatureINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceUserSignature struct {}

func (FfiDestroyerSequenceUserSignature) Destroy(sequence []*UserSignature) {
	for _, value := range sequence {
		FfiDestroyerUserSignature{}.Destroy(value)
	}
}

type FfiConverterSequenceValidatorExecutionTimeObservation struct{}

var FfiConverterSequenceValidatorExecutionTimeObservationINSTANCE = FfiConverterSequenceValidatorExecutionTimeObservation{}

func (c FfiConverterSequenceValidatorExecutionTimeObservation) Lift(rb RustBufferI) []*ValidatorExecutionTimeObservation {
	return LiftFromRustBuffer[[]*ValidatorExecutionTimeObservation](c, rb)
}

func (c FfiConverterSequenceValidatorExecutionTimeObservation) Read(reader io.Reader) []*ValidatorExecutionTimeObservation {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*ValidatorExecutionTimeObservation, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterValidatorExecutionTimeObservationINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceValidatorExecutionTimeObservation) Lower(value []*ValidatorExecutionTimeObservation) C.RustBuffer {
	return LowerIntoRustBuffer[[]*ValidatorExecutionTimeObservation](c, value)
}

func (c FfiConverterSequenceValidatorExecutionTimeObservation) Write(writer io.Writer, value []*ValidatorExecutionTimeObservation) {
	if len(value) > math.MaxInt32 {
		panic("[]*ValidatorExecutionTimeObservation is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterValidatorExecutionTimeObservationINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceValidatorExecutionTimeObservation struct {}

func (FfiDestroyerSequenceValidatorExecutionTimeObservation) Destroy(sequence []*ValidatorExecutionTimeObservation) {
	for _, value := range sequence {
		FfiDestroyerValidatorExecutionTimeObservation{}.Destroy(value)
	}
}

type FfiConverterSequenceVersionAssignment struct{}

var FfiConverterSequenceVersionAssignmentINSTANCE = FfiConverterSequenceVersionAssignment{}

func (c FfiConverterSequenceVersionAssignment) Lift(rb RustBufferI) []*VersionAssignment {
	return LiftFromRustBuffer[[]*VersionAssignment](c, rb)
}

func (c FfiConverterSequenceVersionAssignment) Read(reader io.Reader) []*VersionAssignment {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*VersionAssignment, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterVersionAssignmentINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceVersionAssignment) Lower(value []*VersionAssignment) C.RustBuffer {
	return LowerIntoRustBuffer[[]*VersionAssignment](c, value)
}

func (c FfiConverterSequenceVersionAssignment) Write(writer io.Writer, value []*VersionAssignment) {
	if len(value) > math.MaxInt32 {
		panic("[]*VersionAssignment is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterVersionAssignmentINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceVersionAssignment struct {}

func (FfiDestroyerSequenceVersionAssignment) Destroy(sequence []*VersionAssignment) {
	for _, value := range sequence {
		FfiDestroyerVersionAssignment{}.Destroy(value)
	}
}

type FfiConverterSequenceActiveJwk struct{}

var FfiConverterSequenceActiveJwkINSTANCE = FfiConverterSequenceActiveJwk{}

func (c FfiConverterSequenceActiveJwk) Lift(rb RustBufferI) []ActiveJwk {
	return LiftFromRustBuffer[[]ActiveJwk](c, rb)
}

func (c FfiConverterSequenceActiveJwk) Read(reader io.Reader) []ActiveJwk {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ActiveJwk, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterActiveJwkINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceActiveJwk) Lower(value []ActiveJwk) C.RustBuffer {
	return LowerIntoRustBuffer[[]ActiveJwk](c, value)
}

func (c FfiConverterSequenceActiveJwk) Write(writer io.Writer, value []ActiveJwk) {
	if len(value) > math.MaxInt32 {
		panic("[]ActiveJwk is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterActiveJwkINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceActiveJwk struct {}

func (FfiDestroyerSequenceActiveJwk) Destroy(sequence []ActiveJwk) {
	for _, value := range sequence {
		FfiDestroyerActiveJwk{}.Destroy(value)
	}
}

type FfiConverterSequenceChangedObject struct{}

var FfiConverterSequenceChangedObjectINSTANCE = FfiConverterSequenceChangedObject{}

func (c FfiConverterSequenceChangedObject) Lift(rb RustBufferI) []ChangedObject {
	return LiftFromRustBuffer[[]ChangedObject](c, rb)
}

func (c FfiConverterSequenceChangedObject) Read(reader io.Reader) []ChangedObject {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ChangedObject, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterChangedObjectINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceChangedObject) Lower(value []ChangedObject) C.RustBuffer {
	return LowerIntoRustBuffer[[]ChangedObject](c, value)
}

func (c FfiConverterSequenceChangedObject) Write(writer io.Writer, value []ChangedObject) {
	if len(value) > math.MaxInt32 {
		panic("[]ChangedObject is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterChangedObjectINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceChangedObject struct {}

func (FfiDestroyerSequenceChangedObject) Destroy(sequence []ChangedObject) {
	for _, value := range sequence {
		FfiDestroyerChangedObject{}.Destroy(value)
	}
}

type FfiConverterSequenceCoinInfo struct{}

var FfiConverterSequenceCoinInfoINSTANCE = FfiConverterSequenceCoinInfo{}

func (c FfiConverterSequenceCoinInfo) Lift(rb RustBufferI) []CoinInfo {
	return LiftFromRustBuffer[[]CoinInfo](c, rb)
}

func (c FfiConverterSequenceCoinInfo) Read(reader io.Reader) []CoinInfo {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]CoinInfo, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterCoinInfoINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceCoinInfo) Lower(value []CoinInfo) C.RustBuffer {
	return LowerIntoRustBuffer[[]CoinInfo](c, value)
}

func (c FfiConverterSequenceCoinInfo) Write(writer io.Writer, value []CoinInfo) {
	if len(value) > math.MaxInt32 {
		panic("[]CoinInfo is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterCoinInfoINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceCoinInfo struct {}

func (FfiDestroyerSequenceCoinInfo) Destroy(sequence []CoinInfo) {
	for _, value := range sequence {
		FfiDestroyerCoinInfo{}.Destroy(value)
	}
}

type FfiConverterSequenceDryRunEffect struct{}

var FfiConverterSequenceDryRunEffectINSTANCE = FfiConverterSequenceDryRunEffect{}

func (c FfiConverterSequenceDryRunEffect) Lift(rb RustBufferI) []DryRunEffect {
	return LiftFromRustBuffer[[]DryRunEffect](c, rb)
}

func (c FfiConverterSequenceDryRunEffect) Read(reader io.Reader) []DryRunEffect {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]DryRunEffect, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterDryRunEffectINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceDryRunEffect) Lower(value []DryRunEffect) C.RustBuffer {
	return LowerIntoRustBuffer[[]DryRunEffect](c, value)
}

func (c FfiConverterSequenceDryRunEffect) Write(writer io.Writer, value []DryRunEffect) {
	if len(value) > math.MaxInt32 {
		panic("[]DryRunEffect is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterDryRunEffectINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceDryRunEffect struct {}

func (FfiDestroyerSequenceDryRunEffect) Destroy(sequence []DryRunEffect) {
	for _, value := range sequence {
		FfiDestroyerDryRunEffect{}.Destroy(value)
	}
}

type FfiConverterSequenceDryRunMutation struct{}

var FfiConverterSequenceDryRunMutationINSTANCE = FfiConverterSequenceDryRunMutation{}

func (c FfiConverterSequenceDryRunMutation) Lift(rb RustBufferI) []DryRunMutation {
	return LiftFromRustBuffer[[]DryRunMutation](c, rb)
}

func (c FfiConverterSequenceDryRunMutation) Read(reader io.Reader) []DryRunMutation {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]DryRunMutation, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterDryRunMutationINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceDryRunMutation) Lower(value []DryRunMutation) C.RustBuffer {
	return LowerIntoRustBuffer[[]DryRunMutation](c, value)
}

func (c FfiConverterSequenceDryRunMutation) Write(writer io.Writer, value []DryRunMutation) {
	if len(value) > math.MaxInt32 {
		panic("[]DryRunMutation is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterDryRunMutationINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceDryRunMutation struct {}

func (FfiDestroyerSequenceDryRunMutation) Destroy(sequence []DryRunMutation) {
	for _, value := range sequence {
		FfiDestroyerDryRunMutation{}.Destroy(value)
	}
}

type FfiConverterSequenceDryRunReturn struct{}

var FfiConverterSequenceDryRunReturnINSTANCE = FfiConverterSequenceDryRunReturn{}

func (c FfiConverterSequenceDryRunReturn) Lift(rb RustBufferI) []DryRunReturn {
	return LiftFromRustBuffer[[]DryRunReturn](c, rb)
}

func (c FfiConverterSequenceDryRunReturn) Read(reader io.Reader) []DryRunReturn {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]DryRunReturn, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterDryRunReturnINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceDryRunReturn) Lower(value []DryRunReturn) C.RustBuffer {
	return LowerIntoRustBuffer[[]DryRunReturn](c, value)
}

func (c FfiConverterSequenceDryRunReturn) Write(writer io.Writer, value []DryRunReturn) {
	if len(value) > math.MaxInt32 {
		panic("[]DryRunReturn is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterDryRunReturnINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceDryRunReturn struct {}

func (FfiDestroyerSequenceDryRunReturn) Destroy(sequence []DryRunReturn) {
	for _, value := range sequence {
		FfiDestroyerDryRunReturn{}.Destroy(value)
	}
}

type FfiConverterSequenceDynamicFieldOutput struct{}

var FfiConverterSequenceDynamicFieldOutputINSTANCE = FfiConverterSequenceDynamicFieldOutput{}

func (c FfiConverterSequenceDynamicFieldOutput) Lift(rb RustBufferI) []DynamicFieldOutput {
	return LiftFromRustBuffer[[]DynamicFieldOutput](c, rb)
}

func (c FfiConverterSequenceDynamicFieldOutput) Read(reader io.Reader) []DynamicFieldOutput {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]DynamicFieldOutput, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterDynamicFieldOutputINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceDynamicFieldOutput) Lower(value []DynamicFieldOutput) C.RustBuffer {
	return LowerIntoRustBuffer[[]DynamicFieldOutput](c, value)
}

func (c FfiConverterSequenceDynamicFieldOutput) Write(writer io.Writer, value []DynamicFieldOutput) {
	if len(value) > math.MaxInt32 {
		panic("[]DynamicFieldOutput is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterDynamicFieldOutputINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceDynamicFieldOutput struct {}

func (FfiDestroyerSequenceDynamicFieldOutput) Destroy(sequence []DynamicFieldOutput) {
	for _, value := range sequence {
		FfiDestroyerDynamicFieldOutput{}.Destroy(value)
	}
}

type FfiConverterSequenceEpoch struct{}

var FfiConverterSequenceEpochINSTANCE = FfiConverterSequenceEpoch{}

func (c FfiConverterSequenceEpoch) Lift(rb RustBufferI) []Epoch {
	return LiftFromRustBuffer[[]Epoch](c, rb)
}

func (c FfiConverterSequenceEpoch) Read(reader io.Reader) []Epoch {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]Epoch, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterEpochINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceEpoch) Lower(value []Epoch) C.RustBuffer {
	return LowerIntoRustBuffer[[]Epoch](c, value)
}

func (c FfiConverterSequenceEpoch) Write(writer io.Writer, value []Epoch) {
	if len(value) > math.MaxInt32 {
		panic("[]Epoch is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterEpochINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceEpoch struct {}

func (FfiDestroyerSequenceEpoch) Destroy(sequence []Epoch) {
	for _, value := range sequence {
		FfiDestroyerEpoch{}.Destroy(value)
	}
}

type FfiConverterSequenceEvent struct{}

var FfiConverterSequenceEventINSTANCE = FfiConverterSequenceEvent{}

func (c FfiConverterSequenceEvent) Lift(rb RustBufferI) []Event {
	return LiftFromRustBuffer[[]Event](c, rb)
}

func (c FfiConverterSequenceEvent) Read(reader io.Reader) []Event {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]Event, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterEventINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceEvent) Lower(value []Event) C.RustBuffer {
	return LowerIntoRustBuffer[[]Event](c, value)
}

func (c FfiConverterSequenceEvent) Write(writer io.Writer, value []Event) {
	if len(value) > math.MaxInt32 {
		panic("[]Event is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterEventINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceEvent struct {}

func (FfiDestroyerSequenceEvent) Destroy(sequence []Event) {
	for _, value := range sequence {
		FfiDestroyerEvent{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveEnum struct{}

var FfiConverterSequenceMoveEnumINSTANCE = FfiConverterSequenceMoveEnum{}

func (c FfiConverterSequenceMoveEnum) Lift(rb RustBufferI) []MoveEnum {
	return LiftFromRustBuffer[[]MoveEnum](c, rb)
}

func (c FfiConverterSequenceMoveEnum) Read(reader io.Reader) []MoveEnum {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]MoveEnum, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveEnumINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveEnum) Lower(value []MoveEnum) C.RustBuffer {
	return LowerIntoRustBuffer[[]MoveEnum](c, value)
}

func (c FfiConverterSequenceMoveEnum) Write(writer io.Writer, value []MoveEnum) {
	if len(value) > math.MaxInt32 {
		panic("[]MoveEnum is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveEnumINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveEnum struct {}

func (FfiDestroyerSequenceMoveEnum) Destroy(sequence []MoveEnum) {
	for _, value := range sequence {
		FfiDestroyerMoveEnum{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveEnumVariant struct{}

var FfiConverterSequenceMoveEnumVariantINSTANCE = FfiConverterSequenceMoveEnumVariant{}

func (c FfiConverterSequenceMoveEnumVariant) Lift(rb RustBufferI) []MoveEnumVariant {
	return LiftFromRustBuffer[[]MoveEnumVariant](c, rb)
}

func (c FfiConverterSequenceMoveEnumVariant) Read(reader io.Reader) []MoveEnumVariant {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]MoveEnumVariant, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveEnumVariantINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveEnumVariant) Lower(value []MoveEnumVariant) C.RustBuffer {
	return LowerIntoRustBuffer[[]MoveEnumVariant](c, value)
}

func (c FfiConverterSequenceMoveEnumVariant) Write(writer io.Writer, value []MoveEnumVariant) {
	if len(value) > math.MaxInt32 {
		panic("[]MoveEnumVariant is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveEnumVariantINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveEnumVariant struct {}

func (FfiDestroyerSequenceMoveEnumVariant) Destroy(sequence []MoveEnumVariant) {
	for _, value := range sequence {
		FfiDestroyerMoveEnumVariant{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveField struct{}

var FfiConverterSequenceMoveFieldINSTANCE = FfiConverterSequenceMoveField{}

func (c FfiConverterSequenceMoveField) Lift(rb RustBufferI) []MoveField {
	return LiftFromRustBuffer[[]MoveField](c, rb)
}

func (c FfiConverterSequenceMoveField) Read(reader io.Reader) []MoveField {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]MoveField, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveFieldINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveField) Lower(value []MoveField) C.RustBuffer {
	return LowerIntoRustBuffer[[]MoveField](c, value)
}

func (c FfiConverterSequenceMoveField) Write(writer io.Writer, value []MoveField) {
	if len(value) > math.MaxInt32 {
		panic("[]MoveField is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveFieldINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveField struct {}

func (FfiDestroyerSequenceMoveField) Destroy(sequence []MoveField) {
	for _, value := range sequence {
		FfiDestroyerMoveField{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveFunctionTypeParameter struct{}

var FfiConverterSequenceMoveFunctionTypeParameterINSTANCE = FfiConverterSequenceMoveFunctionTypeParameter{}

func (c FfiConverterSequenceMoveFunctionTypeParameter) Lift(rb RustBufferI) []MoveFunctionTypeParameter {
	return LiftFromRustBuffer[[]MoveFunctionTypeParameter](c, rb)
}

func (c FfiConverterSequenceMoveFunctionTypeParameter) Read(reader io.Reader) []MoveFunctionTypeParameter {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]MoveFunctionTypeParameter, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveFunctionTypeParameterINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveFunctionTypeParameter) Lower(value []MoveFunctionTypeParameter) C.RustBuffer {
	return LowerIntoRustBuffer[[]MoveFunctionTypeParameter](c, value)
}

func (c FfiConverterSequenceMoveFunctionTypeParameter) Write(writer io.Writer, value []MoveFunctionTypeParameter) {
	if len(value) > math.MaxInt32 {
		panic("[]MoveFunctionTypeParameter is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveFunctionTypeParameterINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveFunctionTypeParameter struct {}

func (FfiDestroyerSequenceMoveFunctionTypeParameter) Destroy(sequence []MoveFunctionTypeParameter) {
	for _, value := range sequence {
		FfiDestroyerMoveFunctionTypeParameter{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveModuleQuery struct{}

var FfiConverterSequenceMoveModuleQueryINSTANCE = FfiConverterSequenceMoveModuleQuery{}

func (c FfiConverterSequenceMoveModuleQuery) Lift(rb RustBufferI) []MoveModuleQuery {
	return LiftFromRustBuffer[[]MoveModuleQuery](c, rb)
}

func (c FfiConverterSequenceMoveModuleQuery) Read(reader io.Reader) []MoveModuleQuery {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]MoveModuleQuery, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveModuleQueryINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveModuleQuery) Lower(value []MoveModuleQuery) C.RustBuffer {
	return LowerIntoRustBuffer[[]MoveModuleQuery](c, value)
}

func (c FfiConverterSequenceMoveModuleQuery) Write(writer io.Writer, value []MoveModuleQuery) {
	if len(value) > math.MaxInt32 {
		panic("[]MoveModuleQuery is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveModuleQueryINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveModuleQuery struct {}

func (FfiDestroyerSequenceMoveModuleQuery) Destroy(sequence []MoveModuleQuery) {
	for _, value := range sequence {
		FfiDestroyerMoveModuleQuery{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveStructQuery struct{}

var FfiConverterSequenceMoveStructQueryINSTANCE = FfiConverterSequenceMoveStructQuery{}

func (c FfiConverterSequenceMoveStructQuery) Lift(rb RustBufferI) []MoveStructQuery {
	return LiftFromRustBuffer[[]MoveStructQuery](c, rb)
}

func (c FfiConverterSequenceMoveStructQuery) Read(reader io.Reader) []MoveStructQuery {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]MoveStructQuery, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveStructQueryINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveStructQuery) Lower(value []MoveStructQuery) C.RustBuffer {
	return LowerIntoRustBuffer[[]MoveStructQuery](c, value)
}

func (c FfiConverterSequenceMoveStructQuery) Write(writer io.Writer, value []MoveStructQuery) {
	if len(value) > math.MaxInt32 {
		panic("[]MoveStructQuery is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveStructQueryINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveStructQuery struct {}

func (FfiDestroyerSequenceMoveStructQuery) Destroy(sequence []MoveStructQuery) {
	for _, value := range sequence {
		FfiDestroyerMoveStructQuery{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveStructTypeParameter struct{}

var FfiConverterSequenceMoveStructTypeParameterINSTANCE = FfiConverterSequenceMoveStructTypeParameter{}

func (c FfiConverterSequenceMoveStructTypeParameter) Lift(rb RustBufferI) []MoveStructTypeParameter {
	return LiftFromRustBuffer[[]MoveStructTypeParameter](c, rb)
}

func (c FfiConverterSequenceMoveStructTypeParameter) Read(reader io.Reader) []MoveStructTypeParameter {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]MoveStructTypeParameter, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveStructTypeParameterINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveStructTypeParameter) Lower(value []MoveStructTypeParameter) C.RustBuffer {
	return LowerIntoRustBuffer[[]MoveStructTypeParameter](c, value)
}

func (c FfiConverterSequenceMoveStructTypeParameter) Write(writer io.Writer, value []MoveStructTypeParameter) {
	if len(value) > math.MaxInt32 {
		panic("[]MoveStructTypeParameter is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveStructTypeParameterINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveStructTypeParameter struct {}

func (FfiDestroyerSequenceMoveStructTypeParameter) Destroy(sequence []MoveStructTypeParameter) {
	for _, value := range sequence {
		FfiDestroyerMoveStructTypeParameter{}.Destroy(value)
	}
}

type FfiConverterSequenceObjectRef struct{}

var FfiConverterSequenceObjectRefINSTANCE = FfiConverterSequenceObjectRef{}

func (c FfiConverterSequenceObjectRef) Lift(rb RustBufferI) []ObjectRef {
	return LiftFromRustBuffer[[]ObjectRef](c, rb)
}

func (c FfiConverterSequenceObjectRef) Read(reader io.Reader) []ObjectRef {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ObjectRef, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterObjectRefINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceObjectRef) Lower(value []ObjectRef) C.RustBuffer {
	return LowerIntoRustBuffer[[]ObjectRef](c, value)
}

func (c FfiConverterSequenceObjectRef) Write(writer io.Writer, value []ObjectRef) {
	if len(value) > math.MaxInt32 {
		panic("[]ObjectRef is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterObjectRefINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceObjectRef struct {}

func (FfiDestroyerSequenceObjectRef) Destroy(sequence []ObjectRef) {
	for _, value := range sequence {
		FfiDestroyerObjectRef{}.Destroy(value)
	}
}

type FfiConverterSequenceObjectReference struct{}

var FfiConverterSequenceObjectReferenceINSTANCE = FfiConverterSequenceObjectReference{}

func (c FfiConverterSequenceObjectReference) Lift(rb RustBufferI) []ObjectReference {
	return LiftFromRustBuffer[[]ObjectReference](c, rb)
}

func (c FfiConverterSequenceObjectReference) Read(reader io.Reader) []ObjectReference {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ObjectReference, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterObjectReferenceINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceObjectReference) Lower(value []ObjectReference) C.RustBuffer {
	return LowerIntoRustBuffer[[]ObjectReference](c, value)
}

func (c FfiConverterSequenceObjectReference) Write(writer io.Writer, value []ObjectReference) {
	if len(value) > math.MaxInt32 {
		panic("[]ObjectReference is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterObjectReferenceINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceObjectReference struct {}

func (FfiDestroyerSequenceObjectReference) Destroy(sequence []ObjectReference) {
	for _, value := range sequence {
		FfiDestroyerObjectReference{}.Destroy(value)
	}
}

type FfiConverterSequenceOpenMoveType struct{}

var FfiConverterSequenceOpenMoveTypeINSTANCE = FfiConverterSequenceOpenMoveType{}

func (c FfiConverterSequenceOpenMoveType) Lift(rb RustBufferI) []OpenMoveType {
	return LiftFromRustBuffer[[]OpenMoveType](c, rb)
}

func (c FfiConverterSequenceOpenMoveType) Read(reader io.Reader) []OpenMoveType {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]OpenMoveType, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterOpenMoveTypeINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceOpenMoveType) Lower(value []OpenMoveType) C.RustBuffer {
	return LowerIntoRustBuffer[[]OpenMoveType](c, value)
}

func (c FfiConverterSequenceOpenMoveType) Write(writer io.Writer, value []OpenMoveType) {
	if len(value) > math.MaxInt32 {
		panic("[]OpenMoveType is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterOpenMoveTypeINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceOpenMoveType struct {}

func (FfiDestroyerSequenceOpenMoveType) Destroy(sequence []OpenMoveType) {
	for _, value := range sequence {
		FfiDestroyerOpenMoveType{}.Destroy(value)
	}
}

type FfiConverterSequenceProtocolConfigAttr struct{}

var FfiConverterSequenceProtocolConfigAttrINSTANCE = FfiConverterSequenceProtocolConfigAttr{}

func (c FfiConverterSequenceProtocolConfigAttr) Lift(rb RustBufferI) []ProtocolConfigAttr {
	return LiftFromRustBuffer[[]ProtocolConfigAttr](c, rb)
}

func (c FfiConverterSequenceProtocolConfigAttr) Read(reader io.Reader) []ProtocolConfigAttr {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ProtocolConfigAttr, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterProtocolConfigAttrINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceProtocolConfigAttr) Lower(value []ProtocolConfigAttr) C.RustBuffer {
	return LowerIntoRustBuffer[[]ProtocolConfigAttr](c, value)
}

func (c FfiConverterSequenceProtocolConfigAttr) Write(writer io.Writer, value []ProtocolConfigAttr) {
	if len(value) > math.MaxInt32 {
		panic("[]ProtocolConfigAttr is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterProtocolConfigAttrINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceProtocolConfigAttr struct {}

func (FfiDestroyerSequenceProtocolConfigAttr) Destroy(sequence []ProtocolConfigAttr) {
	for _, value := range sequence {
		FfiDestroyerProtocolConfigAttr{}.Destroy(value)
	}
}

type FfiConverterSequenceProtocolConfigFeatureFlag struct{}

var FfiConverterSequenceProtocolConfigFeatureFlagINSTANCE = FfiConverterSequenceProtocolConfigFeatureFlag{}

func (c FfiConverterSequenceProtocolConfigFeatureFlag) Lift(rb RustBufferI) []ProtocolConfigFeatureFlag {
	return LiftFromRustBuffer[[]ProtocolConfigFeatureFlag](c, rb)
}

func (c FfiConverterSequenceProtocolConfigFeatureFlag) Read(reader io.Reader) []ProtocolConfigFeatureFlag {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ProtocolConfigFeatureFlag, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterProtocolConfigFeatureFlagINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceProtocolConfigFeatureFlag) Lower(value []ProtocolConfigFeatureFlag) C.RustBuffer {
	return LowerIntoRustBuffer[[]ProtocolConfigFeatureFlag](c, value)
}

func (c FfiConverterSequenceProtocolConfigFeatureFlag) Write(writer io.Writer, value []ProtocolConfigFeatureFlag) {
	if len(value) > math.MaxInt32 {
		panic("[]ProtocolConfigFeatureFlag is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterProtocolConfigFeatureFlagINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceProtocolConfigFeatureFlag struct {}

func (FfiDestroyerSequenceProtocolConfigFeatureFlag) Destroy(sequence []ProtocolConfigFeatureFlag) {
	for _, value := range sequence {
		FfiDestroyerProtocolConfigFeatureFlag{}.Destroy(value)
	}
}

type FfiConverterSequenceSignedTransaction struct{}

var FfiConverterSequenceSignedTransactionINSTANCE = FfiConverterSequenceSignedTransaction{}

func (c FfiConverterSequenceSignedTransaction) Lift(rb RustBufferI) []SignedTransaction {
	return LiftFromRustBuffer[[]SignedTransaction](c, rb)
}

func (c FfiConverterSequenceSignedTransaction) Read(reader io.Reader) []SignedTransaction {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]SignedTransaction, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterSignedTransactionINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceSignedTransaction) Lower(value []SignedTransaction) C.RustBuffer {
	return LowerIntoRustBuffer[[]SignedTransaction](c, value)
}

func (c FfiConverterSequenceSignedTransaction) Write(writer io.Writer, value []SignedTransaction) {
	if len(value) > math.MaxInt32 {
		panic("[]SignedTransaction is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterSignedTransactionINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceSignedTransaction struct {}

func (FfiDestroyerSequenceSignedTransaction) Destroy(sequence []SignedTransaction) {
	for _, value := range sequence {
		FfiDestroyerSignedTransaction{}.Destroy(value)
	}
}

type FfiConverterSequenceTransactionDataEffects struct{}

var FfiConverterSequenceTransactionDataEffectsINSTANCE = FfiConverterSequenceTransactionDataEffects{}

func (c FfiConverterSequenceTransactionDataEffects) Lift(rb RustBufferI) []TransactionDataEffects {
	return LiftFromRustBuffer[[]TransactionDataEffects](c, rb)
}

func (c FfiConverterSequenceTransactionDataEffects) Read(reader io.Reader) []TransactionDataEffects {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]TransactionDataEffects, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTransactionDataEffectsINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceTransactionDataEffects) Lower(value []TransactionDataEffects) C.RustBuffer {
	return LowerIntoRustBuffer[[]TransactionDataEffects](c, value)
}

func (c FfiConverterSequenceTransactionDataEffects) Write(writer io.Writer, value []TransactionDataEffects) {
	if len(value) > math.MaxInt32 {
		panic("[]TransactionDataEffects is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTransactionDataEffectsINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceTransactionDataEffects struct {}

func (FfiDestroyerSequenceTransactionDataEffects) Destroy(sequence []TransactionDataEffects) {
	for _, value := range sequence {
		FfiDestroyerTransactionDataEffects{}.Destroy(value)
	}
}

type FfiConverterSequenceTypeOrigin struct{}

var FfiConverterSequenceTypeOriginINSTANCE = FfiConverterSequenceTypeOrigin{}

func (c FfiConverterSequenceTypeOrigin) Lift(rb RustBufferI) []TypeOrigin {
	return LiftFromRustBuffer[[]TypeOrigin](c, rb)
}

func (c FfiConverterSequenceTypeOrigin) Read(reader io.Reader) []TypeOrigin {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]TypeOrigin, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTypeOriginINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceTypeOrigin) Lower(value []TypeOrigin) C.RustBuffer {
	return LowerIntoRustBuffer[[]TypeOrigin](c, value)
}

func (c FfiConverterSequenceTypeOrigin) Write(writer io.Writer, value []TypeOrigin) {
	if len(value) > math.MaxInt32 {
		panic("[]TypeOrigin is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTypeOriginINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceTypeOrigin struct {}

func (FfiDestroyerSequenceTypeOrigin) Destroy(sequence []TypeOrigin) {
	for _, value := range sequence {
		FfiDestroyerTypeOrigin{}.Destroy(value)
	}
}

type FfiConverterSequenceUnchangedSharedObject struct{}

var FfiConverterSequenceUnchangedSharedObjectINSTANCE = FfiConverterSequenceUnchangedSharedObject{}

func (c FfiConverterSequenceUnchangedSharedObject) Lift(rb RustBufferI) []UnchangedSharedObject {
	return LiftFromRustBuffer[[]UnchangedSharedObject](c, rb)
}

func (c FfiConverterSequenceUnchangedSharedObject) Read(reader io.Reader) []UnchangedSharedObject {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]UnchangedSharedObject, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterUnchangedSharedObjectINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceUnchangedSharedObject) Lower(value []UnchangedSharedObject) C.RustBuffer {
	return LowerIntoRustBuffer[[]UnchangedSharedObject](c, value)
}

func (c FfiConverterSequenceUnchangedSharedObject) Write(writer io.Writer, value []UnchangedSharedObject) {
	if len(value) > math.MaxInt32 {
		panic("[]UnchangedSharedObject is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterUnchangedSharedObjectINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceUnchangedSharedObject struct {}

func (FfiDestroyerSequenceUnchangedSharedObject) Destroy(sequence []UnchangedSharedObject) {
	for _, value := range sequence {
		FfiDestroyerUnchangedSharedObject{}.Destroy(value)
	}
}

type FfiConverterSequenceValidator struct{}

var FfiConverterSequenceValidatorINSTANCE = FfiConverterSequenceValidator{}

func (c FfiConverterSequenceValidator) Lift(rb RustBufferI) []Validator {
	return LiftFromRustBuffer[[]Validator](c, rb)
}

func (c FfiConverterSequenceValidator) Read(reader io.Reader) []Validator {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]Validator, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterValidatorINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceValidator) Lower(value []Validator) C.RustBuffer {
	return LowerIntoRustBuffer[[]Validator](c, value)
}

func (c FfiConverterSequenceValidator) Write(writer io.Writer, value []Validator) {
	if len(value) > math.MaxInt32 {
		panic("[]Validator is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterValidatorINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceValidator struct {}

func (FfiDestroyerSequenceValidator) Destroy(sequence []Validator) {
	for _, value := range sequence {
		FfiDestroyerValidator{}.Destroy(value)
	}
}

type FfiConverterSequenceValidatorCommitteeMember struct{}

var FfiConverterSequenceValidatorCommitteeMemberINSTANCE = FfiConverterSequenceValidatorCommitteeMember{}

func (c FfiConverterSequenceValidatorCommitteeMember) Lift(rb RustBufferI) []ValidatorCommitteeMember {
	return LiftFromRustBuffer[[]ValidatorCommitteeMember](c, rb)
}

func (c FfiConverterSequenceValidatorCommitteeMember) Read(reader io.Reader) []ValidatorCommitteeMember {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ValidatorCommitteeMember, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterValidatorCommitteeMemberINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceValidatorCommitteeMember) Lower(value []ValidatorCommitteeMember) C.RustBuffer {
	return LowerIntoRustBuffer[[]ValidatorCommitteeMember](c, value)
}

func (c FfiConverterSequenceValidatorCommitteeMember) Write(writer io.Writer, value []ValidatorCommitteeMember) {
	if len(value) > math.MaxInt32 {
		panic("[]ValidatorCommitteeMember is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterValidatorCommitteeMemberINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceValidatorCommitteeMember struct {}

func (FfiDestroyerSequenceValidatorCommitteeMember) Destroy(sequence []ValidatorCommitteeMember) {
	for _, value := range sequence {
		FfiDestroyerValidatorCommitteeMember{}.Destroy(value)
	}
}

type FfiConverterSequenceFeature struct{}

var FfiConverterSequenceFeatureINSTANCE = FfiConverterSequenceFeature{}

func (c FfiConverterSequenceFeature) Lift(rb RustBufferI) []Feature {
	return LiftFromRustBuffer[[]Feature](c, rb)
}

func (c FfiConverterSequenceFeature) Read(reader io.Reader) []Feature {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]Feature, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterFeatureINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceFeature) Lower(value []Feature) C.RustBuffer {
	return LowerIntoRustBuffer[[]Feature](c, value)
}

func (c FfiConverterSequenceFeature) Write(writer io.Writer, value []Feature) {
	if len(value) > math.MaxInt32 {
		panic("[]Feature is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterFeatureINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceFeature struct {}

func (FfiDestroyerSequenceFeature) Destroy(sequence []Feature) {
	for _, value := range sequence {
		FfiDestroyerFeature{}.Destroy(value)
	}
}

type FfiConverterSequenceMoveAbility struct{}

var FfiConverterSequenceMoveAbilityINSTANCE = FfiConverterSequenceMoveAbility{}

func (c FfiConverterSequenceMoveAbility) Lift(rb RustBufferI) []MoveAbility {
	return LiftFromRustBuffer[[]MoveAbility](c, rb)
}

func (c FfiConverterSequenceMoveAbility) Read(reader io.Reader) []MoveAbility {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]MoveAbility, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMoveAbilityINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMoveAbility) Lower(value []MoveAbility) C.RustBuffer {
	return LowerIntoRustBuffer[[]MoveAbility](c, value)
}

func (c FfiConverterSequenceMoveAbility) Write(writer io.Writer, value []MoveAbility) {
	if len(value) > math.MaxInt32 {
		panic("[]MoveAbility is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMoveAbilityINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMoveAbility struct {}

func (FfiDestroyerSequenceMoveAbility) Destroy(sequence []MoveAbility) {
	for _, value := range sequence {
		FfiDestroyerMoveAbility{}.Destroy(value)
	}
}

type FfiConverterMapStringSequenceString struct {}

var FfiConverterMapStringSequenceStringINSTANCE = FfiConverterMapStringSequenceString{}

func (c FfiConverterMapStringSequenceString) Lift(rb RustBufferI) map[string][]string {
	return LiftFromRustBuffer[map[string][]string](c, rb)
}

func (_ FfiConverterMapStringSequenceString) Read(reader io.Reader) map[string][]string {
	result := make(map[string][]string)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterStringINSTANCE.Read(reader)
		value := FfiConverterSequenceStringINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapStringSequenceString) Lower(value map[string][]string) C.RustBuffer {
	return LowerIntoRustBuffer[map[string][]string](c, value)
}

func (_ FfiConverterMapStringSequenceString) Write(writer io.Writer, mapValue map[string][]string) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string][]string is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterStringINSTANCE.Write(writer, key)
		FfiConverterSequenceStringINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapStringSequenceString struct {}

func (_ FfiDestroyerMapStringSequenceString) Destroy(mapValue map[string][]string) {
	for key, value := range mapValue {
		FfiDestroyerString{}.Destroy(key)
		FfiDestroyerSequenceString{}.Destroy(value)
	}
}

type FfiConverterMapIdentifierBytes struct {}

var FfiConverterMapIdentifierBytesINSTANCE = FfiConverterMapIdentifierBytes{}

func (c FfiConverterMapIdentifierBytes) Lift(rb RustBufferI) map[*Identifier][]byte {
	return LiftFromRustBuffer[map[*Identifier][]byte](c, rb)
}

func (_ FfiConverterMapIdentifierBytes) Read(reader io.Reader) map[*Identifier][]byte {
	result := make(map[*Identifier][]byte)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterIdentifierINSTANCE.Read(reader)
		value := FfiConverterBytesINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapIdentifierBytes) Lower(value map[*Identifier][]byte) C.RustBuffer {
	return LowerIntoRustBuffer[map[*Identifier][]byte](c, value)
}

func (_ FfiConverterMapIdentifierBytes) Write(writer io.Writer, mapValue map[*Identifier][]byte) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[*Identifier][]byte is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterIdentifierINSTANCE.Write(writer, key)
		FfiConverterBytesINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapIdentifierBytes struct {}

func (_ FfiDestroyerMapIdentifierBytes) Destroy(mapValue map[*Identifier][]byte) {
	for key, value := range mapValue {
		FfiDestroyerIdentifier{}.Destroy(key)
		FfiDestroyerBytes{}.Destroy(value)
	}
}

type FfiConverterMapObjectIdUpgradeInfo struct {}

var FfiConverterMapObjectIdUpgradeInfoINSTANCE = FfiConverterMapObjectIdUpgradeInfo{}

func (c FfiConverterMapObjectIdUpgradeInfo) Lift(rb RustBufferI) map[*ObjectId]UpgradeInfo {
	return LiftFromRustBuffer[map[*ObjectId]UpgradeInfo](c, rb)
}

func (_ FfiConverterMapObjectIdUpgradeInfo) Read(reader io.Reader) map[*ObjectId]UpgradeInfo {
	result := make(map[*ObjectId]UpgradeInfo)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterObjectIdINSTANCE.Read(reader)
		value := FfiConverterUpgradeInfoINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapObjectIdUpgradeInfo) Lower(value map[*ObjectId]UpgradeInfo) C.RustBuffer {
	return LowerIntoRustBuffer[map[*ObjectId]UpgradeInfo](c, value)
}

func (_ FfiConverterMapObjectIdUpgradeInfo) Write(writer io.Writer, mapValue map[*ObjectId]UpgradeInfo) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[*ObjectId]UpgradeInfo is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterObjectIdINSTANCE.Write(writer, key)
		FfiConverterUpgradeInfoINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapObjectIdUpgradeInfo struct {}

func (_ FfiDestroyerMapObjectIdUpgradeInfo) Destroy(mapValue map[*ObjectId]UpgradeInfo) {
	for key, value := range mapValue {
		FfiDestroyerObjectId{}.Destroy(key)
		FfiDestroyerUpgradeInfo{}.Destroy(value)
	}
}

type FfiConverterMapJwkIdJwk struct {}

var FfiConverterMapJwkIdJwkINSTANCE = FfiConverterMapJwkIdJwk{}

func (c FfiConverterMapJwkIdJwk) Lift(rb RustBufferI) map[JwkId]Jwk {
	return LiftFromRustBuffer[map[JwkId]Jwk](c, rb)
}

func (_ FfiConverterMapJwkIdJwk) Read(reader io.Reader) map[JwkId]Jwk {
	result := make(map[JwkId]Jwk)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterJwkIdINSTANCE.Read(reader)
		value := FfiConverterJwkINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapJwkIdJwk) Lower(value map[JwkId]Jwk) C.RustBuffer {
	return LowerIntoRustBuffer[map[JwkId]Jwk](c, value)
}

func (_ FfiConverterMapJwkIdJwk) Write(writer io.Writer, mapValue map[JwkId]Jwk) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[JwkId]Jwk is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterJwkIdINSTANCE.Write(writer, key)
		FfiConverterJwkINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapJwkIdJwk struct {}

func (_ FfiDestroyerMapJwkIdJwk) Destroy(mapValue map[JwkId]Jwk) {
	for key, value := range mapValue {
		FfiDestroyerJwkId{}.Destroy(key)
		FfiDestroyerJwk{}.Destroy(value)
	}
}
/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type Base64 = string
type FfiConverterTypeBase64 = FfiConverterString
type FfiDestroyerTypeBase64 = FfiDestroyerString
var FfiConverterTypeBase64INSTANCE = FfiConverterString{}
/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type BigInt = string
type FfiConverterTypeBigInt = FfiConverterString
type FfiDestroyerTypeBigInt = FfiDestroyerString
var FfiConverterTypeBigIntINSTANCE = FfiConverterString{}
/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type Value = string
type FfiConverterTypeValue = FfiConverterString
type FfiDestroyerTypeValue = FfiDestroyerString
var FfiConverterTypeValueINSTANCE = FfiConverterString{}


const (
	uniffiRustFuturePollReady      int8 = 0
	uniffiRustFuturePollMaybeReady int8 = 1
)

type rustFuturePollFunc func(C.uint64_t, C.UniffiRustFutureContinuationCallback, C.uint64_t)
type rustFutureCompleteFunc[T any] func(C.uint64_t, *C.RustCallStatus) T
type rustFutureFreeFunc func(C.uint64_t)

//export iota_sdk_uniffiFutureContinuationCallback
func iota_sdk_uniffiFutureContinuationCallback(data C.uint64_t, pollResult C.int8_t) {
	h := cgo.Handle(uintptr(data))
	waiter := h.Value().(chan int8)
	waiter <- int8(pollResult)
}

func uniffiRustCallAsync[E any, T any, F any](
	errConverter BufReader[*E],
	completeFunc rustFutureCompleteFunc[F],
	liftFunc func(F) T,
	rustFuture C.uint64_t,
	pollFunc rustFuturePollFunc,
	freeFunc rustFutureFreeFunc,
) (T, *E) {
	defer freeFunc(rustFuture)

	pollResult := int8(-1)
	waiter := make(chan int8, 1)

	chanHandle := cgo.NewHandle(waiter)
	defer chanHandle.Delete()

	for pollResult != uniffiRustFuturePollReady {
		pollFunc(
			rustFuture,
			(C.UniffiRustFutureContinuationCallback)(C.iota_sdk_uniffiFutureContinuationCallback),
			C.uint64_t(chanHandle),
		)
		pollResult = <-waiter
	}

	var goValue T
	var ffiValue F
	var err *E

	ffiValue, err = rustCallWithError(errConverter, func(status *C.RustCallStatus) F {
		return completeFunc(rustFuture, status)
	})
	if err != nil {
		return goValue, err
	}
	return liftFunc(ffiValue), nil
}

//export iota_sdk_uniffiFreeGorutine
func iota_sdk_uniffiFreeGorutine(data C.uint64_t) {
	handle := cgo.Handle(uintptr(data))
	defer handle.Delete()

	guard := handle.Value().(chan struct{})
	guard <- struct{}{}
}

// Create this type from BCS encoded bytes.
func ActiveJwkFromBcs(bcs []byte) (ActiveJwk, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_active_jwk_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ActiveJwk
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterActiveJwkINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ActiveJwkToBcs(data ActiveJwk) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_active_jwk_to_bcs(FfiConverterActiveJwkINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func AddressFromBcs(bcs []byte) (*Address, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_address_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Address
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterAddressINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func AddressToBcs(data *Address) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_address_to_bcs(FfiConverterAddressINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ArgumentFromBcs(bcs []byte) (*Argument, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_argument_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Argument
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterArgumentINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ArgumentToBcs(data *Argument) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_argument_to_bcs(FfiConverterArgumentINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func AuthenticatorStateExpireFromBcs(bcs []byte) (AuthenticatorStateExpire, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_authenticator_state_expire_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue AuthenticatorStateExpire
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterAuthenticatorStateExpireINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func AuthenticatorStateExpireToBcs(data AuthenticatorStateExpire) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_authenticator_state_expire_to_bcs(FfiConverterAuthenticatorStateExpireINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func AuthenticatorStateUpdateV1FromBcs(bcs []byte) (AuthenticatorStateUpdateV1, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_authenticator_state_update_v1_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue AuthenticatorStateUpdateV1
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterAuthenticatorStateUpdateV1INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func AuthenticatorStateUpdateV1ToBcs(data AuthenticatorStateUpdateV1) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_authenticator_state_update_v1_to_bcs(FfiConverterAuthenticatorStateUpdateV1INSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

func Base64Decode(input string) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_base64_decode(FfiConverterStringINSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

func Base64Encode(input []byte) string {
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_base64_encode(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus),
	}
	}))
}

// Create this type from BCS encoded bytes.
func Bls12381PublicKeyFromBcs(bcs []byte) (*Bls12381PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_bls12381_public_key_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bls12381PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBls12381PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func Bls12381PublicKeyToBcs(data *Bls12381PublicKey) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_bls12381_public_key_to_bcs(FfiConverterBls12381PublicKeyINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func Bls12381SignatureFromBcs(bcs []byte) (*Bls12381Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_bls12381_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bls12381Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBls12381SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func Bls12381SignatureToBcs(data *Bls12381Signature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_bls12381_signature_to_bcs(FfiConverterBls12381SignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func Bn254FieldElementFromBcs(bcs []byte) (*Bn254FieldElement, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_bn254_field_element_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Bn254FieldElement
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBn254FieldElementINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func Bn254FieldElementToBcs(data *Bn254FieldElement) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_bn254_field_element_to_bcs(FfiConverterBn254FieldElementINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create a bool from BCS encoded bytes.
func BoolFromBcs(input []byte) (bool, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_func_bool_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue bool
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBoolINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this bool to BCS encoded bytes.
func BoolToBcs(input bool) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_bool_to_bcs(FfiConverterBoolINSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func CancelledTransactionFromBcs(bcs []byte) (*CancelledTransaction, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_cancelled_transaction_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *CancelledTransaction
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCancelledTransactionINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func CancelledTransactionToBcs(data *CancelledTransaction) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_cancelled_transaction_to_bcs(FfiConverterCancelledTransactionINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ChangeEpochFromBcs(bcs []byte) (*ChangeEpoch, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_change_epoch_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ChangeEpoch
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterChangeEpochINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ChangeEpochToBcs(data *ChangeEpoch) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_change_epoch_to_bcs(FfiConverterChangeEpochINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ChangeEpochV2FromBcs(bcs []byte) (*ChangeEpochV2, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_change_epoch_v2_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ChangeEpochV2
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterChangeEpochV2INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ChangeEpochV2ToBcs(data *ChangeEpochV2) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_change_epoch_v2_to_bcs(FfiConverterChangeEpochV2INSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ChangedObjectFromBcs(bcs []byte) (ChangedObject, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_changed_object_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ChangedObject
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterChangedObjectINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ChangedObjectToBcs(data ChangedObject) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_changed_object_to_bcs(FfiConverterChangedObjectINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func CheckpointCommitmentFromBcs(bcs []byte) (*CheckpointCommitment, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_checkpoint_commitment_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *CheckpointCommitment
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCheckpointCommitmentINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func CheckpointCommitmentToBcs(data *CheckpointCommitment) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_checkpoint_commitment_to_bcs(FfiConverterCheckpointCommitmentINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func CheckpointContentsFromBcs(bcs []byte) (*CheckpointContents, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_checkpoint_contents_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *CheckpointContents
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCheckpointContentsINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func CheckpointContentsToBcs(data *CheckpointContents) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_checkpoint_contents_to_bcs(FfiConverterCheckpointContentsINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func CheckpointSummaryFromBcs(bcs []byte) (*CheckpointSummary, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_checkpoint_summary_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *CheckpointSummary
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCheckpointSummaryINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func CheckpointSummaryToBcs(data *CheckpointSummary) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_checkpoint_summary_to_bcs(FfiConverterCheckpointSummaryINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func CheckpointTransactionInfoFromBcs(bcs []byte) (*CheckpointTransactionInfo, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_checkpoint_transaction_info_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *CheckpointTransactionInfo
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCheckpointTransactionInfoINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func CheckpointTransactionInfoToBcs(data *CheckpointTransactionInfo) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_checkpoint_transaction_info_to_bcs(FfiConverterCheckpointTransactionInfoINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func CircomG1FromBcs(bcs []byte) (*CircomG1, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_circom_g1_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *CircomG1
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCircomG1INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func CircomG1ToBcs(data *CircomG1) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_circom_g1_to_bcs(FfiConverterCircomG1INSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func CircomG2FromBcs(bcs []byte) (*CircomG2, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_circom_g2_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *CircomG2
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCircomG2INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func CircomG2ToBcs(data *CircomG2) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_circom_g2_to_bcs(FfiConverterCircomG2INSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func CommandArgumentErrorFromBcs(bcs []byte) (CommandArgumentError, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_command_argument_error_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue CommandArgumentError
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCommandArgumentErrorINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func CommandArgumentErrorToBcs(data CommandArgumentError) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_command_argument_error_to_bcs(FfiConverterCommandArgumentErrorINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func CommandFromBcs(bcs []byte) (*Command, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_command_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Command
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterCommandINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func CommandToBcs(data *Command) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_command_to_bcs(FfiConverterCommandINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ConsensusCommitPrologueV1FromBcs(bcs []byte) (*ConsensusCommitPrologueV1, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_consensus_commit_prologue_v1_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ConsensusCommitPrologueV1
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterConsensusCommitPrologueV1INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ConsensusCommitPrologueV1ToBcs(data *ConsensusCommitPrologueV1) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_consensus_commit_prologue_v1_to_bcs(FfiConverterConsensusCommitPrologueV1INSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ConsensusDeterminedVersionAssignmentsFromBcs(bcs []byte) (*ConsensusDeterminedVersionAssignments, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_consensus_determined_version_assignments_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ConsensusDeterminedVersionAssignments
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterConsensusDeterminedVersionAssignmentsINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ConsensusDeterminedVersionAssignmentsToBcs(data *ConsensusDeterminedVersionAssignments) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_consensus_determined_version_assignments_to_bcs(FfiConverterConsensusDeterminedVersionAssignmentsINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func DigestFromBcs(bcs []byte) (*Digest, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_digest_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Digest
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterDigestINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func DigestToBcs(data *Digest) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_digest_to_bcs(FfiConverterDigestINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func Ed25519PublicKeyFromBcs(bcs []byte) (*Ed25519PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_ed25519_public_key_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func Ed25519PublicKeyToBcs(data *Ed25519PublicKey) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_ed25519_public_key_to_bcs(FfiConverterEd25519PublicKeyINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func Ed25519SignatureFromBcs(bcs []byte) (*Ed25519Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_ed25519_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Ed25519Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEd25519SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func Ed25519SignatureToBcs(data *Ed25519Signature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_ed25519_signature_to_bcs(FfiConverterEd25519SignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func EndOfEpochDataFromBcs(bcs []byte) (EndOfEpochData, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_end_of_epoch_data_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue EndOfEpochData
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEndOfEpochDataINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func EndOfEpochDataToBcs(data EndOfEpochData) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_end_of_epoch_data_to_bcs(FfiConverterEndOfEpochDataINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func EventFromBcs(bcs []byte) (Event, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_event_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue Event
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterEventINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func EventToBcs(data Event) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_event_to_bcs(FfiConverterEventINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ExecutionErrorFromBcs(bcs []byte) (ExecutionError, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_execution_error_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ExecutionError
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterExecutionErrorINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ExecutionErrorToBcs(data ExecutionError) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_execution_error_to_bcs(FfiConverterExecutionErrorINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ExecutionStatusFromBcs(bcs []byte) (ExecutionStatus, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_execution_status_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ExecutionStatus
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterExecutionStatusINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ExecutionStatusToBcs(data ExecutionStatus) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_execution_status_to_bcs(FfiConverterExecutionStatusINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ExecutionTimeObservationFromBcs(bcs []byte) (*ExecutionTimeObservation, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ExecutionTimeObservation
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterExecutionTimeObservationINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ExecutionTimeObservationKeyFromBcs(bcs []byte) (*ExecutionTimeObservationKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_key_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ExecutionTimeObservationKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterExecutionTimeObservationKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ExecutionTimeObservationKeyToBcs(data *ExecutionTimeObservationKey) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_key_to_bcs(FfiConverterExecutionTimeObservationKeyINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ExecutionTimeObservationToBcs(data *ExecutionTimeObservation) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_to_bcs(FfiConverterExecutionTimeObservationINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ExecutionTimeObservationsFromBcs(bcs []byte) (*ExecutionTimeObservations, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_execution_time_observations_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ExecutionTimeObservations
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterExecutionTimeObservationsINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ExecutionTimeObservationsToBcs(data *ExecutionTimeObservations) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_execution_time_observations_to_bcs(FfiConverterExecutionTimeObservationsINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func GasCostSummaryFromBcs(bcs []byte) (GasCostSummary, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_gas_cost_summary_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue GasCostSummary
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterGasCostSummaryINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func GasCostSummaryToBcs(data GasCostSummary) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_gas_cost_summary_to_bcs(FfiConverterGasCostSummaryINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func GasPaymentFromBcs(bcs []byte) (GasPayment, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_gas_payment_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue GasPayment
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterGasPaymentINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func GasPaymentToBcs(data GasPayment) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_gas_payment_to_bcs(FfiConverterGasPaymentINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Generate a new BIP-39 mnemonic in English.
// Supported word counts are 12 and 24 (default).
func GenerateMnemonic(wordCount *MnemonicLength) string {
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_generate_mnemonic(FfiConverterOptionalMnemonicLengthINSTANCE.Lower(wordCount),_uniffiStatus),
	}
	}))
}

// Create this type from BCS encoded bytes.
func GenesisObjectFromBcs(bcs []byte) (*GenesisObject, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_genesis_object_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *GenesisObject
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterGenesisObjectINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func GenesisObjectToBcs(data *GenesisObject) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_genesis_object_to_bcs(FfiConverterGenesisObjectINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func GenesisTransactionFromBcs(bcs []byte) (*GenesisTransaction, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_genesis_transaction_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *GenesisTransaction
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterGenesisTransactionINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func GenesisTransactionToBcs(data *GenesisTransaction) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_genesis_transaction_to_bcs(FfiConverterGenesisTransactionINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

func HexDecode(input string) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_hex_decode(FfiConverterStringINSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

func HexEncode(input []byte) string {
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_hex_encode(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus),
	}
	}))
}

// Create a i16 from BCS encoded bytes.
func I16FromBcs(input []byte) (int16, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) C.int16_t {
		return C.uniffi_iota_sdk_ffi_fn_func_i16_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue int16
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterInt16INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this i16 to BCS encoded bytes.
func I16ToBcs(input int16) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_i16_to_bcs(FfiConverterInt16INSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create a i32 from BCS encoded bytes.
func I32FromBcs(input []byte) (int32, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) C.int32_t {
		return C.uniffi_iota_sdk_ffi_fn_func_i32_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue int32
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterInt32INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this i32 to BCS encoded bytes.
func I32ToBcs(input int32) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_i32_to_bcs(FfiConverterInt32INSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create a i64 from BCS encoded bytes.
func I64FromBcs(input []byte) (int64, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) C.int64_t {
		return C.uniffi_iota_sdk_ffi_fn_func_i64_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue int64
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterInt64INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this i64 to BCS encoded bytes.
func I64ToBcs(input int64) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_i64_to_bcs(FfiConverterInt64INSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create a i8 from BCS encoded bytes.
func I8FromBcs(input []byte) (int8, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_iota_sdk_ffi_fn_func_i8_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue int8
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterInt8INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this i8 to BCS encoded bytes.
func I8ToBcs(input int8) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_i8_to_bcs(FfiConverterInt8INSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func IdOperationFromBcs(bcs []byte) (IdOperation, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_id_operation_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue IdOperation
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterIdOperationINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func IdOperationToBcs(data IdOperation) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_id_operation_to_bcs(FfiConverterIdOperationINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func IdentifierFromBcs(bcs []byte) (*Identifier, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_identifier_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Identifier
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterIdentifierINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func IdentifierToBcs(data *Identifier) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_identifier_to_bcs(FfiConverterIdentifierINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func InputFromBcs(bcs []byte) (*Input, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_input_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Input
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterInputINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func InputToBcs(data *Input) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_input_to_bcs(FfiConverterInputINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func JwkFromBcs(bcs []byte) (Jwk, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_jwk_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue Jwk
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterJwkINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func JwkIdFromBcs(bcs []byte) (JwkId, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_jwk_id_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue JwkId
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterJwkIdINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func JwkIdToBcs(data JwkId) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_jwk_id_to_bcs(FfiConverterJwkIdINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func JwkToBcs(data Jwk) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_jwk_to_bcs(FfiConverterJwkINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MakeMoveVectorFromBcs(bcs []byte) (*MakeMoveVector, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_make_move_vector_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MakeMoveVector
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMakeMoveVectorINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MakeMoveVectorToBcs(data *MakeMoveVector) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_make_move_vector_to_bcs(FfiConverterMakeMoveVectorINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MergeCoinsFromBcs(bcs []byte) (*MergeCoins, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_merge_coins_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MergeCoins
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMergeCoinsINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MergeCoinsToBcs(data *MergeCoins) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_merge_coins_to_bcs(FfiConverterMergeCoinsINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MoveCallFromBcs(bcs []byte) (*MoveCall, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_move_call_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MoveCall
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveCallINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MoveCallToBcs(data *MoveCall) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_move_call_to_bcs(FfiConverterMoveCallINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MoveLocationFromBcs(bcs []byte) (MoveLocation, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_move_location_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue MoveLocation
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveLocationINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MoveLocationToBcs(data MoveLocation) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_move_location_to_bcs(FfiConverterMoveLocationINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MovePackageFromBcs(bcs []byte) (*MovePackage, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_move_package_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MovePackage
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMovePackageINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MovePackageToBcs(data *MovePackage) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_move_package_to_bcs(FfiConverterMovePackageINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MoveStructFromBcs(bcs []byte) (MoveStruct, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_move_struct_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue MoveStruct
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMoveStructINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MoveStructToBcs(data MoveStruct) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_move_struct_to_bcs(FfiConverterMoveStructINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MultisigAggregatedSignatureFromBcs(bcs []byte) (*MultisigAggregatedSignature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_multisig_aggregated_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MultisigAggregatedSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMultisigAggregatedSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MultisigAggregatedSignatureToBcs(data *MultisigAggregatedSignature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_multisig_aggregated_signature_to_bcs(FfiConverterMultisigAggregatedSignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MultisigCommitteeFromBcs(bcs []byte) (*MultisigCommittee, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_multisig_committee_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MultisigCommittee
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMultisigCommitteeINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MultisigCommitteeToBcs(data *MultisigCommittee) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_multisig_committee_to_bcs(FfiConverterMultisigCommitteeINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MultisigMemberFromBcs(bcs []byte) (*MultisigMember, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_multisig_member_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MultisigMember
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMultisigMemberINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MultisigMemberPublicKeyFromBcs(bcs []byte) (*MultisigMemberPublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_multisig_member_public_key_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MultisigMemberPublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMultisigMemberPublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MultisigMemberPublicKeyToBcs(data *MultisigMemberPublicKey) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_multisig_member_public_key_to_bcs(FfiConverterMultisigMemberPublicKeyINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func MultisigMemberSignatureFromBcs(bcs []byte) (*MultisigMemberSignature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_multisig_member_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *MultisigMemberSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterMultisigMemberSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MultisigMemberSignatureToBcs(data *MultisigMemberSignature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_multisig_member_signature_to_bcs(FfiConverterMultisigMemberSignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func MultisigMemberToBcs(data *MultisigMember) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_multisig_member_to_bcs(FfiConverterMultisigMemberINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ObjectDataFromBcs(bcs []byte) (*ObjectData, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_object_data_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ObjectData
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterObjectDataINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ObjectDataToBcs(data *ObjectData) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_object_data_to_bcs(FfiConverterObjectDataINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ObjectFromBcs(bcs []byte) (*Object, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_object_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Object
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterObjectINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ObjectIdFromBcs(bcs []byte) (*ObjectId, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_object_id_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ObjectId
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterObjectIdINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ObjectIdToBcs(data *ObjectId) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_object_id_to_bcs(FfiConverterObjectIdINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ObjectInFromBcs(bcs []byte) (ObjectIn, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_object_in_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ObjectIn
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterObjectInINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ObjectInToBcs(data ObjectIn) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_object_in_to_bcs(FfiConverterObjectInINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ObjectOutFromBcs(bcs []byte) (ObjectOut, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_object_out_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ObjectOut
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterObjectOutINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ObjectOutToBcs(data ObjectOut) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_object_out_to_bcs(FfiConverterObjectOutINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ObjectReferenceFromBcs(bcs []byte) (ObjectReference, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_object_reference_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ObjectReference
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterObjectReferenceINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ObjectReferenceToBcs(data ObjectReference) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_object_reference_to_bcs(FfiConverterObjectReferenceINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ObjectToBcs(data *Object) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_object_to_bcs(FfiConverterObjectINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func OwnerFromBcs(bcs []byte) (*Owner, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_owner_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Owner
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterOwnerINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func OwnerToBcs(data *Owner) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_owner_to_bcs(FfiConverterOwnerINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func PackageUpgradeErrorFromBcs(bcs []byte) (PackageUpgradeError, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_package_upgrade_error_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue PackageUpgradeError
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPackageUpgradeErrorINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func PackageUpgradeErrorToBcs(data PackageUpgradeError) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_package_upgrade_error_to_bcs(FfiConverterPackageUpgradeErrorINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func PasskeyAuthenticatorFromBcs(bcs []byte) (*PasskeyAuthenticator, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_passkey_authenticator_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *PasskeyAuthenticator
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPasskeyAuthenticatorINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func PasskeyAuthenticatorToBcs(data *PasskeyAuthenticator) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_passkey_authenticator_to_bcs(FfiConverterPasskeyAuthenticatorINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ProgrammableTransactionFromBcs(bcs []byte) (*ProgrammableTransaction, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_programmable_transaction_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ProgrammableTransaction
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterProgrammableTransactionINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ProgrammableTransactionToBcs(data *ProgrammableTransaction) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_programmable_transaction_to_bcs(FfiConverterProgrammableTransactionINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func PublishFromBcs(bcs []byte) (*Publish, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_publish_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Publish
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterPublishINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func PublishToBcs(data *Publish) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_publish_to_bcs(FfiConverterPublishINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func RandomnessStateUpdateFromBcs(bcs []byte) (RandomnessStateUpdate, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_randomness_state_update_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue RandomnessStateUpdate
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterRandomnessStateUpdateINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func RandomnessStateUpdateToBcs(data RandomnessStateUpdate) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_randomness_state_update_to_bcs(FfiConverterRandomnessStateUpdateINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func Secp256k1PublicKeyFromBcs(bcs []byte) (*Secp256k1PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_secp256k1_public_key_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func Secp256k1PublicKeyToBcs(data *Secp256k1PublicKey) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_secp256k1_public_key_to_bcs(FfiConverterSecp256k1PublicKeyINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func Secp256k1SignatureFromBcs(bcs []byte) (*Secp256k1Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_secp256k1_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256k1Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256k1SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func Secp256k1SignatureToBcs(data *Secp256k1Signature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_secp256k1_signature_to_bcs(FfiConverterSecp256k1SignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func Secp256r1PublicKeyFromBcs(bcs []byte) (*Secp256r1PublicKey, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_secp256r1_public_key_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1PublicKey
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1PublicKeyINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func Secp256r1PublicKeyToBcs(data *Secp256r1PublicKey) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_secp256r1_public_key_to_bcs(FfiConverterSecp256r1PublicKeyINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func Secp256r1SignatureFromBcs(bcs []byte) (*Secp256r1Signature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_secp256r1_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Secp256r1Signature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSecp256r1SignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func Secp256r1SignatureToBcs(data *Secp256r1Signature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_secp256r1_signature_to_bcs(FfiConverterSecp256r1SignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func SignedTransactionFromBcs(bcs []byte) (SignedTransaction, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_signed_transaction_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue SignedTransaction
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSignedTransactionINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func SignedTransactionToBcs(data SignedTransaction) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_signed_transaction_to_bcs(FfiConverterSignedTransactionINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func SimpleSignatureFromBcs(bcs []byte) (*SimpleSignature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_simple_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SimpleSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSimpleSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func SimpleSignatureToBcs(data *SimpleSignature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_simple_signature_to_bcs(FfiConverterSimpleSignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func SplitCoinsFromBcs(bcs []byte) (*SplitCoins, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_split_coins_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SplitCoins
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSplitCoinsINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func SplitCoinsToBcs(data *SplitCoins) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_split_coins_to_bcs(FfiConverterSplitCoinsINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create a String from BCS encoded bytes.
func StringFromBcs(input []byte) (string, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_string_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue string
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this String to BCS encoded bytes.
func StringToBcs(input string) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_string_to_bcs(FfiConverterStringINSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func StructTagFromBcs(bcs []byte) (*StructTag, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_struct_tag_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *StructTag
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterStructTagINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func StructTagToBcs(data *StructTag) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_struct_tag_to_bcs(FfiConverterStructTagINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func SystemPackageFromBcs(bcs []byte) (*SystemPackage, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_system_package_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *SystemPackage
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterSystemPackageINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func SystemPackageToBcs(data *SystemPackage) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_system_package_to_bcs(FfiConverterSystemPackageINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TransactionEffectsFromBcs(bcs []byte) (*TransactionEffects, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_transaction_effects_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *TransactionEffects
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionEffectsINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TransactionEffectsToBcs(data *TransactionEffects) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transaction_effects_to_bcs(FfiConverterTransactionEffectsINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TransactionEffectsV1FromBcs(bcs []byte) (TransactionEffectsV1, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transaction_effects_v1_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue TransactionEffectsV1
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionEffectsV1INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TransactionEffectsV1ToBcs(data TransactionEffectsV1) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transaction_effects_v1_to_bcs(FfiConverterTransactionEffectsV1INSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TransactionEventsFromBcs(bcs []byte) (*TransactionEvents, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_transaction_events_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *TransactionEvents
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionEventsINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TransactionEventsToBcs(data *TransactionEvents) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transaction_events_to_bcs(FfiConverterTransactionEventsINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TransactionExpirationFromBcs(bcs []byte) (TransactionExpiration, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transaction_expiration_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue TransactionExpiration
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionExpirationINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TransactionExpirationToBcs(data TransactionExpiration) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transaction_expiration_to_bcs(FfiConverterTransactionExpirationINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TransactionFromBcs(bcs []byte) (*Transaction, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_transaction_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Transaction
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TransactionKindFromBcs(bcs []byte) (*TransactionKind, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_transaction_kind_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *TransactionKind
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionKindINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TransactionKindToBcs(data *TransactionKind) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transaction_kind_to_bcs(FfiConverterTransactionKindINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TransactionToBcs(data *Transaction) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transaction_to_bcs(FfiConverterTransactionINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TransactionV1FromBcs(bcs []byte) (*TransactionV1, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_transaction_v1_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *TransactionV1
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransactionV1INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TransactionV1ToBcs(data *TransactionV1) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transaction_v1_to_bcs(FfiConverterTransactionV1INSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TransferObjectsFromBcs(bcs []byte) (*TransferObjects, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_transfer_objects_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *TransferObjects
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTransferObjectsINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TransferObjectsToBcs(data *TransferObjects) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_transfer_objects_to_bcs(FfiConverterTransferObjectsINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TypeArgumentErrorFromBcs(bcs []byte) (TypeArgumentError, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_type_argument_error_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue TypeArgumentError
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTypeArgumentErrorINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TypeArgumentErrorToBcs(data TypeArgumentError) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_type_argument_error_to_bcs(FfiConverterTypeArgumentErrorINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TypeOriginFromBcs(bcs []byte) (TypeOrigin, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_type_origin_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue TypeOrigin
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTypeOriginINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TypeOriginToBcs(data TypeOrigin) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_type_origin_to_bcs(FfiConverterTypeOriginINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func TypeTagFromBcs(bcs []byte) (*TypeTag, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_type_tag_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *TypeTag
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterTypeTagINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func TypeTagToBcs(data *TypeTag) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_type_tag_to_bcs(FfiConverterTypeTagINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create a u16 from BCS encoded bytes.
func U16FromBcs(input []byte) (uint16, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.uniffi_iota_sdk_ffi_fn_func_u16_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue uint16
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUint16INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this u16 to BCS encoded bytes.
func U16ToBcs(input uint16) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_u16_to_bcs(FfiConverterUint16INSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create a u32 from BCS encoded bytes.
func U32FromBcs(input []byte) (uint32, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) C.uint32_t {
		return C.uniffi_iota_sdk_ffi_fn_func_u32_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue uint32
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUint32INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this u32 to BCS encoded bytes.
func U32ToBcs(input uint32) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_u32_to_bcs(FfiConverterUint32INSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create a u64 from BCS encoded bytes.
func U64FromBcs(input []byte) (uint64, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_iota_sdk_ffi_fn_func_u64_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue uint64
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUint64INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this u64 to BCS encoded bytes.
func U64ToBcs(input uint64) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_u64_to_bcs(FfiConverterUint64INSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create a u8 from BCS encoded bytes.
func U8FromBcs(input []byte) (uint8, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) C.uint8_t {
		return C.uniffi_iota_sdk_ffi_fn_func_u8_from_bcs(FfiConverterBytesINSTANCE.Lower(input),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue uint8
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUint8INSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this u8 to BCS encoded bytes.
func U8ToBcs(input uint8) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_u8_to_bcs(FfiConverterUint8INSTANCE.Lower(input),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func UnchangedSharedKindFromBcs(bcs []byte) (UnchangedSharedKind, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_kind_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue UnchangedSharedKind
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUnchangedSharedKindINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func UnchangedSharedKindToBcs(data UnchangedSharedKind) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_kind_to_bcs(FfiConverterUnchangedSharedKindINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func UnchangedSharedObjectFromBcs(bcs []byte) (UnchangedSharedObject, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_object_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue UnchangedSharedObject
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUnchangedSharedObjectINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func UnchangedSharedObjectToBcs(data UnchangedSharedObject) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_object_to_bcs(FfiConverterUnchangedSharedObjectINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func UpgradeFromBcs(bcs []byte) (*Upgrade, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_upgrade_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *Upgrade
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUpgradeINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func UpgradeInfoFromBcs(bcs []byte) (UpgradeInfo, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_upgrade_info_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue UpgradeInfo
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUpgradeInfoINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func UpgradeInfoToBcs(data UpgradeInfo) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_upgrade_info_to_bcs(FfiConverterUpgradeInfoINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func UpgradeToBcs(data *Upgrade) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_upgrade_to_bcs(FfiConverterUpgradeINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func UserSignatureFromBcs(bcs []byte) (*UserSignature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_user_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *UserSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterUserSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func UserSignatureToBcs(data *UserSignature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_user_signature_to_bcs(FfiConverterUserSignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ValidatorAggregatedSignatureFromBcs(bcs []byte) (*ValidatorAggregatedSignature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_validator_aggregated_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ValidatorAggregatedSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterValidatorAggregatedSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ValidatorAggregatedSignatureToBcs(data *ValidatorAggregatedSignature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_validator_aggregated_signature_to_bcs(FfiConverterValidatorAggregatedSignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ValidatorCommitteeFromBcs(bcs []byte) (ValidatorCommittee, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_validator_committee_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ValidatorCommittee
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterValidatorCommitteeINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ValidatorCommitteeMemberFromBcs(bcs []byte) (ValidatorCommitteeMember, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_validator_committee_member_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ValidatorCommitteeMember
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterValidatorCommitteeMemberINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ValidatorCommitteeMemberToBcs(data ValidatorCommitteeMember) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_validator_committee_member_to_bcs(FfiConverterValidatorCommitteeMemberINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ValidatorCommitteeToBcs(data ValidatorCommittee) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_validator_committee_to_bcs(FfiConverterValidatorCommitteeINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ValidatorExecutionTimeObservationFromBcs(bcs []byte) (*ValidatorExecutionTimeObservation, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_validator_execution_time_observation_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ValidatorExecutionTimeObservation
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterValidatorExecutionTimeObservationINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ValidatorExecutionTimeObservationToBcs(data *ValidatorExecutionTimeObservation) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_validator_execution_time_observation_to_bcs(FfiConverterValidatorExecutionTimeObservationINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ValidatorSignatureFromBcs(bcs []byte) (*ValidatorSignature, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_validator_signature_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ValidatorSignature
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterValidatorSignatureINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ValidatorSignatureToBcs(data *ValidatorSignature) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_validator_signature_to_bcs(FfiConverterValidatorSignatureINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func VersionAssignmentFromBcs(bcs []byte) (*VersionAssignment, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_version_assignment_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *VersionAssignment
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterVersionAssignmentINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func VersionAssignmentToBcs(data *VersionAssignment) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_version_assignment_to_bcs(FfiConverterVersionAssignmentINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ZkLoginAuthenticatorFromBcs(bcs []byte) (*ZkLoginAuthenticator, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_zk_login_authenticator_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ZkLoginAuthenticator
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterZkLoginAuthenticatorINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ZkLoginAuthenticatorToBcs(data *ZkLoginAuthenticator) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_zk_login_authenticator_to_bcs(FfiConverterZkLoginAuthenticatorINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ZkLoginClaimFromBcs(bcs []byte) (ZkLoginClaim, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_zk_login_claim_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue ZkLoginClaim
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterZkLoginClaimINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ZkLoginClaimToBcs(data ZkLoginClaim) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_zk_login_claim_to_bcs(FfiConverterZkLoginClaimINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ZkLoginProofFromBcs(bcs []byte) (*ZkLoginProof, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_zk_login_proof_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ZkLoginProof
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterZkLoginProofINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ZkLoginProofToBcs(data *ZkLoginProof) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_zk_login_proof_to_bcs(FfiConverterZkLoginProofINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

// Create this type from BCS encoded bytes.
func ZkLoginPublicIdentifierFromBcs(bcs []byte) (*ZkLoginPublicIdentifier, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_iota_sdk_ffi_fn_func_zk_login_public_identifier_from_bcs(FfiConverterBytesINSTANCE.Lower(bcs),_uniffiStatus)
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue *ZkLoginPublicIdentifier
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterZkLoginPublicIdentifierINSTANCE.Lift(_uniffiRV), nil
		}
}

// Convert this type to BCS encoded bytes.
func ZkLoginPublicIdentifierToBcs(data *ZkLoginPublicIdentifier) ([]byte, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[SdkFfiError](FfiConverterSdkFfiError{},func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer {
		inner: C.uniffi_iota_sdk_ffi_fn_func_zk_login_public_identifier_to_bcs(FfiConverterZkLoginPublicIdentifierINSTANCE.Lower(data),_uniffiStatus),
	}
	})
		if _uniffiErr != nil {
			var _uniffiDefaultValue []byte
			return _uniffiDefaultValue, _uniffiErr
		} else {
			return FfiConverterBytesINSTANCE.Lift(_uniffiRV), nil
		}
}

